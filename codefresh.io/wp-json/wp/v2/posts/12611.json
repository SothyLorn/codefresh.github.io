{"id":12611,"date":"2018-12-27T21:36:34","date_gmt":"2018-12-27T21:36:34","guid":{"rendered":"http:\/\/codefresh.io\/?p=12611"},"modified":"2022-02-09T14:32:43","modified_gmt":"2022-02-09T14:32:43","slug":"codefresh-versus-jenkins-x","status":"publish","type":"post","link":"https:\/\/codefresh.io\/continuous-deployment\/codefresh-versus-jenkins-x\/","title":{"rendered":"Codefresh versus Jenkins X"},"content":{"rendered":"<p>In a previous blog post, we saw how <a href=\"https:\/\/codefresh.io\/continuous-deployment\/codefresh-versus-jenkins\/\">Codefresh compared to Jenkins<\/a>. In that post, the major takeaway is the fact that Codefresh is a solution for both builds and deployments (CI\/CD) while Jenkins does not support any deployments on its own (only CI).<\/p>\n<p>Jenkins X has recently been announced and it is has been introduced as a native <a href=\"https:\/\/codefresh.io\/continuous-integration\/continuous-integration-delivery-pipeline-important\/\">CI\/CD solution<\/a> for Kubernetes. It adds deployment capabilities to plain <a href=\"https:\/\/codefresh.io\/continuous-deployment\/codefresh-versus-jenkins\/\">Jenkins<\/a> and also makes entities such as environments and deployments a first-class citizen.<\/p>\n<p>In theory, Jenkins X is a step in the right direction especially for organizations that are moving into containers and Kubernetes clusters. It therefore makes sense to see how this new project stands up against Codefresh, the CI\/CD solution that was developed with Docker\/Helm\/Kubernetes support right from its inception.<\/p>\n<p>In practice, Jenkins X has some very strong opinions on the software lifecycle which might not always agree with the processes of your organization.<\/p>\n<h2>Jenkins X is still using Jenkins 2.x behind the scenes inheriting all its problems<\/h2>\n<p>This is probably the most important point to understand regarding Jenkins X. Jenkins X is NOT a new version of Jenkins, or even a rewrite. It is only a collection of existing services that still include Jenkins at its core. If you deploy Jenkins X on a cluster you can easily look at all the individual components:<\/p>\n<figure id=\"attachment_12615\" aria-describedby=\"caption-attachment-12615\" style=\"width: 887px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/12\/jenkinsx-components.png\"><img class=\"size-full wp-image-12615\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/12\/jenkinsx-components.png\" alt=\"Jenkins X components\" width=\"887\" height=\"378\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/12\/jenkinsx-components.png 887w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/12\/jenkinsx-components-300x128.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/12\/jenkinsx-components-768x327.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/12\/jenkinsx-components-628x268.png 628w\" sizes=\"(max-width: 887px) 100vw, 887px\" \/><\/a><figcaption id=\"caption-attachment-12615\" class=\"wp-caption-text\">Jenkins X components<\/figcaption><\/figure>\n<p>Jenkins X is just Jenkins plus <a href=\"https:\/\/github.com\/helm\/chartmuseum\">Chartmuseum<\/a>, <a href=\"https:\/\/www.sonatype.com\/nexus-repository-sonatype\">Nexus<\/a>, <a href=\"https:\/\/www.mongodb.com\/\">Mongo<\/a>, <a href=\"https:\/\/github.com\/helm\/monocular\">Monocular<\/a>, etc. The main new addition is the jx executable which is responsible for installing and managing JX installations.<\/p>\n<p><strong>Fun fact<\/strong>: Chartmuseum is actually a Codefresh project!<\/p>\n<figure id=\"attachment_12633\" aria-describedby=\"caption-attachment-12633\" style=\"width: 539px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/12\/chart-museum.png\"><img class=\"size-full wp-image-12633\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/12\/chart-museum.png\" alt=\"Jenkins X uses a Codefresh project\" width=\"539\" height=\"77\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/12\/chart-museum.png 539w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/12\/chart-museum-300x43.png 300w\" sizes=\"(max-width: 539px) 100vw, 539px\" \/><\/a><figcaption id=\"caption-attachment-12633\" class=\"wp-caption-text\">Jenkins X uses a Codefresh project<\/figcaption><\/figure>\n<p>This means that Jenkins X is essentially a superset of plain Jenkins. Of course it adds new deployment abilities to the mix but it also inherits all existing problems. Most points we have mentioned in the <a href=\"https:\/\/codefresh.io\/continuous-deployment\/codefresh-versus-jenkins\/\">original comparison<\/a> are still true:<\/p>\n<ul>\n<li>Plugins and shared libraries are still present<\/li>\n<li>Upgrading and configuring the Jenkins server is still an issue<\/li>\n<li>Extending the platform requires Groovy\/Java knowledge<\/li>\n<\/ul>\n<p>You can even visit the URL of Jenkins in a Jenkins X installation and see the familiar UI.<\/p>\n<figure id=\"attachment_12616\" aria-describedby=\"caption-attachment-12616\" style=\"width: 1492px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/12\/jenkinsx.png\"><img class=\"size-full wp-image-12616\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/12\/jenkinsx.png\" alt=\"Jenkins 2 inside Jenkins X\" width=\"1492\" height=\"892\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/12\/jenkinsx.png 1492w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/12\/jenkinsx-300x179.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/12\/jenkinsx-768x459.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/12\/jenkinsx-1024x612.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/12\/jenkinsx-549x328.png 549w\" sizes=\"(max-width: 1492px) 100vw, 1492px\" \/><\/a><figcaption id=\"caption-attachment-12616\" class=\"wp-caption-text\">Jenkins 2 inside Jenkins X<\/figcaption><\/figure>\n<p>What is more troubling is that all Jenkins configuration options are still valid. So if you want to change the default Docker registry, for example, you still need to manage it via the Jenkins UI.<\/p>\n<p>Another downside of the inclusion of all these off-the-shelf tools is the high system requirements. Gone are the days where you could just download the Jenkins war on your laptop and try it out. I tried to install Jenkins X on my laptop and failed simply because of lack of resources.<\/p>\n<p>The recommended installation mode is to use a cloud provider with 5 nodes of 20-30GBs or RAM. I tried to get away with just 3 nodes and was not even able to compile\/deploy the official quickstart application.<\/p>\n<h2>Jenkins X deploys only on Kubernetes clusters, Codefresh can deploy anywhere<\/h2>\n<p>Kubernetes popularity is currently exploding and Jenkins X contains native support for Kubernetes deployments. The problem, however, is that Jenkins X can ONLY deploy on Kubernetes clusters and nothing else.<\/p>\n<p>All new Jenkins X concepts such as environments, previews, and promotions are always targeting a namespace in a Kubernetes cluster. You can still use Jenkins X for compiling and packaging any kind of application, but the continuous delivery part is strictly constrained to Kubernetes clusters.<\/p>\n<p>Codefresh, on the other hand, can deploy everywhere. Even though there is native support for Helm and Kubernetes dashboards, you can use Codefresh to deploy to Virtual machines, Docker Swarm, Bare Metal clusters, FTP sites, and any other deployment target you can imagine.<\/p>\n<p>This means that Codefresh has a clear advantage for organizations that are migrating to Kubernetes while still having legacy applications around, as Codefresh can be used in a gradual way.<\/p>\n<h2>Jenkins X requires Helm, in Codefresh Helm is optional<\/h2>\n<p><a href=\"https:\/\/helm.sh\/\">Helm <\/a>is the package manager for Kubernetes that allows you to group multiple microservices together, manage templates for Kubernetes manifests and also perform easy rollbacks to previous releases.<\/p>\n<p>Codefresh has native support for Helm by offering a private Helm repository and a dedicated Helm dashboard.<\/p>\n<figure id=\"attachment_12618\" aria-describedby=\"caption-attachment-12618\" style=\"width: 1048px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/12\/Helm-Releases.png\"><img class=\"size-full wp-image-12618\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/12\/Helm-Releases.png\" alt=\"Codefresh Helm Dashboard\" width=\"1048\" height=\"670\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/12\/Helm-Releases.png 1048w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/12\/Helm-Releases-300x192.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/12\/Helm-Releases-768x491.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/12\/Helm-Releases-1024x655.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/12\/Helm-Releases-513x328.png 513w\" sizes=\"(max-width: 1048px) 100vw, 1048px\" \/><\/a><figcaption id=\"caption-attachment-12618\" class=\"wp-caption-text\">Codefresh Helm Dashboard<\/figcaption><\/figure>\n<p>We love Helm and we believe it is the future of Kubernetes deployments. However, you don\u2019t have to adopt Helm in order to use Codefresh.<\/p>\n<p>In Codefresh the usage of Helm is strictly optional. As mentioned in the previous section you can use Codefresh to deploy anywhere including plain Kubernetes clusters without Helm installed. We have several customers that are using Kubernetes without Helm and some of the facilities we offer such as <a href=\"https:\/\/codefresh.io\/kubernetes-tutorial\/fully-automated-blue-green-deployments-kubernetes-codefresh\/\">blue\/green<\/a> and <a href=\"https:\/\/codefresh.io\/kubernetes-tutorial\/fully-automated-canary-deployments-kubernetes\/\">canary deployments<\/a> are designed with that in mind.<\/p>\n<p>Jenkins X, on the other hand, <strong>REQUIRES <\/strong>the adoption of Helm. All deployments happen via Helm as the only option.<\/p>\n<p>Helm is also used to represent complete environments (the Helm umbrella pattern). The GIT repositories that back each environment are based on Helm charts.<\/p>\n<p>We love the fact that Jenkins X has adopted Helm, but making it the only deployment option is a very aggressive stance for organizations that want to deploy legacy applications as well.<\/p>\n<p>Representing an environment with a Helm umbrella chart is a good practice but in Codefresh this is just one of the many ways that you can do deployments.<\/p>\n<h2>Jenkins X enforces trunk based development, Codefresh allows any git workflow<\/h2>\n<p>From the previous sections, it should become clear that Jenkins X is a very opinionated solution that has a strong preference on how deployments are handled.<\/p>\n<p>The problem is that these strong opinions also extend to how development happens during the integration phase. Jenkins X is designed around trunk based development. The mainline branch is what is always deployed and merging a pull request also implies a new release.<\/p>\n<p>Trunk-based development is not bad on its own, but again there several organizations that have selected other strategies which are better suited for their needs. The ever-popular gitflow paradigm might be losing popularity in the last years, but in some cases, it really is a better solution. Jenkins X does not support it at all.<\/p>\n<p>There are several organizations where even the concept of a single \u201cproduction\u201d branch might not exist at all. In some cases, there are several production branches (i.e. where releases are happening from) and adopting them in Jenkins X would be a difficult if not impossible task.<\/p>\n<p>Codefresh does not enforce a specific git methodology. You can use any git workflow you want.<\/p>\n<figure id=\"attachment_12619\" aria-describedby=\"caption-attachment-12619\" style=\"width: 1871px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/12\/pipelines.png\"><img class=\"size-full wp-image-12619\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/12\/pipelines.png\" alt=\"Example of Codefresh pipeline\" width=\"1871\" height=\"845\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/12\/pipelines.png 1871w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/12\/pipelines-300x135.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/12\/pipelines-768x347.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/12\/pipelines-1024x462.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/12\/pipelines-628x284.png 628w\" sizes=\"(max-width: 1871px) 100vw, 1871px\" \/><\/a><figcaption id=\"caption-attachment-12619\" class=\"wp-caption-text\">Example of Codefresh pipeline<\/figcaption><\/figure>\n<p>A similar situation occurs with versioning. Jenkins X is designed around semantic versioning of Git tags. Codefresh does not enforce any specific versioning pattern.<\/p>\n<p>In summary, with Codefresh you are free to choose your own workflow. With Jenkins X there is only a single way of doing things.<\/p>\n<h2>Jenkins X has no Graphical interface, Codefresh offers built-in GUI dashboards<\/h2>\n<p>Jenkins X does not have a UI on its own. The only UI present is the one from Jenkins which, as we have already explained, knows only about jobs and builds. In the case of a headless install, not even that UI is available.<\/p>\n<p>This means that all the new Jenkins X constructs such as deployments, applications, and environments are only available in the command line.<\/p>\n<p>The command line is great for developers and engineers who want to manage Jenkins X, but very inflexible when it comes to getting a general overview of everything that is happening. If Jenkins X is installed in a big organization, several non-developers (e.g. project manager, QA lead) will need an easy way to see what their team is doing.<\/p>\n<p>Unfortunately, at its present state, <strong>only the JX executable<\/strong> offers a view of the Jenkins X flows via the command line.<\/p>\n<p>Codefresh has a full UI for both CI and CD parts of the software lifecycle that includes everything in a single place. There are graphical dashboards for:<\/p>\n<ul>\n<li>Git Repos<\/li>\n<li>Pipelines<\/li>\n<li>Builds<\/li>\n<li>Docker images<\/li>\n<li>Helm repository<\/li>\n<li>Helm releases<\/li>\n<li>Kubernetes services<\/li>\n<\/ul>\n<p>It is very easy to get the full story of a feature from commit until it reaches production as well as understand what is deployed where.<\/p>\n<figure id=\"attachment_12621\" aria-describedby=\"caption-attachment-12621\" style=\"width: 1909px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/12\/helm-board.png\"><img class=\"size-full wp-image-12621\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/12\/helm-board.png\" alt=\"Enteprise Helm promotion board\" width=\"1909\" height=\"556\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/12\/helm-board.png 1909w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/12\/helm-board-300x87.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/12\/helm-board-768x224.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/12\/helm-board-1024x298.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/12\/helm-board-628x183.png 628w\" sizes=\"(max-width: 1909px) 100vw, 1909px\" \/><\/a><figcaption id=\"caption-attachment-12621\" class=\"wp-caption-text\">Enteprise Helm promotion board<\/figcaption><\/figure>\n<p>The UI offered from Codefresh is targeted at all stakeholders that take part in the software delivery process.<\/p>\n<h2>Jenkins X uses Groovy\/JX pipelines, Codefresh uses declarative YAML<\/h2>\n<p>We already mentioned that Jenkins X is using plain Jenkins under the hood. This means that pipelines in Jenkins X are also created with Groovy and shared libraries. Codefresh, on the other hand, uses <a href=\"https:\/\/codefresh.io\/docs\/docs\/codefresh-yaml\/what-is-the-codefresh-yaml\">declarative YAML<\/a>.<\/p>\n<p>The big problem here is that the jx executable (which is normally used to manage Jenkins X installation) can also be injected into Jenkins pipelines by extending their pipeline steps. This means that pipelines are now even more complicated as one must also learn how the jx executable works and how it affects the pipelines it takes part in.<\/p>\n<p>Here is an official example from the quick start of Jenkins X (this is just a segment of the full pipeline)<\/p>\n<pre>steps {\n       container('maven') {\n \n         \/\/ ensure we're not on a detached head\n         sh \"git checkout master\"\n         sh \"git config --global credential.helper store\"\n         sh \"jx step git credentials\"\n \n         \/\/ so we can retrieve the version in later steps\n         sh \"echo \\$(jx-release-version) &gt; VERSION\"\n         sh \"mvn versions:set -DnewVersion=\\$(cat VERSION)\"\n         sh \"jx step tag --version \\$(cat VERSION)\"\n         sh \"mvn clean deploy\"\n \n         sh \"export VERSION=`cat VERSION` &amp;&amp; skaffold build -f skaffold.yaml\"\n         sh \"jx step post build --image $DOCKER_REGISTRY\/$ORG\/$APP_NAME:\\$(cat VERSION)\"\n       }\n     }\n<\/pre>\n<p>You can see in the example above that jx now takes place in the Jenkins X pipelines requiring developers to learn yet another tool.<\/p>\n<p>The problem here is that for Jenkins X to do its magic your pipelines must behave as they are expected to. Therefore modifying Jenkins X pipelines becomes extra difficult as you must honor the assumptions already present in the pipeline (that match the opinionated design of Jenkins X).<\/p>\n<p>This problem does not exist in Codefresh. You can have a single pipeline that does everything with conditionals or multiple independent pipelines, or linked-pipelines or parallel pipelines, or any other pattern that you wish for your project.<\/p>\n<h2>Jenkins X does not cache dependencies by default, Codefresh has automatic caching<\/h2>\n<p>Jenkins X is scaling by creating additional builders on the Kubernetes cluster where it is installed. When you start a new pipeline, a new builder is created dynamically on the cluster that contains a Jenkins slave which is automatically connected to the Jenkins master. Jenkins X also supports a serverless installation where there is no need for a Jenkins master at all (which normally consumes resources even when no builds are running).<\/p>\n<p>While this approach is great for scalability it is also ineffective when it comes to build caching. Each build node starts in a fresh state without any knowledge of previous builds. This means that all module dependencies needed by your programming language are downloaded again and again all the time.<\/p>\n<p>A particularly bad example of this is the quick start demo offered by Jenkins. It is a Java application that downloads its Maven dependencies:<\/p>\n<ol>\n<li>Whenever a branch is built<\/li>\n<li>When a pull request is created<\/li>\n<li>When a pull request is merged back to master<\/li>\n<\/ol>\n<p>Basically <strong>any <\/strong>Jenkins X build will download all dependencies each time it runs.<\/p>\n<p>The builders in all 3 cases are completely isolated. For big projects (think also node modules, pip packages, ruby gems etc) where the dependencies actually dominate the compile time, this problem can quickly get out of hand with very slow Jenkins X builds.<\/p>\n<p>Codefresh solves this problem by attaching a Docker volume in all steps on the pipeline. This volume is cached between subsequent builds so that dependencies are only downloaded once.<\/p>\n<figure id=\"attachment_12622\" aria-describedby=\"caption-attachment-12622\" style=\"width: 800px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/12\/codefresh-volume.png\"><img class=\"size-full wp-image-12622\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/12\/codefresh-volume.png\" alt=\"Codefresh caches the shared volume \" width=\"800\" height=\"440\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/12\/codefresh-volume.png 800w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/12\/codefresh-volume-300x165.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/12\/codefresh-volume-768x422.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/12\/codefresh-volume-596x328.png 596w\" sizes=\"(max-width: 800px) 100vw, 800px\" \/><\/a><figcaption id=\"caption-attachment-12622\" class=\"wp-caption-text\">Codefresh caches the shared volume<\/figcaption><\/figure>\n<p>In summary, Codefresh has much better caching than JenkinsX resulting in very fast builds and quick feedback times from commit to result.<\/p>\n<h2>Jenkins X advantages<\/h2>\n<p>In the previous sections we have seen some shortcomings of Jenkins X when compared directly to Codefresh. However, some of these issues actually have to do with the mindset behind Jenkins X and the goals it tries to achieve.<\/p>\n<p>First of all, Jenkins X tries to help you with creating a CI\/CD pipeline as fast as possible by automating several tasks that are typical prerequisites. For example, you can quickly create a Kubernetes cluster on any popular cloud provider with the <code>jx create cluster<\/code> command. Codefresh just assumes that your Kubernetes cluster is already there (and possibly created by another member of your team such as an SRE).<\/p>\n<p>Creating a project from scratch in Jenkins X is also a very simple process as <a href=\"https:\/\/github.com\/jenkins-x-buildpacks\/jenkins-x-kubernetes\/tree\/master\/packs\">several buildpacks<\/a> are offered for all popular programming languages. With the same <code>jx<\/code> executable you can easily create a project skeleton for Rust, Ruby, Scala, Gradle etc. You also get an automatically generated Dockerfile for your project. Jenkins X will even commit your project to GIT for you if it is not already in source control. Codefresh again assumes, that you already have an existing source code project and the only thing missing is the CI\/CD pipeline.<\/p>\n<p>This makes the usage of Jenkins X very easy for beginners, as with several built-in commands they can start from nothing to a full blown CI\/CD pipeline. This is especially helpful for startup teams that start on green field projects where there are no existing best practices and processes.<\/p>\n<p>Jenkins X also attempts to solve more aspects of software development (and not just the CI\/CD part), such as the experience for local programming. A Jenkins X installation automatically offers live sync of dev code while being developed (devpods). This helps developers to test their application code even before they merge their feature in the mainline, by seeing how their code runs on the same environment as it will be deployed. Codefresh has no such capability and assumes that you are using an external solution such as <a href=\"https:\/\/garden.io\/\">garden<\/a>, <a href=\"https:\/\/skaffold.dev\/\">skaffold<\/a>, <a href=\"https:\/\/www.telepresence.io\/\">telepresence<\/a>, <a href=\"https:\/\/okteto.com\/\">Okteto <\/a>etc. (Jenkins X is in fact using Skaffold behind the scenes).<\/p>\n<p>Jenkins X makes also very easy the promotion of releases among different environments if you indeed follow trunk based development. Jenkins X automatically creates a GIT repository for each environment with an umbrella Helm chart and all promotions are happening via pull requests. You can get the same thing in Codefresh, but it is up to you to set-it-up, while with Jenkins X you get it out of the box. So for companies that need this specific functionality, they can start using pull-based promotions right away with Jenkins X.<\/p>\n<p>Finally, Jenkins X has IDE integrations with Visual Studio Code and Intellij allowing developers to monitor builds from their favorite development environment. Codefresh offers no such functionality.<\/p>\n<h2>Conclusion<\/h2>\n<p>In this article, we have seen some discussion points on how Jenkins X and Codefresh work with CI\/CD pipelines.<\/p>\n<p>Jenkins X is a beginner friendly solution that tries to help as much as possible with the initial project setup. With just a few commands you can get a cluster created with Jenkins X, several deployment environments (backed by git repositories) and a source code skeleton for your development project. This model would work great in a startup company that works on a brand new project where no conventions exist yet.<\/p>\n<p>This quick initial setup however comes at the expense of several design decisions that focus on a opinionated workflow. If you agree with the decisions Jenkins X made already for you then there is great value for green field projects. Jenkins X assumes that you work with trunk based development, promote your releases with pull requests on git-based environments and most importantly use <strong>only<\/strong> Helm for all deployments (not even plain Kubernetes manifests). Any other project configuration is simply <strong>NOT<\/strong> supported.<\/p>\n<p>Finally, at its present state, Jenkins X has only a command line interface, making the visualization of its environment and application a very difficult process.<\/p>\n<p>Codefresh on the other hand does not impose any limitation on your workflow or the deployment targets. You can use Codefresh to deploy to VMs, Nomad clusters, Tomcat servers, FTP sites, S3 buckets and any other target that you want. This is particularly important for big companies with existing projects, as expecting every system to be switched right away to Kubernetes\/Helm is an unrealistic proposition (companies still have VM based projects or even bare metal).<\/p>\n<p>In the development part, again Codefresh is very flexible. You can use trunk based development or any other workflow that your company already uses. Single pipelines, manual approvals, continuous deployment are all supported. You can promote releases to other environments with just an API, a CLI or pull requests or any other method that your team agrees on.<\/p>\n<p>Finally, Codefresh offers a graphical view for all major assets such as builds, pipelines, docker images, Helm charts, environments etc. making the CI\/CD process accessible by everyone inside a company and not just developers.<\/p>\n<p>In summary if you start working on a brand new cloud application and are just finding your way around Kubernetes, Helm, Docker registries and cloud deployment environments, Jenkins X can greatly help you with the initial setup (especially with small teams composed only from developers). But if you work at an existing company with multiple established projects (cloud and non-cloud, Dockerized or traditional VMs) Codefresh is a much more flexible solution that can adapt to any team workflow and project process. Codefresh is especially powerful in companies where different people manage the infrastructure than those that do application development or companies with legacy\/existing projects that are still using VMs or other non-Helm environments.<\/p>\n<p>Codefresh is also a proven solution, used in production deployments for many more years than Jenkins X, which is a new and immature solution. If you are part of a small team that want to manually manage builder nodes, Jenkins X might look tempting if you have nothing to lose when downtime occurs. The SAAS version of Codefresh is fully managed and is used already from companies of all sizes.<\/p>\n<p>In the following table, we summarize the characteristics of Jenkins X vs Codefresh:<\/p>\n<div class=\"table-responsive\"><table class=\"table table-responsive-sm\">\n<thead>\n<tr>\n<th>Feature<\/th>\n<th>Jenkins X<\/th>\n<th>Codefresh<\/th>\n<\/tr>\n<\/thead>\n<tbody>\n<tr>\n<td>Git repository dashboard<\/td>\n<td>No<\/td>\n<td>Yes<\/td>\n<\/tr>\n<tr>\n<td>Git support<\/td>\n<td>Yes<\/td>\n<td>Yes<\/td>\n<\/tr>\n<tr>\n<td>Quay\/ACR\/JFrog\/Dockerhub triggers<\/td>\n<td>No<\/td>\n<td>Yes<\/td>\n<\/tr>\n<tr>\n<td>GIT flow<\/td>\n<td>Trunk-based<\/td>\n<td>Any<\/td>\n<\/tr>\n<tr>\n<td>Versioning<\/td>\n<td>Git tags \/semantic<\/td>\n<td>Any<\/td>\n<\/tr>\n<tr>\n<td>Pipeline Management<\/td>\n<td>CLI<\/td>\n<td>Graphical and CLI<\/td>\n<\/tr>\n<tr>\n<td>Built-in dynamic test environments<\/td>\n<td>Yes<\/td>\n<td>Yes<\/td>\n<\/tr>\n<tr>\n<td>Docker-based builds<\/td>\n<td>Yes<\/td>\n<td>Yes<\/td>\n<\/tr>\n<tr>\n<td>Native build caching<\/td>\n<td>No<\/td>\n<td>Yes<\/td>\n<\/tr>\n<tr>\n<td>Pipelines as code<\/td>\n<td>Groovy<\/td>\n<td>Yaml<\/td>\n<\/tr>\n<tr>\n<td>Native Monorepo support<\/td>\n<td>No<\/td>\n<td>Yes<\/td>\n<\/tr>\n<tr>\n<td>Extension mechanism<\/td>\n<td>Groovy shared libraries<\/td>\n<td>Docker images<\/td>\n<\/tr>\n<tr>\n<td>Installation<\/td>\n<td>Cloud\/On-prem<\/td>\n<td>Cloud\/On-prem\/Hybrid<\/td>\n<\/tr>\n<tr>\n<td>Internal Docker registry<\/td>\n<td>Yes<\/td>\n<td>Yes<\/td>\n<\/tr>\n<tr>\n<td>Docker Registry dashboard<\/td>\n<td>No<\/td>\n<td>Yes<\/td>\n<\/tr>\n<tr>\n<td>Custom Docker image metadata<\/td>\n<td>No<\/td>\n<td>Yes<\/td>\n<\/tr>\n<tr>\n<td>Native Kubernetes deployment<\/td>\n<td>Yes<\/td>\n<td>Yes<\/td>\n<\/tr>\n<tr>\n<td>Kubernetes Release Dashboard<\/td>\n<td>No<\/td>\n<td>Yes<\/td>\n<\/tr>\n<tr>\n<td>Deployment mode<\/td>\n<td>Helm only<\/td>\n<td>Helm or plain K8s<\/td>\n<\/tr>\n<tr>\n<td>Integrated Helm repository<\/td>\n<td>Yes<\/td>\n<td>Yes<\/td>\n<\/tr>\n<tr>\n<td>Helm app dashboard<\/td>\n<td>Yes<\/td>\n<td>Yes<\/td>\n<\/tr>\n<tr>\n<td>Helm release dashboard<\/td>\n<td>No<\/td>\n<td>Yes<\/td>\n<\/tr>\n<tr>\n<td>Helm releases history and management (UI)<\/td>\n<td>No<\/td>\n<td>Yes<\/td>\n<\/tr>\n<tr>\n<td>Helm Rollback to any previous version (UI)<\/td>\n<td>No<\/td>\n<td>Yes<\/td>\n<\/tr>\n<tr>\n<td>Deploy to Bare Metal\/VM<\/td>\n<td>No<\/td>\n<td>Yes<\/td>\n<\/tr>\n<tr>\n<td>Deployment management<\/td>\n<td>CLI<\/td>\n<td>GUI and CLI<\/td>\n<\/tr>\n<tr>\n<td>Quick project skeleton creation<\/td>\n<td>Yes<\/td>\n<td>No<\/td>\n<\/tr>\n<tr>\n<td>Quick Git repo creation<\/td>\n<td>Yes<\/td>\n<td>No<\/td>\n<\/tr>\n<tr>\n<td>Syncing code to Pod<\/td>\n<td>Yes<\/td>\n<td>No<\/td>\n<\/tr>\n<tr>\n<td>Built-in Pull-request promotion<\/td>\n<td>Yes<\/td>\n<td>No<\/td>\n<\/tr>\n<tr>\n<td>Quick environmenet creation<\/td>\n<td>Yes<\/td>\n<td>No<\/td>\n<\/tr>\n<tr>\n<td>Quick cluster creation<\/td>\n<td>Yes<\/td>\n<td>No<\/td>\n<\/tr>\n<tr>\n<td>IDE integrations<\/td>\n<td>Yes<\/td>\n<td>No<\/td>\n<\/tr>\n<\/tbody>\n<\/table><\/div>\n<p>New to Codefresh? <a href=\"https:\/\/codefresh.io\/codefresh-signup\/?utm_source=Blog&amp;utm_medium=Post&amp;utm_campaign=versusJenkinsX\">Create Your Free Account Today!<\/a><\/p>\n<input class=\"fooboxshare_post_id\" type=\"hidden\" value=\"12611\"\/>","protected":false},"excerpt":{"rendered":"<p>In a previous blog post, we saw how Codefresh compared to Jenkins. In that post, the major takeaway is the fact that Codefresh is a solution for both builds and deployments (CI\/CD) while Jenkins does not support any deployments on its own (only CI). Jenkins X has recently been announced and it is has been &hellip; <a href=\"https:\/\/codefresh.io\/continuous-deployment\/codefresh-versus-jenkins-x\/\">Read more<\/a><\/p>\n","protected":false},"author":62,"featured_media":12614,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[3120,1657,1505,1543,1538],"tags":[],"yoast_head":"<!-- This site is optimized with the Yoast SEO Premium plugin v17.9 (Yoast SEO v18.4.1) - https:\/\/yoast.com\/wordpress\/plugins\/seo\/ -->\n<title>Codefresh versus Jenkins X | Codefresh<\/title>\n<meta name=\"robots\" content=\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\" \/>\n<link rel=\"canonical\" href=\"https:\/\/codefresh.io\/continuous-deployment\/codefresh-versus-jenkins-x\/\" \/>\n<meta property=\"og:locale\" content=\"en_US\" \/>\n<meta property=\"og:type\" content=\"article\" \/>\n<meta property=\"og:title\" content=\"Codefresh versus Jenkins X\" \/>\n<meta property=\"og:description\" content=\"In a previous blog post, we saw how Codefresh compared to Jenkins. In that post, the major takeaway is the fact that Codefresh is a solution for both builds and deployments (CI\/CD) while Jenkins does not support any deployments on its own (only CI). Jenkins X has recently been announced and it is has been &hellip; Read more\" \/>\n<meta property=\"og:url\" content=\"https:\/\/codefresh.io\/continuous-deployment\/codefresh-versus-jenkins-x\/\" \/>\n<meta property=\"og:site_name\" content=\"Codefresh\" \/>\n<meta property=\"article:publisher\" content=\"https:\/\/www.facebook.com\/codefresh.io\" \/>\n<meta property=\"article:published_time\" content=\"2018-12-27T21:36:34+00:00\" \/>\n<meta property=\"article:modified_time\" content=\"2022-02-09T14:32:43+00:00\" \/>\n<meta property=\"og:image\" content=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/12\/codefresh_vs__Jenkins_x.jpg\" \/>\n\t<meta property=\"og:image:width\" content=\"670\" \/>\n\t<meta property=\"og:image:height\" content=\"200\" \/>\n\t<meta property=\"og:image:type\" content=\"image\/jpeg\" \/>\n<meta name=\"twitter:card\" content=\"summary_large_image\" \/>\n<meta name=\"twitter:creator\" content=\"@codefresh\" \/>\n<meta name=\"twitter:site\" content=\"@codefresh\" \/>\n<meta name=\"twitter:label1\" content=\"Written by\" \/>\n\t<meta name=\"twitter:data1\" content=\"Kostis Kapelonis\" \/>\n\t<meta name=\"twitter:label2\" content=\"Est. reading time\" \/>\n\t<meta name=\"twitter:data2\" content=\"16 minutes\" \/>\n<script type=\"application\/ld+json\" class=\"yoast-schema-graph\">{\"@context\":\"https:\/\/schema.org\",\"@graph\":[{\"@type\":\"Organization\",\"@id\":\"https:\/\/codefresh.io\/#organization\",\"name\":\"Codefresh\",\"url\":\"https:\/\/codefresh.io\/\",\"sameAs\":[\"https:\/\/www.facebook.com\/codefresh.io\",\"https:\/\/www.linkedin.com\/company\/codefresh\",\"https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg\",\"https:\/\/twitter.com\/codefresh\"],\"logo\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#logo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"width\":800,\"height\":800,\"caption\":\"Codefresh\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/#logo\"}},{\"@type\":\"WebSite\",\"@id\":\"https:\/\/codefresh.io\/#website\",\"url\":\"https:\/\/codefresh.io\/\",\"name\":\"Codefresh\",\"description\":\"\",\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"potentialAction\":[{\"@type\":\"SearchAction\",\"target\":{\"@type\":\"EntryPoint\",\"urlTemplate\":\"https:\/\/codefresh.io\/?s={search_term_string}\"},\"query-input\":\"required name=search_term_string\"}],\"inLanguage\":\"en-US\"},{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/continuous-deployment\/codefresh-versus-jenkins-x\/#primaryimage\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/12\/codefresh_vs__Jenkins_x.jpg\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/12\/codefresh_vs__Jenkins_x.jpg\",\"width\":670,\"height\":200},{\"@type\":\"WebPage\",\"@id\":\"https:\/\/codefresh.io\/continuous-deployment\/codefresh-versus-jenkins-x\/#webpage\",\"url\":\"https:\/\/codefresh.io\/continuous-deployment\/codefresh-versus-jenkins-x\/\",\"name\":\"Codefresh versus Jenkins X | Codefresh\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/#website\"},\"primaryImageOfPage\":{\"@id\":\"https:\/\/codefresh.io\/continuous-deployment\/codefresh-versus-jenkins-x\/#primaryimage\"},\"datePublished\":\"2018-12-27T21:36:34+00:00\",\"dateModified\":\"2022-02-09T14:32:43+00:00\",\"breadcrumb\":{\"@id\":\"https:\/\/codefresh.io\/continuous-deployment\/codefresh-versus-jenkins-x\/#breadcrumb\"},\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"ReadAction\",\"target\":[\"https:\/\/codefresh.io\/continuous-deployment\/codefresh-versus-jenkins-x\/\"]}]},{\"@type\":\"BreadcrumbList\",\"@id\":\"https:\/\/codefresh.io\/continuous-deployment\/codefresh-versus-jenkins-x\/#breadcrumb\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"name\":\"Home\",\"item\":\"https:\/\/codefresh.io\/\"},{\"@type\":\"ListItem\",\"position\":2,\"name\":\"Codefresh versus Jenkins X\"}]},{\"@type\":\"Article\",\"@id\":\"https:\/\/codefresh.io\/continuous-deployment\/codefresh-versus-jenkins-x\/#article\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/continuous-deployment\/codefresh-versus-jenkins-x\/#webpage\"},\"author\":{\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87\"},\"headline\":\"Codefresh versus Jenkins X\",\"datePublished\":\"2018-12-27T21:36:34+00:00\",\"dateModified\":\"2022-02-09T14:32:43+00:00\",\"mainEntityOfPage\":{\"@id\":\"https:\/\/codefresh.io\/continuous-deployment\/codefresh-versus-jenkins-x\/#webpage\"},\"wordCount\":3195,\"commentCount\":0,\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/continuous-deployment\/codefresh-versus-jenkins-x\/#primaryimage\"},\"thumbnailUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/12\/codefresh_vs__Jenkins_x.jpg\",\"articleSection\":[\"Continuous Deployment\/Delivery\",\"Kubernetes Tutorials\",\"Containers\",\"Continuous Integration\",\"DevOps Tutorials\"],\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"CommentAction\",\"name\":\"Comment\",\"target\":[\"https:\/\/codefresh.io\/continuous-deployment\/codefresh-versus-jenkins-x\/#respond\"]}]},{\"@type\":\"Person\",\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87\",\"name\":\"Kostis Kapelonis\",\"image\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#personlogo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png\",\"caption\":\"Kostis Kapelonis\"},\"description\":\"Kostis is a software engineer\/technical-writer dual class character. He lives and breathes automation, good testing practices and stress-free deployments with GitOps.\",\"url\":\"https:\/\/codefresh.io\/author\/kostiscodefresh-io\/\"}]}<\/script>\n<!-- \/ Yoast SEO Premium plugin. -->","yoast_head_json":{"title":"Codefresh versus Jenkins X | Codefresh","robots":{"index":"index","follow":"follow","max-snippet":"max-snippet:-1","max-image-preview":"max-image-preview:large","max-video-preview":"max-video-preview:-1"},"canonical":"https:\/\/codefresh.io\/continuous-deployment\/codefresh-versus-jenkins-x\/","og_locale":"en_US","og_type":"article","og_title":"Codefresh versus Jenkins X","og_description":"In a previous blog post, we saw how Codefresh compared to Jenkins. In that post, the major takeaway is the fact that Codefresh is a solution for both builds and deployments (CI\/CD) while Jenkins does not support any deployments on its own (only CI). Jenkins X has recently been announced and it is has been &hellip; Read more","og_url":"https:\/\/codefresh.io\/continuous-deployment\/codefresh-versus-jenkins-x\/","og_site_name":"Codefresh","article_publisher":"https:\/\/www.facebook.com\/codefresh.io","article_published_time":"2018-12-27T21:36:34+00:00","article_modified_time":"2022-02-09T14:32:43+00:00","og_image":[{"width":670,"height":200,"url":"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/12\/codefresh_vs__Jenkins_x.jpg","type":"image\/jpeg"}],"twitter_card":"summary_large_image","twitter_creator":"@codefresh","twitter_site":"@codefresh","twitter_misc":{"Written by":"Kostis Kapelonis","Est. reading time":"16 minutes"},"schema":{"@context":"https:\/\/schema.org","@graph":[{"@type":"Organization","@id":"https:\/\/codefresh.io\/#organization","name":"Codefresh","url":"https:\/\/codefresh.io\/","sameAs":["https:\/\/www.facebook.com\/codefresh.io","https:\/\/www.linkedin.com\/company\/codefresh","https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg","https:\/\/twitter.com\/codefresh"],"logo":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#logo","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","width":800,"height":800,"caption":"Codefresh"},"image":{"@id":"https:\/\/codefresh.io\/#logo"}},{"@type":"WebSite","@id":"https:\/\/codefresh.io\/#website","url":"https:\/\/codefresh.io\/","name":"Codefresh","description":"","publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"potentialAction":[{"@type":"SearchAction","target":{"@type":"EntryPoint","urlTemplate":"https:\/\/codefresh.io\/?s={search_term_string}"},"query-input":"required name=search_term_string"}],"inLanguage":"en-US"},{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/continuous-deployment\/codefresh-versus-jenkins-x\/#primaryimage","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/12\/codefresh_vs__Jenkins_x.jpg","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/12\/codefresh_vs__Jenkins_x.jpg","width":670,"height":200},{"@type":"WebPage","@id":"https:\/\/codefresh.io\/continuous-deployment\/codefresh-versus-jenkins-x\/#webpage","url":"https:\/\/codefresh.io\/continuous-deployment\/codefresh-versus-jenkins-x\/","name":"Codefresh versus Jenkins X | Codefresh","isPartOf":{"@id":"https:\/\/codefresh.io\/#website"},"primaryImageOfPage":{"@id":"https:\/\/codefresh.io\/continuous-deployment\/codefresh-versus-jenkins-x\/#primaryimage"},"datePublished":"2018-12-27T21:36:34+00:00","dateModified":"2022-02-09T14:32:43+00:00","breadcrumb":{"@id":"https:\/\/codefresh.io\/continuous-deployment\/codefresh-versus-jenkins-x\/#breadcrumb"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https:\/\/codefresh.io\/continuous-deployment\/codefresh-versus-jenkins-x\/"]}]},{"@type":"BreadcrumbList","@id":"https:\/\/codefresh.io\/continuous-deployment\/codefresh-versus-jenkins-x\/#breadcrumb","itemListElement":[{"@type":"ListItem","position":1,"name":"Home","item":"https:\/\/codefresh.io\/"},{"@type":"ListItem","position":2,"name":"Codefresh versus Jenkins X"}]},{"@type":"Article","@id":"https:\/\/codefresh.io\/continuous-deployment\/codefresh-versus-jenkins-x\/#article","isPartOf":{"@id":"https:\/\/codefresh.io\/continuous-deployment\/codefresh-versus-jenkins-x\/#webpage"},"author":{"@id":"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87"},"headline":"Codefresh versus Jenkins X","datePublished":"2018-12-27T21:36:34+00:00","dateModified":"2022-02-09T14:32:43+00:00","mainEntityOfPage":{"@id":"https:\/\/codefresh.io\/continuous-deployment\/codefresh-versus-jenkins-x\/#webpage"},"wordCount":3195,"commentCount":0,"publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"image":{"@id":"https:\/\/codefresh.io\/continuous-deployment\/codefresh-versus-jenkins-x\/#primaryimage"},"thumbnailUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/12\/codefresh_vs__Jenkins_x.jpg","articleSection":["Continuous Deployment\/Delivery","Kubernetes Tutorials","Containers","Continuous Integration","DevOps Tutorials"],"inLanguage":"en-US","potentialAction":[{"@type":"CommentAction","name":"Comment","target":["https:\/\/codefresh.io\/continuous-deployment\/codefresh-versus-jenkins-x\/#respond"]}]},{"@type":"Person","@id":"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87","name":"Kostis Kapelonis","image":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#personlogo","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png","caption":"Kostis Kapelonis"},"description":"Kostis is a software engineer\/technical-writer dual class character. He lives and breathes automation, good testing practices and stress-free deployments with GitOps.","url":"https:\/\/codefresh.io\/author\/kostiscodefresh-io\/"}]}},"acf":[],"_links":{"self":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/12611"}],"collection":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/users\/62"}],"replies":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/comments?post=12611"}],"version-history":[{"count":1,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/12611\/revisions"}],"predecessor-version":[{"id":21357,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/12611\/revisions\/21357"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media\/12614"}],"wp:attachment":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media?parent=12611"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/categories?post=12611"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/tags?post=12611"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}