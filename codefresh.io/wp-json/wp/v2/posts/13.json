{"id":13,"date":"2015-03-19T05:13:06","date_gmt":"2015-03-19T05:13:06","guid":{"rendered":"https:\/\/codefresh.io\/2015\/03\/19\/node-docker-and-microservices\/"},"modified":"2022-01-18T16:42:34","modified_gmt":"2022-01-18T16:42:34","slug":"node-docker-and-microservices","status":"publish","type":"post","link":"https:\/\/codefresh.io\/docker-tutorial\/node-docker-and-microservices\/","title":{"rendered":"Node, Docker, and Microservices"},"content":{"rendered":"<p>In my <a href=\"\/soa-microservices\/\">last blog post<\/a>, I wrote about how the term <em>microservice<\/em> has entered our vocabulary. In this post, I examine the trend toward microservice architecture and discuss how Node.js and Docker technologies converge to facilitate this pattern.<\/p>\n<h3>The Era of Monolithic Architecture<\/h3>\n<p>The classic view of a web application looks like this:<\/p>\n<p>&nbsp;<\/p>\n<p><img class=\"size-medium wp-image-20987 aligncenter\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2015\/03\/monolithic-architecture-300x151.png\" alt=\"monolithic-architecture\" width=\"300\" height=\"151\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2015\/03\/monolithic-architecture-300x151.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2015\/03\/monolithic-architecture-768x386.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2015\/03\/monolithic-architecture-20x10.png 20w, https:\/\/codefresh.io\/wp-content\/uploads\/2015\/03\/monolithic-architecture.png 911w\" sizes=\"(max-width: 300px) 100vw, 300px\" \/><\/p>\n<p>In software engineering, this is known as monolithic architecture, and it has a number of advantages.<\/p>\n<ul>\n<li>It is relatively straightforward to begin developing, testing and debugging code that is bundled into a single executable process. Until the codebase actually begins to reach a mass where it really deserves to be called monolithic, it can be fairly easy to reason about data flows and application behavior.<\/li>\n<li>The deployment model is easy to understand. The application is deployed as a unit, whether a bundle of files or compressed as a single web application resource (for example, a Java WAR file).<\/li>\n<li>\u00a0The model for scaling is simple to understand. Scale up by installing the application on a more powerful server and scale out by placing the application behind some type of load balancer to distribute requests so that no single instance is overwhelmed by high loads.<\/li>\n<\/ul>\n<p>The second point above is actually pretty significant, especially when you consider that creating server environments has historically been time-consuming and expensive. Because of this, there was a practical limit on the number of environments that were available for promoting applications through a pipeline to production. Starting from the developer&#8217;s local workstation, a staged pipeline might include some or all of these:<\/p>\n<ul>\n<li><strong>(local)<\/strong>\u00a0&#8211; developer&#8217;s workstation<\/li>\n<li><strong>dev (or sandbox)<\/strong>\u00a0&#8211; first stage for developers to merge and unit test<\/li>\n<li><strong>int<\/strong>** &#8211; integration stage for developers to test with external databases and other services; often used for CI builds<\/li>\n<li><strong>qa (or test)<\/strong>\u00a0&#8211; for functional and other types of testing<\/li>\n<li><strong>uat<\/strong>** &#8211; customer user acceptance testing and demo<\/li>\n<li><strong>preprod (or staging)<\/strong>\u00a0&#8211; exact replica of production environment for final verification<\/li>\n<li><strong>production<\/strong>\u00a0&#8211; live site<\/li>\n<\/ul>\n<p>The creation and management of the pipeline from developer workstations to production data center servers, and the requisite team coordination needed to promote builds through each stage, historically involved a significant investment in time and effort. The introduction of virtual machine technology (and eventually Vagrant, and Puppet and Chef) helped provide organizations with labor, time and infrastructure cost savings, but the process nevertheless remained burdensome.<\/p>\n<p>If the process to move an application through the pipeline is laborious and time-consuming, it makes sense to coordinate larger releases that are worth the effort. And with larger codebases, then type-safe, class-based object-oriented languages with a heavy emphasis on domain models, design patterns like inversion of control through dependency injection, and all the things that became the hallmarks of well designed applications of the last decade or so, may appear quite compelling, if not downright necessary for mediating the challenges of maintainability and extensibility as the application matures.<\/p>\n<p>The Java and .NET platforms, frameworks and tooling evolved in part to address the burden of developing and deploying a complex codebase and bundle of related artifacts for large, sophisticated applications. And to recapitulate, monolithic architecture made sense in part because the deployment model was not only easy to understand, but given the expense of creating and maintaining various staging environments, it was also more cost effective to manage from a traditional IT operations perspective.<\/p>\n<h4>Ramifications of Monolithic Architecture<\/h4>\n<p>But at some point, the advantages of a monolithic architecture become significant liabilities.<\/p>\n<h5>It inhibits continuous delivery<\/h5>\n<p>Staging large epic releases is undesirable, especially to compete in today&#8217;s social, mobile and app-centric world where consumers and customers expect updates and new features to be released frequently.<\/p>\n<p>However, we already noted that application deployment is laborious and time-consuming \u2014 and of course, the larger and more sophisticated the application, the greater the potential risk of things going wrong.<\/p>\n<p><a href=\"http:\/\/martinfowler.com\/bliki\/ContinuousDelivery.html\">Continuous delivery<\/a> is an attempt to reduce the cost and risk associated with delivering incremental changes in large part by automating as much of the deployment pipeline as possible. Nevertheless, for a large complex application, there is simply too much effort, cost, and risk involved in redeploying an entire application to update a single deployment. While feasible, as a practical matter, monolithic architecture inhibits efficient contiuous delivery.<\/p>\n<h5>Sub-optimal scalability<\/h5>\n<p>We noted that the scaling model for an application is straightforward. But there is a practical limit on scaling up, and scaling out by deploying entire copies of large applications is a relatively expensive and inefficient way to scale.<\/p>\n<p>In particular for larger and more complex applications, not all components are under the same load. It would be more ideal to scale out at the individual component level, but in monolithic architecture, the unit of scaling is the entire application.<\/p>\n<h5>Adverse impact on development<\/h5>\n<p>Working with the code of a large, complex monolithic application is challenging. Larger codebases are more difficult to maintain and extend, and require greater coordination among teams. The application evolves at a cadence dictated by a release cycle scheduled to amortize the cost of testing and deployment balanced by the desire to release new features to market. The effort involved leads to more epic releases, and all the inherent effort and risks that that implies.<\/p>\n<p>The friction involved in having teams coordinate development, testing and integration of individual layers and slices of the application impedes rapid progress and evolution. Each individual team member needs to take care in setting up their local development environment to support building and testing the entire application regardless of which little piece they&#8217;re developing for. As cognitive overhead increases, individual team members become less effective, their contributions take greater effort, and quality is adversely affected.<\/p>\n<p>For a project that will scale in size and complexity, the initial commitment to a specific technology stack (platform, frameworks, tooling) becomes another liability. This is a decision that will generally follow the life of the project over many years, dictated by the application architecture as a whole instead of by the choices available for building individual components over time.<\/p>\n<h3>APIs drive modern apps<\/h3>\n<p>Application integration, mashups, AJAX, the trend toward single-page applications and the explosion in the number of clients capable of accessing the web have all driven the ascendancy of APIs and forever changed the way we view a web application. No longer is it about the physical unit of deployment corresponding to the user&#8217;s experience in a browser \u2014 it&#8217;s about the user&#8217;s experience across a broad range of devices.<\/p>\n<p>The application is the set of services delivering functionality exposed by APIs that power an appropriate experience on a particular client.<\/p>\n<p><img class=\"size-medium wp-image-20988 aligncenter\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2015\/03\/apis-drive-modern-apps-300x129.png\" alt=\"apis-drive-modern-apps\" width=\"300\" height=\"129\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2015\/03\/apis-drive-modern-apps-300x129.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2015\/03\/apis-drive-modern-apps-768x329.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2015\/03\/apis-drive-modern-apps-20x9.png 20w, https:\/\/codefresh.io\/wp-content\/uploads\/2015\/03\/apis-drive-modern-apps.png 937w\" sizes=\"(max-width: 300px) 100vw, 300px\" \/><\/p>\n<h3>Rise of microservices<\/h3>\n<p>With an emphasis on APIs, it becomes more desirable than ever to independently evolve, deploy and scale individual services. By moving away from monolithic architecture, we can reduce codebase complexity through separation of concerns at a physical level. We can focus on a system of processes with loosely coupled partitions at functional boundaries instead of a single process with layered boundaries imposed by classic three-tier web application architecture.<\/p>\n<p>Freeing development teams from the constraint of integrating and delivering their functionality as part of a larger complex bundle relieves an enormous amount of friction. By targeting lightweight, fine-grained services, smaller teams can move at their own cadence, test more effectively, and deploy more rapidly. Once deployed, these services can potentially scale independently and more cost effectively.<\/p>\n<p>Of course, these benefits sound great in theory, but as the previous post made clear, there is a reason why we were building monolithic applications in the first place. Achieving these benefits depends on a few other factors.<\/p>\n<h4>Enter Docker<\/h4>\n<p>As noted previously, deployments environments have traditionally been laborious to create and maintain. Virtual machine technology and solutions like Vagrant, Puppet and Chef, have helped mitigate the burden and expense, but the pursuit of microservice architecture creates an even greater demand for compute resources.<\/p>\n<p>In 2013, a company known for its multi-language Platform as a Service (PaaS), dotCloud, released the open source <a href=\"https:\/\/www.docker.com\/\">Docker<\/a> project around the container technology it had been developing.<\/p>\n<p>While based on a legacy that goes back to <a href=\"http:\/\/en.wikipedia.org\/wiki\/Chroot\">chroot<\/a>, <a href=\"http:\/\/en.wikipedia.org\/wiki\/FreeBSD_jail\">FreeBSD jails<\/a>, <a href=\"http:\/\/en.wikipedia.org\/wiki\/Solaris_Containers\">Solaris zones<\/a>, <a href=\"http:\/\/en.wikipedia.org\/wiki\/Cgroups\">cgroups<\/a> and <a href=\"http:\/\/en.wikipedia.org\/wiki\/LXC\">Linux containers<\/a>, Docker helped catalyze mainstream attention.<\/p>\n<p>Docker provides the ability to run processes in isolated operating environments. Unlike virtual machines, however, Docker containers use a shared operating system kernel. By not virtualizing the hardware, containers are far more efficient in terms of system resources, and they launch essentially as quickly as a process can be started.<\/p>\n<p>Docker makes the idea of micro operating environments for microservices practical. It makes it feasible to have development environments and all the other environments in the deployment pipeline mimic the production environment.<\/p>\n<h5>Enter Node<\/h5>\n<p>Docker is a major contributor to making a microservice architecture cost effective and practical. It is a tremendous advantage to have technology that so dramatically simplifies the aspect of launching and hosting a process and its dependencies in an isolated compute environment defined by something as simple as a Dockerfile.<\/p>\n<p>But there is another factor to the equation. While docker provides an efficient operating environment for a process, it doesn&#8217;t have anything to do with how that process was developed.<\/p>\n<p>The introduction of <a href=\"https:\/\/nodejs.org\/\">Node.js<\/a> in 2009 presented developers with an exciting opportunity to leverage a lean and mean platform that leveraged JavaScript and Google&#8217;s high performance V8 engine for building lightweight, fast, and highly scalable network services.<\/p>\n<p>The platform and core framework were designed around an event-driven, non-blocking I\/O model and constructing a trivial server is as simple as the following script:<\/p>\n<pre><code>var http = require('http');\nhttp.createServer(function (req, res) {\n  res.writeHead(200, {'Content-Type': 'application\/json'});\n  res.end('{ \"message\": \"Hello World\" }');\n}).listen(3000, '127.0.0.1');\n\nconsole.log('Server listening at http:\/\/127.0.0.1:1337\/');<\/code><\/pre>\n<p>The server can be launched by executing the script via Node:<\/p>\n<pre><code>$ node server.js\nServer listening at http:\/\/127.0.0.1:3000\/<\/code><\/pre>\n<p>Contributing to Node&#8217;s phenomenal growth was an excellent package management system built on lessons learned from other communities. Creating, publishing, and installing a Node module or collection of related modules as a package is simple and fast.<\/p>\n<p>Packages contain their own local copy of installed modules, easing deployment since there is no requirement to install to any common file system locations (and resolve potential version conflicts).<\/p>\n<p>All that is required for a package is a <code>package.json<\/code> file that contains a bit of metadata about a package and its dependencies. A minimal package.json file only requires a name and version.<\/p>\n<p>Because creating and publishing is so trivial, and installing is so simple and effective, npm encourages the development of lightweight, narrowly focused libraries. The growth of the public npm registry has been nothing short of phenomenal.<\/p>\n<p>As March 2015, there are over 130,000 packages at the public npm registry, and over one billion downloads during the past month.<\/p>\n<p><img class=\"aligncenter size-medium wp-image-20989\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2015\/03\/npm-300x224.png\" alt=\"npm\" width=\"300\" height=\"224\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2015\/03\/npm-300x224.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2015\/03\/npm-1024x766.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2015\/03\/npm-768x574.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2015\/03\/npm-20x15.png 20w, https:\/\/codefresh.io\/wp-content\/uploads\/2015\/03\/npm.png 1139w\" sizes=\"(max-width: 300px) 100vw, 300px\" \/><\/p>\n<p><em><a href=\"https:\/\/www.npmjs.com\/\">https:\/\/www.npmjs.com\/<\/a><\/em><\/p>\n<p>In terms of this growth, npm has eclipsed all other package managers, including the venerable CPAN.<\/p>\n<p><img class=\"aligncenter size-medium wp-image-20990\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2015\/03\/modulecounts-300x171.png\" alt=\"module counts\" width=\"300\" height=\"171\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2015\/03\/modulecounts-300x171.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2015\/03\/modulecounts-768x437.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2015\/03\/modulecounts-20x11.png 20w, https:\/\/codefresh.io\/wp-content\/uploads\/2015\/03\/modulecounts.png 942w\" sizes=\"(max-width: 300px) 100vw, 300px\" \/><\/p>\n<p><em>Module Counts Comparison, January 2015<\/em><\/p>\n<p>While no particular technology stack is perfect, the following benefits of Node can&#8217;t be understated with respect to microservice architecture:<\/p>\n<ul>\n<li><strong>Lightweight HTTP server processes<\/strong> \u2014 the Node platform is based on Google&#8217;s well-regarded open source, high performance V8 engine, which compiles JavaScript to native machine code on supported systems; this machine code undergoes dynamic optimization during runtime. The V8 engine is highly tuned for fast startup time, small initial memory footprint, and strong peak performance.<\/li>\n<li><strong>Highly scalable<\/strong> \u2014 the Node platform was designed from the onset for end-to-end asynchronous I\/O for high scalability. There are no extraordinary operating environment requirements to support high scalability, so cost and complexity are not not special concerns in planning deployments of large numbers of services.<\/li>\n<li><strong>Lightweight for developers<\/strong> \u2014 there is minimal ceremony involved in creating and consuming packages, which encourages a high degree of modularization and lightweight, narrowly-focused packages independently versioned and published.<\/li>\n<\/ul>\n<h3>Wrapping it up<\/h3>\n<p>The convergence of Node.js and Docker container technology is phenomenally well suited for microservice architecture.<\/p>\n<p>The benefits include a higher degree of productivity because developers focus their energy on building smaller, narrowly-defined services partitioned along functional boundaries. There is less friction and cognitive overhead with this approach, and services can evolve, be deployed, and scale independently of others.<\/p>\n<p>Node provides a high performance platform that supports high scalability with lightweight server processes. Its simple package management system makes creating, publishing, and consuming packages easy, facilitating and streamlining the process of building and deploying lightweight services.<\/p>\n<p>Docker makes running server processes in isolated compute environments (containers) cheap and easy. These containers are extremely efficient in terms of system resources and provide excellent peformance characteristics, including fast starts.<\/p>\n<p>In future posts, we&#8217;ll provide recipes for building and orchestrating microservices. We&#8217;ll also discuss some of the challenges that come with distributed systems as well as strategies for handling them.<\/p>\n<p>These are the slides for my presentation at NodeSummit 2015:<\/p>\n<p><iframe width=\"480\" height=\"320\" src=\"https:\/\/docs.google.com\/presentation\/d\/1PTgnOOGdXDu2bFWQO5ir_1QQPgf85yDJN0hOP0nOEzc\/embed?start=false&amp;loop=false&amp;delayms=3000\" frameborder=\"0\" allowfullscreen=\"allowfullscreen\"><\/iframe><\/p>\n<input class=\"fooboxshare_post_id\" type=\"hidden\" value=\"13\"\/>","protected":false},"excerpt":{"rendered":"<p>In my last blog post, I wrote about how the term microservice has entered our vocabulary. In this post, I examine the trend toward microservice architecture and discuss how Node.js and Docker technologies converge to facilitate this pattern. The Era of Monolithic Architecture The classic view of a web application looks like this: &nbsp; In &hellip; <a href=\"https:\/\/codefresh.io\/docker-tutorial\/node-docker-and-microservices\/\">Read more<\/a><\/p>\n","protected":false},"author":5,"featured_media":94,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[8],"tags":[],"yoast_head":"<!-- This site is optimized with the Yoast SEO Premium plugin v17.9 (Yoast SEO v18.4.1) - https:\/\/yoast.com\/wordpress\/plugins\/seo\/ -->\n<title>Node, Docker, and Microservices | Codefresh<\/title>\n<meta name=\"robots\" content=\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\" \/>\n<link rel=\"canonical\" href=\"https:\/\/codefresh.io\/docker-tutorial\/node-docker-and-microservices\/\" \/>\n<meta property=\"og:locale\" content=\"en_US\" \/>\n<meta property=\"og:type\" content=\"article\" \/>\n<meta property=\"og:title\" content=\"Node, Docker, and Microservices\" \/>\n<meta property=\"og:description\" content=\"In my last blog post, I wrote about how the term microservice has entered our vocabulary. In this post, I examine the trend toward microservice architecture and discuss how Node.js and Docker technologies converge to facilitate this pattern. The Era of Monolithic Architecture The classic view of a web application looks like this: &nbsp; In &hellip; Read more\" \/>\n<meta property=\"og:url\" content=\"https:\/\/codefresh.io\/docker-tutorial\/node-docker-and-microservices\/\" \/>\n<meta property=\"og:site_name\" content=\"Codefresh\" \/>\n<meta property=\"article:publisher\" content=\"https:\/\/www.facebook.com\/codefresh.io\" \/>\n<meta property=\"article:published_time\" content=\"2015-03-19T05:13:06+00:00\" \/>\n<meta property=\"article:modified_time\" content=\"2022-01-18T16:42:34+00:00\" \/>\n<meta property=\"og:image\" content=\"https:\/\/codefresh.io\/wp-content\/uploads\/2015\/03\/docker-1.png\" \/>\n\t<meta property=\"og:image:width\" content=\"1600\" \/>\n\t<meta property=\"og:image:height\" content=\"500\" \/>\n\t<meta property=\"og:image:type\" content=\"image\/png\" \/>\n<meta name=\"twitter:card\" content=\"summary_large_image\" \/>\n<meta name=\"twitter:creator\" content=\"@razieltabib\" \/>\n<meta name=\"twitter:site\" content=\"@codefresh\" \/>\n<meta name=\"twitter:label1\" content=\"Written by\" \/>\n\t<meta name=\"twitter:data1\" content=\"Raziel Tabib\" \/>\n\t<meta name=\"twitter:label2\" content=\"Est. reading time\" \/>\n\t<meta name=\"twitter:data2\" content=\"11 minutes\" \/>\n<script type=\"application\/ld+json\" class=\"yoast-schema-graph\">{\"@context\":\"https:\/\/schema.org\",\"@graph\":[{\"@type\":\"Organization\",\"@id\":\"https:\/\/codefresh.io\/#organization\",\"name\":\"Codefresh\",\"url\":\"https:\/\/codefresh.io\/\",\"sameAs\":[\"https:\/\/www.facebook.com\/codefresh.io\",\"https:\/\/www.linkedin.com\/company\/codefresh\",\"https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg\",\"https:\/\/twitter.com\/codefresh\"],\"logo\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#logo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"width\":800,\"height\":800,\"caption\":\"Codefresh\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/#logo\"}},{\"@type\":\"WebSite\",\"@id\":\"https:\/\/codefresh.io\/#website\",\"url\":\"https:\/\/codefresh.io\/\",\"name\":\"Codefresh\",\"description\":\"\",\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"potentialAction\":[{\"@type\":\"SearchAction\",\"target\":{\"@type\":\"EntryPoint\",\"urlTemplate\":\"https:\/\/codefresh.io\/?s={search_term_string}\"},\"query-input\":\"required name=search_term_string\"}],\"inLanguage\":\"en-US\"},{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/node-docker-and-microservices\/#primaryimage\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2015\/03\/docker-1.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2015\/03\/docker-1.png\",\"width\":1600,\"height\":500},{\"@type\":\"WebPage\",\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/node-docker-and-microservices\/#webpage\",\"url\":\"https:\/\/codefresh.io\/docker-tutorial\/node-docker-and-microservices\/\",\"name\":\"Node, Docker, and Microservices | Codefresh\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/#website\"},\"primaryImageOfPage\":{\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/node-docker-and-microservices\/#primaryimage\"},\"datePublished\":\"2015-03-19T05:13:06+00:00\",\"dateModified\":\"2022-01-18T16:42:34+00:00\",\"breadcrumb\":{\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/node-docker-and-microservices\/#breadcrumb\"},\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"ReadAction\",\"target\":[\"https:\/\/codefresh.io\/docker-tutorial\/node-docker-and-microservices\/\"]}]},{\"@type\":\"BreadcrumbList\",\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/node-docker-and-microservices\/#breadcrumb\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"name\":\"Home\",\"item\":\"https:\/\/codefresh.io\/\"},{\"@type\":\"ListItem\",\"position\":2,\"name\":\"Node, Docker, and Microservices\"}]},{\"@type\":\"Article\",\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/node-docker-and-microservices\/#article\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/node-docker-and-microservices\/#webpage\"},\"author\":{\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/7f1e186af5b21641f0f3fe5e8e4281c1\"},\"headline\":\"Node, Docker, and Microservices\",\"datePublished\":\"2015-03-19T05:13:06+00:00\",\"dateModified\":\"2022-01-18T16:42:34+00:00\",\"mainEntityOfPage\":{\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/node-docker-and-microservices\/#webpage\"},\"wordCount\":2096,\"commentCount\":1,\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/node-docker-and-microservices\/#primaryimage\"},\"thumbnailUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2015\/03\/docker-1.png\",\"articleSection\":[\"Docker Tutorials\"],\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"CommentAction\",\"name\":\"Comment\",\"target\":[\"https:\/\/codefresh.io\/docker-tutorial\/node-docker-and-microservices\/#respond\"]}]},{\"@type\":\"Person\",\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/7f1e186af5b21641f0f3fe5e8e4281c1\",\"name\":\"Raziel Tabib\",\"image\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#personlogo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/secure.gravatar.com\/avatar\/dace30247c8ac4ddb9e90b0d20d382f1?s=96&d=blank&r=g\",\"contentUrl\":\"https:\/\/secure.gravatar.com\/avatar\/dace30247c8ac4ddb9e90b0d20d382f1?s=96&d=blank&r=g\",\"caption\":\"Raziel Tabib\"},\"description\":\"Co-Founder and CEO, Codefresh\",\"sameAs\":[\"https:\/\/twitter.com\/razieltabib\"],\"url\":\"https:\/\/codefresh.io\/author\/raziel-tabib\/\"}]}<\/script>\n<!-- \/ Yoast SEO Premium plugin. -->","yoast_head_json":{"title":"Node, Docker, and Microservices | Codefresh","robots":{"index":"index","follow":"follow","max-snippet":"max-snippet:-1","max-image-preview":"max-image-preview:large","max-video-preview":"max-video-preview:-1"},"canonical":"https:\/\/codefresh.io\/docker-tutorial\/node-docker-and-microservices\/","og_locale":"en_US","og_type":"article","og_title":"Node, Docker, and Microservices","og_description":"In my last blog post, I wrote about how the term microservice has entered our vocabulary. In this post, I examine the trend toward microservice architecture and discuss how Node.js and Docker technologies converge to facilitate this pattern. The Era of Monolithic Architecture The classic view of a web application looks like this: &nbsp; In &hellip; Read more","og_url":"https:\/\/codefresh.io\/docker-tutorial\/node-docker-and-microservices\/","og_site_name":"Codefresh","article_publisher":"https:\/\/www.facebook.com\/codefresh.io","article_published_time":"2015-03-19T05:13:06+00:00","article_modified_time":"2022-01-18T16:42:34+00:00","og_image":[{"width":1600,"height":500,"url":"https:\/\/codefresh.io\/wp-content\/uploads\/2015\/03\/docker-1.png","type":"image\/png"}],"twitter_card":"summary_large_image","twitter_creator":"@razieltabib","twitter_site":"@codefresh","twitter_misc":{"Written by":"Raziel Tabib","Est. reading time":"11 minutes"},"schema":{"@context":"https:\/\/schema.org","@graph":[{"@type":"Organization","@id":"https:\/\/codefresh.io\/#organization","name":"Codefresh","url":"https:\/\/codefresh.io\/","sameAs":["https:\/\/www.facebook.com\/codefresh.io","https:\/\/www.linkedin.com\/company\/codefresh","https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg","https:\/\/twitter.com\/codefresh"],"logo":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#logo","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","width":800,"height":800,"caption":"Codefresh"},"image":{"@id":"https:\/\/codefresh.io\/#logo"}},{"@type":"WebSite","@id":"https:\/\/codefresh.io\/#website","url":"https:\/\/codefresh.io\/","name":"Codefresh","description":"","publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"potentialAction":[{"@type":"SearchAction","target":{"@type":"EntryPoint","urlTemplate":"https:\/\/codefresh.io\/?s={search_term_string}"},"query-input":"required name=search_term_string"}],"inLanguage":"en-US"},{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/docker-tutorial\/node-docker-and-microservices\/#primaryimage","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2015\/03\/docker-1.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2015\/03\/docker-1.png","width":1600,"height":500},{"@type":"WebPage","@id":"https:\/\/codefresh.io\/docker-tutorial\/node-docker-and-microservices\/#webpage","url":"https:\/\/codefresh.io\/docker-tutorial\/node-docker-and-microservices\/","name":"Node, Docker, and Microservices | Codefresh","isPartOf":{"@id":"https:\/\/codefresh.io\/#website"},"primaryImageOfPage":{"@id":"https:\/\/codefresh.io\/docker-tutorial\/node-docker-and-microservices\/#primaryimage"},"datePublished":"2015-03-19T05:13:06+00:00","dateModified":"2022-01-18T16:42:34+00:00","breadcrumb":{"@id":"https:\/\/codefresh.io\/docker-tutorial\/node-docker-and-microservices\/#breadcrumb"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https:\/\/codefresh.io\/docker-tutorial\/node-docker-and-microservices\/"]}]},{"@type":"BreadcrumbList","@id":"https:\/\/codefresh.io\/docker-tutorial\/node-docker-and-microservices\/#breadcrumb","itemListElement":[{"@type":"ListItem","position":1,"name":"Home","item":"https:\/\/codefresh.io\/"},{"@type":"ListItem","position":2,"name":"Node, Docker, and Microservices"}]},{"@type":"Article","@id":"https:\/\/codefresh.io\/docker-tutorial\/node-docker-and-microservices\/#article","isPartOf":{"@id":"https:\/\/codefresh.io\/docker-tutorial\/node-docker-and-microservices\/#webpage"},"author":{"@id":"https:\/\/codefresh.io\/#\/schema\/person\/7f1e186af5b21641f0f3fe5e8e4281c1"},"headline":"Node, Docker, and Microservices","datePublished":"2015-03-19T05:13:06+00:00","dateModified":"2022-01-18T16:42:34+00:00","mainEntityOfPage":{"@id":"https:\/\/codefresh.io\/docker-tutorial\/node-docker-and-microservices\/#webpage"},"wordCount":2096,"commentCount":1,"publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"image":{"@id":"https:\/\/codefresh.io\/docker-tutorial\/node-docker-and-microservices\/#primaryimage"},"thumbnailUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2015\/03\/docker-1.png","articleSection":["Docker Tutorials"],"inLanguage":"en-US","potentialAction":[{"@type":"CommentAction","name":"Comment","target":["https:\/\/codefresh.io\/docker-tutorial\/node-docker-and-microservices\/#respond"]}]},{"@type":"Person","@id":"https:\/\/codefresh.io\/#\/schema\/person\/7f1e186af5b21641f0f3fe5e8e4281c1","name":"Raziel Tabib","image":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#personlogo","inLanguage":"en-US","url":"https:\/\/secure.gravatar.com\/avatar\/dace30247c8ac4ddb9e90b0d20d382f1?s=96&d=blank&r=g","contentUrl":"https:\/\/secure.gravatar.com\/avatar\/dace30247c8ac4ddb9e90b0d20d382f1?s=96&d=blank&r=g","caption":"Raziel Tabib"},"description":"Co-Founder and CEO, Codefresh","sameAs":["https:\/\/twitter.com\/razieltabib"],"url":"https:\/\/codefresh.io\/author\/raziel-tabib\/"}]}},"acf":[],"_links":{"self":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/13"}],"collection":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/users\/5"}],"replies":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/comments?post=13"}],"version-history":[{"count":2,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/13\/revisions"}],"predecessor-version":[{"id":20991,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/13\/revisions\/20991"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media\/94"}],"wp:attachment":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media?parent=13"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/categories?post=13"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/tags?post=13"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}