{"id":14444,"date":"2019-09-23T09:31:35","date_gmt":"2019-09-23T09:31:35","guid":{"rendered":"http:\/\/codefresh.io\/?p=14444"},"modified":"2019-09-23T09:31:35","modified_gmt":"2019-09-23T09:31:35","slug":"service-container-testing","status":"publish","type":"post","link":"https:\/\/codefresh.io\/continuous-integration\/service-container-testing\/","title":{"rendered":"Easy integration testing with Codefresh pipelines"},"content":{"rendered":"<p>Unit and integration testing is one of the pillars of software quality. Shipping software fast is certainly an important target for any organization, but shipping <strong>correct <\/strong>software is an equally important goal.<\/p>\n<p>There are several types of testing in regards to what area of the application we examine (functional or non-functional requirements), but in the broader sense we can split tests that happen in a CI\/CD pipeline into two categories:<\/p>\n<ul>\n<li>Unit tests that depend only on the source code of the application and nothing else.<\/li>\n<li>Integration\/component\/end-to-end tests that depend on external services (such as a database or a queue) and if you have adopted a microservice architecture you might also need a selection of neighboring services to be up as well.<\/li>\n<\/ul>\n<p>The first category (plain unit tests) is easy to implement in a Codefresh pipeline since the only thing needed is the source code. Just pick a Docker image that contains your tools (e.g. maven\/junit) and run the same command that you would run locally in your workstation. For more details see the <a href=\"https:\/\/codefresh.io\/docs\/docs\/testing\/unit-tests\/\">Codefresh unit testing guide<\/a>.<\/p>\n<p>Integration tests are much more challenging to set up. You need to make your pipeline aware that integration tests are taking place and automatically launch the extra services needed.<\/p>\n<h2>Launch service containers in a pipeline<\/h2>\n<p>Codefresh supported integration testing since its inception by using <a href=\"https:\/\/codefresh.io\/docs\/docs\/codefresh-yaml\/steps\/composition\/\">composition steps<\/a>. Composition steps allow you to describe extra services in your pipeline in a similar manner to Docker compose. However, as more and more companies started using Codefresh for CI\/CD we discussed several improvements on how to make integration testing even easier in order to cover more customer scenarios. To this purpose, Codefresh now supports <strong>Service Containers<\/strong>.<\/p>\n<p><a href=\"https:\/\/codefresh.io\/docs\/docs\/codefresh-yaml\/service-containers\/\">Service Containers<\/a> are the recommended way to run integration tests from now on. Plain composition steps are still supported, so don\u2019t fear that you need to migrate your existing steps to service containers.<\/p>\n<p>Some of the major advantages that service containers have (and will be described in more detail below) are:<\/p>\n<ol>\n<li>Ability to <a href=\"https:\/\/codefresh.io\/docs\/docs\/codefresh-yaml\/service-containers\/#checking-readiness-of-a-service\">control service startup order<\/a> in a fine-grained manner<\/li>\n<li>\nExplicit mode for <a href=\"https:\/\/codefresh.io\/docs\/docs\/codefresh-yaml\/service-containers\/#preloading-data-to-databases\">preloading test data<\/a> to databases or doing other initialization tasks<\/li>\n<li>Automatic mounting of the <a href=\"https:\/\/codefresh.io\/docs\/docs\/configure-ci-cd-pipeline\/introduction-to-codefresh-pipelines\/#sharing-the-workspace-between-build-steps\">shared Codefresh volume<\/a> in order to access your source code in integration tests<\/li>\n<li>Launching services <a href=\"https:\/\/codefresh.io\/docs\/docs\/codefresh-yaml\/service-containers\/#running-services-for-the-duration-of-the-pipeline\">for the duration of the whole pipeline<\/a> instead of just individual pipeline steps.<\/li>\n<\/ol>\n<p>As a very simple example let\u2019s say you want to use a Redis datastore in your pipeline because your Node.JS application depends on it.<\/p>\n<figure id=\"attachment_14448\" aria-describedby=\"caption-attachment-14448\" style=\"width: 676px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2019\/09\/from-source-code.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2019\/09\/from-source-code.png\" alt=\"Redis integration tests\" width=\"676\" height=\"354\" class=\"size-full wp-image-14448\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2019\/09\/from-source-code.png 676w, https:\/\/codefresh.io\/wp-content\/uploads\/2019\/09\/from-source-code-300x157.png 300w\" sizes=\"(max-width: 676px) 100vw, 676px\" \/><\/a><figcaption id=\"caption-attachment-14448\" class=\"wp-caption-text\">Redis integration tests<\/figcaption><\/figure>\n<p>Your integration tests expect the Redis hostname to be my_redis (with the standard Redis port). Here is the Codefresh YAML that does this:<\/p>\n<pre>\n my_tests:\n    image: 'node:11'\n    title: \"Integration tests\"\n    commands:\n      - 'npm test'\n    services:\n      composition:\n        my_redis:\n          image: 'redis:latest'\n          ports:\n            - 6379\n<\/pre>\n<p>The syntax for services is similar to <a href=\"https:\/\/docs.docker.com\/compose\/\">Docker compose<\/a> (in fact you can even reference an existing docker-compose file in your pipeline if you already have one). And as with Docker compose, you can create any complex microservice architecture that you need for integration tests.<\/p>\n<h2>Controlling the startup order of services<\/h2>\n<p>One of the killer features of service containers is the ability to control the exact order of services launched. This way when your integration tests run, you know that all services are actually up and running. This is a well-known problem that <a href=\"https:\/\/docs.docker.com\/compose\/startup-order\/\">is not solved even by Docker compose itself<\/a>.<\/p>\n<figure id=\"attachment_14450\" aria-describedby=\"caption-attachment-14450\" style=\"width: 865px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2019\/09\/complex-tests.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2019\/09\/complex-tests.png\" alt=\"\" width=\"865\" height=\"438\" class=\"size-full wp-image-14450\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2019\/09\/complex-tests.png 865w, https:\/\/codefresh.io\/wp-content\/uploads\/2019\/09\/complex-tests-300x152.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2019\/09\/complex-tests-768x389.png 768w\" sizes=\"(max-width: 865px) 100vw, 865px\" \/><\/a><figcaption id=\"caption-attachment-14450\" class=\"wp-caption-text\">Complex integration tests<\/figcaption><\/figure>\n<p>Let\u2019s say that you have a pipeline like the picture shown above. You need to make sure that both datastores are up before launching the backend, and also that the backend is itself up before launching the front-end.<\/p>\n<p>This particular issue is usually solved with <a href=\"https:\/\/github.com\/vishnubob\/wait-for-it\">special wait-for-it scripts<\/a> that loop over a port until it is actually ready to receive connection. These scripts do work, but in a very clumsy manner, because you have to remember to include them in <strong>every <\/strong> Dockerfile that needs them.<\/p>\n<p>Codefresh instead offers you this functionality in a built-in manner placing it where it belongs (i.e. in the pipeline). For each service container, you can define one or more commands that will check a condition in a setup block. The condition is automatically looped by Codefresh until it becomes true. Here is a very simple example for PostgreSQL:<\/p>\n<pre>\n run_integration_tests:\n    image: '${{build_image}}'\n    commands:\n      # PostgreSQL is certainly up at this point\n      - rails db:migrate\n      - rails test\n    services:\n      composition:\n        my_postgresql_db:\n          image: postgres:latest\n          ports:\n            - 5432 \n      readiness:\n        timeoutSeconds: 30\n        periodSeconds: 15\n        image: 'postgres:latest'\n        commands:\n          - \"pg_isready -h my_postgresql_db\"\n<\/pre>\n<p>In the example above our Rails tests only run when the PostgreSQL DB is actually ready to receive connections. Notice the complete lack of a looping script. Codefresh will automatically loop on its own running pg_isready all the time. Of course you can specify timeouts and the loop period <a href=\"https:\/\/codefresh.io\/docs\/docs\/codefresh-yaml\/service-containers\/#checking-readiness-of-a-service\">as well as other parameters<\/a>.<\/p>\n<p>The commands and Docker image that you use in the readiness block are arbitrary. Another common pattern is to just use curl for checking the status of a web application:<\/p>\n<pre>\n run_integration_tests:\n    title: \"Running integration tests\"\n    stage: test\n    image: '${{build_test_image}}'\n    commands:\n      # Tomcat is certainly up at this point\n      - mvn verify -Dserver.host=app\n    services:\n      composition:\n        app:\n          image: '${{build_app_image}}'\n          ports:\n            - 8080\n      readiness:\n        timeoutSeconds: 30\n        periodSeconds: 15\n        image: byrnedo\/alpine-curl\n        commands:\n          - \"curl http:\/\/app:8080\/health\"\n<\/pre>\n<p>In this pipeline we make sure that the <code>\/health<\/code> endpoint of our application under test is up and running and then we start the integration tests.<\/p>\n<p>This is a very powerful technique because it means that no matter the services you need in integration tests, they will always start in the correct order that you have defined. The definition of being \u201cready\u201d for each service is up to you. Simple HTTP and TCP checks are very common, but given the power of Docker images, you could create your own complex health check in exactly the way that your service is working.<\/p>\n<h2>Preloading a database with Test data<\/h2>\n<p>Another common scenario with database testing is when you need test data in the DB. Some tests are smart enough to create and delete their own data from a dB, but even in this case you still need some minimum data such as read-only values, configuration properties, and other information that is \u201calways there\u201d.<\/p>\n<p>Service containers also support a \u201csetup\u201d block that you can use to run any initialization code that you need. What you put in this block is entirely up to you.<\/p>\n<pre>\nrun_integration_tests:\n    image: '${{build_image}}'\n    commands:\n      # PostgreSQL is certainly up at this point and has the correct data\n      - rails test\n    services:\n      composition:\n        my_postgresql_db:\n          image: postgres:latest\n          ports:\n            - 5432 \n      readiness:\n        timeoutSeconds: 30\n        periodSeconds: 15\n        image: 'postgres:latest'\n        commands:\n          - \"pg_isready -h my_postgresql_db\"   \n      setup:\n        image: 'postgres:latest'\n        commands:\n          - \"wget my-staging-server.exaple.com\/testdata\/preload.sql\"\n          - \"psql -h my_postgresql_db < testdata\/preload.sql\"\n<\/pre>\n<p>In the example above, we download a SQL script inside the Postgres container and then automatically load it in the database. Codefresh is smart enough and will run all blocks in the way that you expect them. First, the readiness block will ensure that the database is up, and then the setup block will prepare the test data.<\/p>\n<p>When the integration tests start, Codefresh guarantees that both the Database and its test data will be ready for the tests. PosgreSQL is just an example. You can follow the same technique with other databases, a queue, or any custom service.<\/p>\n<h2>Duration of test infrastructure<\/h2>\n<p>One important thing to remember regarding test infrastructure is that it shares the same resources with your pipeline. The more memory\/cpu your tests need, the less it remains for the actual pipeline.<\/p>\n<p>It is therefore wise to launch extra services only when you actually need them. And the most natural way to do this is to only launch service containers in the steps that require them:<\/p>\n<figure id=\"attachment_14453\" aria-describedby=\"caption-attachment-14453\" style=\"width: 688px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2019\/09\/single-scope.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2019\/09\/single-scope.png\" alt=\"Tests per pipeline step\" width=\"688\" height=\"476\" class=\"size-full wp-image-14453\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2019\/09\/single-scope.png 688w, https:\/\/codefresh.io\/wp-content\/uploads\/2019\/09\/single-scope-300x208.png 300w\" sizes=\"(max-width: 688px) 100vw, 688px\" \/><\/a><figcaption id=\"caption-attachment-14453\" class=\"wp-caption-text\">Tests per pipeline step<\/figcaption><\/figure>\n<p>This is the recommended way to run service containers as it is very resource-efficient. Each set of services is launched before the step that needs it, the step then executes, and then all test infrastructure is torn down.<br \/>\nAll the examples mentioned so far in this blog post use this technique.<\/p>\n<p>We also have listened to customer feedback which involves cases where the test infrastructure is needed for the whole pipeline. The test infrastructure is launched once, the pipeline starts and finishes, and then everything is discarded.<\/p>\n<figure id=\"attachment_14454\" aria-describedby=\"caption-attachment-14454\" style=\"width: 670px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2019\/09\/multi-scope.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2019\/09\/multi-scope.png\" alt=\"Reusing test infrastructure\" width=\"670\" height=\"476\" class=\"size-full wp-image-14454\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2019\/09\/multi-scope.png 670w, https:\/\/codefresh.io\/wp-content\/uploads\/2019\/09\/multi-scope-300x213.png 300w\" sizes=\"(max-width: 670px) 100vw, 670px\" \/><\/a><figcaption id=\"caption-attachment-14454\" class=\"wp-caption-text\">Reusing test infrastructure<\/figcaption><\/figure>\n<p>In order to accomplish this behavior you can simple move the service container YAML to the root of the pipeline:<\/p>\n<p>Here is an example where a Redis instance is accessible to all pipeline steps:<\/p>\n<pre>\nversion: \"1.0\"\nservices:\n  name: my_database\n  composition:\n    my-redis-db-host:\n      image: redis:latest\n      ports:\n        - 6379\nsteps:\n  my_first_step:\n    image: alpine:latest\n    title: Storing Redis data\n    commands:\n      - apk --update add redis\n      - redis-cli -u redis:\/\/my-redis-db-host:6379 -n 0 LPUSH mylist \"hello world\"  \n      - echo finished\n    services:\n      - my_database\n  my_second_step:\n    image: alpine:latest\n    commands:\n      - echo \"Another step in the middle of the pipeline\"    \n  my_third_step:\n    image: alpine:latest\n    title: Reading Redis data\n    commands:\n      - apk --update add redis\n      - redis-cli -u redis:\/\/my-redis-db-host:6379 -n 0 LPOP mylist \n    services:\n      - my_database \n<\/pre>\n<p>Notice that the <code>services<\/code> block is at the root of the yaml instead of being a child in a specific step. Please use this technique with caution as it can be very heavy on your pipeline resources.<\/p>\n<p>Service containers are currently available to all Codefresh accounts of all tiers (even free ones), so you can use them in your own pipelines right now.<\/p>\n<p>Ready to try Codefresh and start creating your own CI\/CD pipelines for microservices? <a href=\"https:\/\/codefresh.io\/codefresh-signup\/?utm_source=Blog&#038;utm_medium=Post&#038;utm_campaign=servicecontainers\">Create Your Free Account Today<\/a>!<\/p>\n<input class=\"fooboxshare_post_id\" type=\"hidden\" value=\"14444\"\/>","protected":false},"excerpt":{"rendered":"<p>Unit and integration testing is one of the pillars of software quality. Shipping software fast is certainly an important target for any organization, but shipping correct software is an equally important goal. There are several types of testing in regards to what area of the application we examine (functional or non-functional requirements), but in the &hellip; <a href=\"https:\/\/codefresh.io\/continuous-integration\/service-container-testing\/\">Read more<\/a><\/p>\n","protected":false},"author":62,"featured_media":14446,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[2507,1505,1543,1538],"tags":[15,24,49,52,53,59,65,67],"yoast_head":"<!-- This site is optimized with the Yoast SEO Premium plugin v17.9 (Yoast SEO v18.4.1) - https:\/\/yoast.com\/wordpress\/plugins\/seo\/ -->\n<title>Easy integration testing with Codefresh pipelines | Codefresh<\/title>\n<meta name=\"robots\" content=\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\" \/>\n<link rel=\"canonical\" href=\"https:\/\/codefresh.io\/continuous-integration\/service-container-testing\/\" \/>\n<meta property=\"og:locale\" content=\"en_US\" \/>\n<meta property=\"og:type\" content=\"article\" \/>\n<meta property=\"og:title\" content=\"Easy integration testing with Codefresh pipelines\" \/>\n<meta property=\"og:description\" content=\"Unit and integration testing is one of the pillars of software quality. Shipping software fast is certainly an important target for any organization, but shipping correct software is an equally important goal. There are several types of testing in regards to what area of the application we examine (functional or non-functional requirements), but in the &hellip; Read more\" \/>\n<meta property=\"og:url\" content=\"https:\/\/codefresh.io\/continuous-integration\/service-container-testing\/\" \/>\n<meta property=\"og:site_name\" content=\"Codefresh\" \/>\n<meta property=\"article:publisher\" content=\"https:\/\/www.facebook.com\/codefresh.io\" \/>\n<meta property=\"article:published_time\" content=\"2019-09-23T09:31:35+00:00\" \/>\n<meta property=\"og:image\" content=\"https:\/\/codefresh.io\/wp-content\/uploads\/2019\/09\/testing_article.jpg\" \/>\n\t<meta property=\"og:image:width\" content=\"671\" \/>\n\t<meta property=\"og:image:height\" content=\"200\" \/>\n\t<meta property=\"og:image:type\" content=\"image\/jpeg\" \/>\n<meta name=\"twitter:card\" content=\"summary_large_image\" \/>\n<meta name=\"twitter:creator\" content=\"@codefresh\" \/>\n<meta name=\"twitter:site\" content=\"@codefresh\" \/>\n<meta name=\"twitter:label1\" content=\"Written by\" \/>\n\t<meta name=\"twitter:data1\" content=\"Kostis Kapelonis\" \/>\n\t<meta name=\"twitter:label2\" content=\"Est. reading time\" \/>\n\t<meta name=\"twitter:data2\" content=\"8 minutes\" \/>\n<script type=\"application\/ld+json\" class=\"yoast-schema-graph\">{\"@context\":\"https:\/\/schema.org\",\"@graph\":[{\"@type\":\"Organization\",\"@id\":\"https:\/\/codefresh.io\/#organization\",\"name\":\"Codefresh\",\"url\":\"https:\/\/codefresh.io\/\",\"sameAs\":[\"https:\/\/www.facebook.com\/codefresh.io\",\"https:\/\/www.linkedin.com\/company\/codefresh\",\"https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg\",\"https:\/\/twitter.com\/codefresh\"],\"logo\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#logo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"width\":800,\"height\":800,\"caption\":\"Codefresh\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/#logo\"}},{\"@type\":\"WebSite\",\"@id\":\"https:\/\/codefresh.io\/#website\",\"url\":\"https:\/\/codefresh.io\/\",\"name\":\"Codefresh\",\"description\":\"\",\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"potentialAction\":[{\"@type\":\"SearchAction\",\"target\":{\"@type\":\"EntryPoint\",\"urlTemplate\":\"https:\/\/codefresh.io\/?s={search_term_string}\"},\"query-input\":\"required name=search_term_string\"}],\"inLanguage\":\"en-US\"},{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/continuous-integration\/service-container-testing\/#primaryimage\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2019\/09\/testing_article.jpg\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2019\/09\/testing_article.jpg\",\"width\":671,\"height\":200},{\"@type\":\"WebPage\",\"@id\":\"https:\/\/codefresh.io\/continuous-integration\/service-container-testing\/#webpage\",\"url\":\"https:\/\/codefresh.io\/continuous-integration\/service-container-testing\/\",\"name\":\"Easy integration testing with Codefresh pipelines | Codefresh\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/#website\"},\"primaryImageOfPage\":{\"@id\":\"https:\/\/codefresh.io\/continuous-integration\/service-container-testing\/#primaryimage\"},\"datePublished\":\"2019-09-23T09:31:35+00:00\",\"dateModified\":\"2019-09-23T09:31:35+00:00\",\"breadcrumb\":{\"@id\":\"https:\/\/codefresh.io\/continuous-integration\/service-container-testing\/#breadcrumb\"},\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"ReadAction\",\"target\":[\"https:\/\/codefresh.io\/continuous-integration\/service-container-testing\/\"]}]},{\"@type\":\"BreadcrumbList\",\"@id\":\"https:\/\/codefresh.io\/continuous-integration\/service-container-testing\/#breadcrumb\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"name\":\"Home\",\"item\":\"https:\/\/codefresh.io\/\"},{\"@type\":\"ListItem\",\"position\":2,\"name\":\"Easy integration testing with Codefresh pipelines\"}]},{\"@type\":\"Article\",\"@id\":\"https:\/\/codefresh.io\/continuous-integration\/service-container-testing\/#article\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/continuous-integration\/service-container-testing\/#webpage\"},\"author\":{\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87\"},\"headline\":\"Easy integration testing with Codefresh pipelines\",\"datePublished\":\"2019-09-23T09:31:35+00:00\",\"dateModified\":\"2019-09-23T09:31:35+00:00\",\"mainEntityOfPage\":{\"@id\":\"https:\/\/codefresh.io\/continuous-integration\/service-container-testing\/#webpage\"},\"wordCount\":1382,\"commentCount\":0,\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/continuous-integration\/service-container-testing\/#primaryimage\"},\"thumbnailUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2019\/09\/testing_article.jpg\",\"keywords\":[\"continuous integration\",\"Containers\",\"test automation\",\"devops\",\"CI\/CD\",\"codefresh\",\"testing\",\"unit testing\"],\"articleSection\":[\"Deployment Verification Testing\",\"Containers\",\"Continuous Integration\",\"DevOps Tutorials\"],\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"CommentAction\",\"name\":\"Comment\",\"target\":[\"https:\/\/codefresh.io\/continuous-integration\/service-container-testing\/#respond\"]}]},{\"@type\":\"Person\",\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87\",\"name\":\"Kostis Kapelonis\",\"image\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#personlogo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png\",\"caption\":\"Kostis Kapelonis\"},\"description\":\"Kostis is a software engineer\/technical-writer dual class character. He lives and breathes automation, good testing practices and stress-free deployments with GitOps.\",\"url\":\"https:\/\/codefresh.io\/author\/kostiscodefresh-io\/\"}]}<\/script>\n<!-- \/ Yoast SEO Premium plugin. -->","yoast_head_json":{"title":"Easy integration testing with Codefresh pipelines | Codefresh","robots":{"index":"index","follow":"follow","max-snippet":"max-snippet:-1","max-image-preview":"max-image-preview:large","max-video-preview":"max-video-preview:-1"},"canonical":"https:\/\/codefresh.io\/continuous-integration\/service-container-testing\/","og_locale":"en_US","og_type":"article","og_title":"Easy integration testing with Codefresh pipelines","og_description":"Unit and integration testing is one of the pillars of software quality. Shipping software fast is certainly an important target for any organization, but shipping correct software is an equally important goal. There are several types of testing in regards to what area of the application we examine (functional or non-functional requirements), but in the &hellip; Read more","og_url":"https:\/\/codefresh.io\/continuous-integration\/service-container-testing\/","og_site_name":"Codefresh","article_publisher":"https:\/\/www.facebook.com\/codefresh.io","article_published_time":"2019-09-23T09:31:35+00:00","og_image":[{"width":671,"height":200,"url":"https:\/\/codefresh.io\/wp-content\/uploads\/2019\/09\/testing_article.jpg","type":"image\/jpeg"}],"twitter_card":"summary_large_image","twitter_creator":"@codefresh","twitter_site":"@codefresh","twitter_misc":{"Written by":"Kostis Kapelonis","Est. reading time":"8 minutes"},"schema":{"@context":"https:\/\/schema.org","@graph":[{"@type":"Organization","@id":"https:\/\/codefresh.io\/#organization","name":"Codefresh","url":"https:\/\/codefresh.io\/","sameAs":["https:\/\/www.facebook.com\/codefresh.io","https:\/\/www.linkedin.com\/company\/codefresh","https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg","https:\/\/twitter.com\/codefresh"],"logo":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#logo","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","width":800,"height":800,"caption":"Codefresh"},"image":{"@id":"https:\/\/codefresh.io\/#logo"}},{"@type":"WebSite","@id":"https:\/\/codefresh.io\/#website","url":"https:\/\/codefresh.io\/","name":"Codefresh","description":"","publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"potentialAction":[{"@type":"SearchAction","target":{"@type":"EntryPoint","urlTemplate":"https:\/\/codefresh.io\/?s={search_term_string}"},"query-input":"required name=search_term_string"}],"inLanguage":"en-US"},{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/continuous-integration\/service-container-testing\/#primaryimage","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2019\/09\/testing_article.jpg","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2019\/09\/testing_article.jpg","width":671,"height":200},{"@type":"WebPage","@id":"https:\/\/codefresh.io\/continuous-integration\/service-container-testing\/#webpage","url":"https:\/\/codefresh.io\/continuous-integration\/service-container-testing\/","name":"Easy integration testing with Codefresh pipelines | Codefresh","isPartOf":{"@id":"https:\/\/codefresh.io\/#website"},"primaryImageOfPage":{"@id":"https:\/\/codefresh.io\/continuous-integration\/service-container-testing\/#primaryimage"},"datePublished":"2019-09-23T09:31:35+00:00","dateModified":"2019-09-23T09:31:35+00:00","breadcrumb":{"@id":"https:\/\/codefresh.io\/continuous-integration\/service-container-testing\/#breadcrumb"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https:\/\/codefresh.io\/continuous-integration\/service-container-testing\/"]}]},{"@type":"BreadcrumbList","@id":"https:\/\/codefresh.io\/continuous-integration\/service-container-testing\/#breadcrumb","itemListElement":[{"@type":"ListItem","position":1,"name":"Home","item":"https:\/\/codefresh.io\/"},{"@type":"ListItem","position":2,"name":"Easy integration testing with Codefresh pipelines"}]},{"@type":"Article","@id":"https:\/\/codefresh.io\/continuous-integration\/service-container-testing\/#article","isPartOf":{"@id":"https:\/\/codefresh.io\/continuous-integration\/service-container-testing\/#webpage"},"author":{"@id":"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87"},"headline":"Easy integration testing with Codefresh pipelines","datePublished":"2019-09-23T09:31:35+00:00","dateModified":"2019-09-23T09:31:35+00:00","mainEntityOfPage":{"@id":"https:\/\/codefresh.io\/continuous-integration\/service-container-testing\/#webpage"},"wordCount":1382,"commentCount":0,"publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"image":{"@id":"https:\/\/codefresh.io\/continuous-integration\/service-container-testing\/#primaryimage"},"thumbnailUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2019\/09\/testing_article.jpg","keywords":["continuous integration","Containers","test automation","devops","CI\/CD","codefresh","testing","unit testing"],"articleSection":["Deployment Verification Testing","Containers","Continuous Integration","DevOps Tutorials"],"inLanguage":"en-US","potentialAction":[{"@type":"CommentAction","name":"Comment","target":["https:\/\/codefresh.io\/continuous-integration\/service-container-testing\/#respond"]}]},{"@type":"Person","@id":"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87","name":"Kostis Kapelonis","image":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#personlogo","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png","caption":"Kostis Kapelonis"},"description":"Kostis is a software engineer\/technical-writer dual class character. He lives and breathes automation, good testing practices and stress-free deployments with GitOps.","url":"https:\/\/codefresh.io\/author\/kostiscodefresh-io\/"}]}},"acf":[],"_links":{"self":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/14444"}],"collection":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/users\/62"}],"replies":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/comments?post=14444"}],"version-history":[{"count":0,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/14444\/revisions"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media\/14446"}],"wp:attachment":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media?parent=14444"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/categories?post=14444"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/tags?post=14444"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}