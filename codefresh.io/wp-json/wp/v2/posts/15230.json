{"id":15230,"date":"2020-03-05T01:56:41","date_gmt":"2020-03-05T09:56:41","guid":{"rendered":"http:\/\/codefresh.io\/?p=15230"},"modified":"2020-03-26T04:35:12","modified_gmt":"2020-03-26T12:35:12","slug":"create-docker-images-for-java","status":"publish","type":"post","link":"https:\/\/codefresh.io\/docker-tutorial\/create-docker-images-for-java\/","title":{"rendered":"Three Ways to Create Docker Images for Java"},"content":{"rendered":"<p>Long before Dockerfiles, Java developers worked with single deployment units (WARs, JARs, EARs, etc.).  As you likely know by now, it is best practice to work in micro-services, deploying a small number of deployment units per JVM.  Instead of one giant, monolithic application, you build your application such that each service can run on its own.<\/p>\n<p>This is where Docker comes in!  If you wish to upgrade a service, rather than redeploying your jar\/war\/ear to a new instance of an application server, you can just build a new Docker image with the upgraded deployment unit.<\/p>\n<p>In this post, I will review 3 different ways to create Docker images for Java applications. If you want to follow along feel free to clone my repository at <a href=\"https:\/\/github.com\/annabaker\/docker-with-java-demos\">https:\/\/github.com\/annabaker\/docker-with-java-demos<\/a>.<\/p>\n<h2>Prerequisites<\/h2>\n<ul>\n<li>Docker is <a href=\"https:\/\/docs.docker.com\/install\/\">installed<\/a><\/li>\n<li>Maven is <a href=\"https:\/\/maven.apache.org\/install.html\">installed <\/a>(for example #1)<\/li>\n<li>You have a simple Spring Boot application (I used the <a href=\"https:\/\/spring.io\/guides\/gs\/spring-boot\/#scratch\">Spring Initializr<\/a> project generator with a Spring Web dependency)<\/li>\n<\/ul>\n<h2> First way: Package-only Build<\/h2>\n<p>In a package-only build, we will let Maven (or your build tool of choice) control the build process.<\/p>\n<p>Unzip the Spring Initializr project you generated as part of the prerequisites.  In the parent folder of your Spring Boot application, create a Dockerfile.  In a terminal, run:<\/p>\n<pre>\n$ unzip demo.zip\n$ cd demo\n$ nano Dockerfile\n<\/pre>\n<p>Paste the following and save:<\/p>\n<pre>\n# we will use openjdk 8 with alpine as it is a very small linux distro\nFROM openjdk:8-jre-alpine3.9\n\n# copy the packaged jar file into our docker image\nCOPY target\/demo-0.0.1-SNAPSHOT.jar \/demo.jar\n\n# set the startup command to execute the jar\nCMD [\"java\", \"-jar\", \"\/demo.jar\"]\n<\/pre>\n<ul>\n<li>The <code>FROM <\/code>layer denotes which parent image to use for our child image<\/li>\n<li>The <code>COPY <\/code>layer will copy the local jar previously built by Maven into our image<\/li>\n<li>The <code>CMD <\/code>layer tells Docker the command to run inside the container once the previous steps have been executed<\/li>\n<\/ul>\n<p>Now, let\u2019s package our application into a .jar using Maven:<\/p>\n<pre>\n$ mvn clean package\n<\/pre>\n<p>\u2026and then build the Docker image.  The following command tells Docker to fetch the Dockerfile in the current directory (the period at the end of the command).  We build using the username\/image name convention, although this is not mandatory.  The -t flag denotes a Docker tag, which in this case is <code>1.0-SNAPSHOT<\/code>.  If you don\u2019t provide a tag, Docker will default to the tag <code>:latest<\/code>.<\/p>\n<pre>\n$ docker build -t anna\/docker-package-only-build-demo:1.0-SNAPSHOT .\n<\/pre>\n<p>To run the container from the image we just created:<\/p>\n<pre>\n$ docker run -d -p 8080:8080 anna\/docker-package-only-build-demo:1.0-SNAPSHOT\n<\/pre>\n<p>-d will run the container in the background (detached mode), and -p will map our local port 8080 to the container\u2019s port of 8080.<\/p>\n<p>Navigate to localhost:8080, and you should see the following:<\/p>\n<figure id=\"attachment_15235\" aria-describedby=\"caption-attachment-15235\" style=\"width: 498px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/03\/launch-app.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/03\/launch-app.png\" alt=\"Spring inside docker\" width=\"498\" height=\"115\" class=\"size-full wp-image-15235\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/03\/launch-app.png 498w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/03\/launch-app-300x69.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/03\/launch-app-20x5.png 20w\" sizes=\"(max-width: 498px) 100vw, 498px\" \/><\/a><figcaption id=\"caption-attachment-15235\" class=\"wp-caption-text\">Spring inside docker<\/figcaption><\/figure>\n<p>Once you are satisfied with your testing, stop the container.<\/p>\n<pre>\n$ docker stop <container_id>\n<\/pre>\n<h3>Pros to this approach:<\/h3>\n<ul>\n<li>Results in a light-weight Docker image<\/li>\n<li>Does not require Maven to be included in the Docker image<\/li>\n<li>Does not require any of our application\u2019s dependencies to be packaged into the image<\/li>\n<li>You can still utilize your local Maven cache upon application layer changes, as opposed to methods 2 and 3 which we will discuss later<\/li>\n<\/ul>\n<h3>Cons to this approach:<\/h3>\n<ul>\n<li>Requires Maven and JDK to be installed on the host machine<\/li>\n<li>The Docker build will fail if the Maven build fails\/is not executed beforehand \u2014 this becomes a problem when you want to integrate with services that automatically \u201cjust build\u201d using the present Dockerfile<\/li>\n<\/ul>\n<h2> Second way: Normal Docker Build <\/h2>\n<p>In a \u201cnormal\u201d Docker build, Docker will control the build process.<br \/>\nModify the previous Dockerfile to contain the following:<\/p>\n<pre>\n# select parent image\nFROM maven:3.6.3-jdk-8\n\n# copy the source tree and the pom.xml to our new container\nCOPY .\/ .\/\n\n# package our application code\nRUN mvn clean package\n\n# set the startup command to execute the jar\nCMD [\"java\", \"-jar\", \"target\/demo-0.0.1-SNAPSHOT.jar\"]\n<\/pre>\n<p>Now, let\u2019s build a new image as we did in Step 1:<\/p>\n<pre>\n$ docker build -t anna\/docker-normal-build-demo:1.0-SNAPSHOT .\n<\/pre>\n<p>And run the container:<\/p>\n<pre>\n$ docker run -d -p 8080:8080 anna\/docker-normal-build-demo:1.0-SNAPSHOT\n<\/pre>\n<p>Again, to test your container, navigate to localhost:8080.  Stop the container once you are finished testing.<\/p>\n<h3>Pros to this approach:<\/h3>\n<ul>\n<li>Docker controls the build process, therefore this method does not require the build tool or the JDK to be installed on the host machine beforehand<\/li>\n<li>\nIntegrates well with services that automatically \u201cjust build\u201d using the present Dockerfile<\/li>\n<\/ul>\n<h3>Cons to this approach:<\/h3>\n<ul>\n<li>Results in the largest Docker image of our 3 methods<\/li>\n<li>This build method not only packaged our app, but all of its dependencies and the build tool itself, which is not necessary to run the executable<\/li>\n<li>If the application layer is rebuilt, the mvn package command will force all Maven dependencies to be pulled from the remote repository all over again (you lose the local Maven cache)<\/li>\n<\/ul>\n<h2>Multi-stage Build (The ideal way)<\/h2>\n<p>With multi-stage Docker builds, we use multiple <code>FROM <\/code>statements for each build stage.  Every <code>FROM <\/code>statement creates a new base layer, and discards everything we don\u2019t need from the previous <code>FROM <\/code>stage.<\/p>\n<p>Modify your Dockerfile to contain the following:<\/p>\n<pre>\n# the first stage of our build will use a maven 3.6.1 parent image\nFROM maven:3.6.1-jdk-8-alpine AS MAVEN_BUILD\n\n# copy the pom and src code to the container\nCOPY .\/ .\/\n\n# package our application code\nRUN mvn clean package\n\n# the second stage of our build will use open jdk 8 on alpine 3.9\nFROM openjdk:8-jre-alpine3.9\n\n# copy only the artifacts we need from the first stage and discard the rest\nCOPY --from=MAVEN_BUILD \/docker-multi-stage-build-demo\/target\/demo-0.0.1-SNAPSHOT.jar \/demo.jar\n\n# set the startup command to execute the jar\nCMD [\"java\", \"-jar\", \"\/demo.jar\"]\n<\/pre>\n<p>Build the image:<\/p>\n<pre>\n$ docker build -t anna\/docker-multi-stage-build-demo:1.0-SNAPSHOT .\n<\/pre>\n<p>And then run the container:<\/p>\n<pre>\n$ docker run -d -p 8080:8080 anna\/docker-multi-stage-build-demo:1.0-SNAPSHOT\n<\/pre>\n<h3>Pros to this approach:<\/h3>\n<ul>\n<li>Results in a light-weight Docker image<\/li>\n<li>Does not require the build tool or JDK to be installed on the host machine beforehand (Docker controls the build process)<\/li>\n<li>Integrates well with services that automatically \u201cjust build\u201d using the present Dockerfile<\/li>\n<li>Only artifacts we need are copied from one stage to the next (i.e., our application\u2019s dependencies are not packaged into the final image as in the previous method)<\/li>\n<li>Create as many build stages as you need<\/li>\n<li>Stop at any particular stage on an image build using the \u2013target flag, i.e.\n<pre>\ndocker build --target MAVEN_BUILD -t anna\/docker-multi-stage-build-demo:1.0-SNAPSHOT .\n<\/pre>\n<\/li>\n<\/ul>\n<h3>Cons to this approach:<\/h3>\n<p>If the application layer is rebuilt, the mvn package command will force all Maven dependencies to be pulled from the remote repository all over again (you lose the local Maven cache)<\/p>\n<h2>Verification:  How big are the images?<\/h2>\n<p>In a terminal, run:<\/p>\n<pre>\ndocker image ls\n<\/pre>\n<p>You should see something like the following:<\/p>\n<figure id=\"attachment_15238\" aria-describedby=\"caption-attachment-15238\" style=\"width: 730px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/03\/image-size.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/03\/image-size.png\" alt=\"Docker image size comparison\" width=\"730\" height=\"53\" class=\"size-full wp-image-15238\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/03\/image-size.png 730w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/03\/image-size-300x22.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/03\/image-size-20x1.png 20w\" sizes=\"(max-width: 730px) 100vw, 730px\" \/><\/a><figcaption id=\"caption-attachment-15238\" class=\"wp-caption-text\">Docker image size comparison<\/figcaption><\/figure>\n<p>As you can see, the multi-stage build resulted in our smallest image, whereas the normal build resulted in our largest image.  This should be expected since the normal build included our application code, all of its dependencies, and our build tooling, and our multi-stage build contained only what we needed.<\/p>\n<h2>Conclusion<\/h2>\n<p>Of the three Docker image build methods we covered, Multi-stage builds are the way to go.  You get the best of both worlds when packaging your application code \u2014 Docker controls the build, but you extract only the artifacts you need.  This becomes particularly important when storing containers on the cloud.<\/p>\n<ul>\n<li>You spend less time building and transferring your containers on the cloud, as your image is much smaller<\/li>\n<li>Cost \u2014 the smaller your image, the cheaper it will be to store<\/li>\n<li>Smaller surface area, aka removing additional dependencies from our image makes it less prone to attacks<\/li>\n<\/ul>\n<p>Thanks for following along, and I hope this helps!  You can find the source code for all three examples at <a href=\"https:\/\/github.com\/annabaker\/docker-with-java-demos\">https:\/\/github.com\/annabaker\/docker-with-java-demos<\/a><\/p>\n<p>In a future post I will show you how to deal with caching issues specifically for Java builds.<\/p>\n<input class=\"fooboxshare_post_id\" type=\"hidden\" value=\"15230\"\/>","protected":false},"excerpt":{"rendered":"<p>Long before Dockerfiles, Java developers worked with single deployment units (WARs, JARs, EARs, etc.). As you likely know by now, it is best practice to work in micro-services, deploying a small number of deployment units per JVM. Instead of one giant, monolithic application, you build your application such that each service can run on its &hellip; <a href=\"https:\/\/codefresh.io\/docker-tutorial\/create-docker-images-for-java\/\">Read more<\/a><\/p>\n","protected":false},"author":125,"featured_media":15231,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[8,1505,6],"tags":[14,24,53,86,87],"yoast_head":"<!-- This site is optimized with the Yoast SEO Premium plugin v17.9 (Yoast SEO v18.4.1) - https:\/\/yoast.com\/wordpress\/plugins\/seo\/ -->\n<title>Three Ways to Create Docker Images for Java | Codefresh<\/title>\n<meta name=\"robots\" content=\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\" \/>\n<link rel=\"canonical\" href=\"https:\/\/codefresh.io\/docker-tutorial\/create-docker-images-for-java\/\" \/>\n<meta property=\"og:locale\" content=\"en_US\" \/>\n<meta property=\"og:type\" content=\"article\" \/>\n<meta property=\"og:title\" content=\"Three Ways to Create Docker Images for Java\" \/>\n<meta property=\"og:description\" content=\"Long before Dockerfiles, Java developers worked with single deployment units (WARs, JARs, EARs, etc.). As you likely know by now, it is best practice to work in micro-services, deploying a small number of deployment units per JVM. Instead of one giant, monolithic application, you build your application such that each service can run on its &hellip; Read more\" \/>\n<meta property=\"og:url\" content=\"https:\/\/codefresh.io\/docker-tutorial\/create-docker-images-for-java\/\" \/>\n<meta property=\"og:site_name\" content=\"Codefresh\" \/>\n<meta property=\"article:publisher\" content=\"https:\/\/www.facebook.com\/codefresh.io\" \/>\n<meta property=\"article:published_time\" content=\"2020-03-05T09:56:41+00:00\" \/>\n<meta property=\"article:modified_time\" content=\"2020-03-26T12:35:12+00:00\" \/>\n<meta property=\"og:image\" content=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/03\/blog-image.png\" \/>\n\t<meta property=\"og:image:width\" content=\"800\" \/>\n\t<meta property=\"og:image:height\" content=\"311\" \/>\n\t<meta property=\"og:image:type\" content=\"image\/png\" \/>\n<meta name=\"twitter:card\" content=\"summary_large_image\" \/>\n<meta name=\"twitter:creator\" content=\"@codefresh\" \/>\n<meta name=\"twitter:site\" content=\"@codefresh\" \/>\n<meta name=\"twitter:label1\" content=\"Written by\" \/>\n\t<meta name=\"twitter:data1\" content=\"Contributor\" \/>\n\t<meta name=\"twitter:label2\" content=\"Est. reading time\" \/>\n\t<meta name=\"twitter:data2\" content=\"7 minutes\" \/>\n<script type=\"application\/ld+json\" class=\"yoast-schema-graph\">{\"@context\":\"https:\/\/schema.org\",\"@graph\":[{\"@type\":\"Organization\",\"@id\":\"https:\/\/codefresh.io\/#organization\",\"name\":\"Codefresh\",\"url\":\"https:\/\/codefresh.io\/\",\"sameAs\":[\"https:\/\/www.facebook.com\/codefresh.io\",\"https:\/\/www.linkedin.com\/company\/codefresh\",\"https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg\",\"https:\/\/twitter.com\/codefresh\"],\"logo\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#logo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"width\":800,\"height\":800,\"caption\":\"Codefresh\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/#logo\"}},{\"@type\":\"WebSite\",\"@id\":\"https:\/\/codefresh.io\/#website\",\"url\":\"https:\/\/codefresh.io\/\",\"name\":\"Codefresh\",\"description\":\"\",\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"potentialAction\":[{\"@type\":\"SearchAction\",\"target\":{\"@type\":\"EntryPoint\",\"urlTemplate\":\"https:\/\/codefresh.io\/?s={search_term_string}\"},\"query-input\":\"required name=search_term_string\"}],\"inLanguage\":\"en-US\"},{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/create-docker-images-for-java\/#primaryimage\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/03\/blog-image.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/03\/blog-image.png\",\"width\":800,\"height\":311},{\"@type\":\"WebPage\",\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/create-docker-images-for-java\/#webpage\",\"url\":\"https:\/\/codefresh.io\/docker-tutorial\/create-docker-images-for-java\/\",\"name\":\"Three Ways to Create Docker Images for Java | Codefresh\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/#website\"},\"primaryImageOfPage\":{\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/create-docker-images-for-java\/#primaryimage\"},\"datePublished\":\"2020-03-05T09:56:41+00:00\",\"dateModified\":\"2020-03-26T12:35:12+00:00\",\"breadcrumb\":{\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/create-docker-images-for-java\/#breadcrumb\"},\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"ReadAction\",\"target\":[\"https:\/\/codefresh.io\/docker-tutorial\/create-docker-images-for-java\/\"]}]},{\"@type\":\"BreadcrumbList\",\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/create-docker-images-for-java\/#breadcrumb\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"name\":\"Home\",\"item\":\"https:\/\/codefresh.io\/\"},{\"@type\":\"ListItem\",\"position\":2,\"name\":\"Three Ways to Create Docker Images for Java\"}]},{\"@type\":\"Article\",\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/create-docker-images-for-java\/#article\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/create-docker-images-for-java\/#webpage\"},\"author\":{\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/268e5c2e4740502fae6d803783a16c75\"},\"headline\":\"Three Ways to Create Docker Images for Java\",\"datePublished\":\"2020-03-05T09:56:41+00:00\",\"dateModified\":\"2020-03-26T12:35:12+00:00\",\"mainEntityOfPage\":{\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/create-docker-images-for-java\/#webpage\"},\"wordCount\":1075,\"commentCount\":16,\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/create-docker-images-for-java\/#primaryimage\"},\"thumbnailUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/03\/blog-image.png\",\"keywords\":[\"docker\",\"Containers\",\"CI\/CD\",\"java\",\"maven\"],\"articleSection\":[\"Docker Tutorials\",\"Containers\",\"How Tos\"],\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"CommentAction\",\"name\":\"Comment\",\"target\":[\"https:\/\/codefresh.io\/docker-tutorial\/create-docker-images-for-java\/#respond\"]}]},{\"@type\":\"Person\",\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/268e5c2e4740502fae6d803783a16c75\",\"name\":\"Contributor\",\"image\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#personlogo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/secure.gravatar.com\/avatar\/26bd6dd87bf70f0c1a44721c8b3abbbd?s=96&d=blank&r=g\",\"contentUrl\":\"https:\/\/secure.gravatar.com\/avatar\/26bd6dd87bf70f0c1a44721c8b3abbbd?s=96&d=blank&r=g\",\"caption\":\"Contributor\"},\"url\":\"https:\/\/codefresh.io\/author\/contributor\/\"}]}<\/script>\n<!-- \/ Yoast SEO Premium plugin. -->","yoast_head_json":{"title":"Three Ways to Create Docker Images for Java | Codefresh","robots":{"index":"index","follow":"follow","max-snippet":"max-snippet:-1","max-image-preview":"max-image-preview:large","max-video-preview":"max-video-preview:-1"},"canonical":"https:\/\/codefresh.io\/docker-tutorial\/create-docker-images-for-java\/","og_locale":"en_US","og_type":"article","og_title":"Three Ways to Create Docker Images for Java","og_description":"Long before Dockerfiles, Java developers worked with single deployment units (WARs, JARs, EARs, etc.). As you likely know by now, it is best practice to work in micro-services, deploying a small number of deployment units per JVM. Instead of one giant, monolithic application, you build your application such that each service can run on its &hellip; Read more","og_url":"https:\/\/codefresh.io\/docker-tutorial\/create-docker-images-for-java\/","og_site_name":"Codefresh","article_publisher":"https:\/\/www.facebook.com\/codefresh.io","article_published_time":"2020-03-05T09:56:41+00:00","article_modified_time":"2020-03-26T12:35:12+00:00","og_image":[{"width":800,"height":311,"url":"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/03\/blog-image.png","type":"image\/png"}],"twitter_card":"summary_large_image","twitter_creator":"@codefresh","twitter_site":"@codefresh","twitter_misc":{"Written by":"Contributor","Est. reading time":"7 minutes"},"schema":{"@context":"https:\/\/schema.org","@graph":[{"@type":"Organization","@id":"https:\/\/codefresh.io\/#organization","name":"Codefresh","url":"https:\/\/codefresh.io\/","sameAs":["https:\/\/www.facebook.com\/codefresh.io","https:\/\/www.linkedin.com\/company\/codefresh","https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg","https:\/\/twitter.com\/codefresh"],"logo":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#logo","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","width":800,"height":800,"caption":"Codefresh"},"image":{"@id":"https:\/\/codefresh.io\/#logo"}},{"@type":"WebSite","@id":"https:\/\/codefresh.io\/#website","url":"https:\/\/codefresh.io\/","name":"Codefresh","description":"","publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"potentialAction":[{"@type":"SearchAction","target":{"@type":"EntryPoint","urlTemplate":"https:\/\/codefresh.io\/?s={search_term_string}"},"query-input":"required name=search_term_string"}],"inLanguage":"en-US"},{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/docker-tutorial\/create-docker-images-for-java\/#primaryimage","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/03\/blog-image.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/03\/blog-image.png","width":800,"height":311},{"@type":"WebPage","@id":"https:\/\/codefresh.io\/docker-tutorial\/create-docker-images-for-java\/#webpage","url":"https:\/\/codefresh.io\/docker-tutorial\/create-docker-images-for-java\/","name":"Three Ways to Create Docker Images for Java | Codefresh","isPartOf":{"@id":"https:\/\/codefresh.io\/#website"},"primaryImageOfPage":{"@id":"https:\/\/codefresh.io\/docker-tutorial\/create-docker-images-for-java\/#primaryimage"},"datePublished":"2020-03-05T09:56:41+00:00","dateModified":"2020-03-26T12:35:12+00:00","breadcrumb":{"@id":"https:\/\/codefresh.io\/docker-tutorial\/create-docker-images-for-java\/#breadcrumb"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https:\/\/codefresh.io\/docker-tutorial\/create-docker-images-for-java\/"]}]},{"@type":"BreadcrumbList","@id":"https:\/\/codefresh.io\/docker-tutorial\/create-docker-images-for-java\/#breadcrumb","itemListElement":[{"@type":"ListItem","position":1,"name":"Home","item":"https:\/\/codefresh.io\/"},{"@type":"ListItem","position":2,"name":"Three Ways to Create Docker Images for Java"}]},{"@type":"Article","@id":"https:\/\/codefresh.io\/docker-tutorial\/create-docker-images-for-java\/#article","isPartOf":{"@id":"https:\/\/codefresh.io\/docker-tutorial\/create-docker-images-for-java\/#webpage"},"author":{"@id":"https:\/\/codefresh.io\/#\/schema\/person\/268e5c2e4740502fae6d803783a16c75"},"headline":"Three Ways to Create Docker Images for Java","datePublished":"2020-03-05T09:56:41+00:00","dateModified":"2020-03-26T12:35:12+00:00","mainEntityOfPage":{"@id":"https:\/\/codefresh.io\/docker-tutorial\/create-docker-images-for-java\/#webpage"},"wordCount":1075,"commentCount":16,"publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"image":{"@id":"https:\/\/codefresh.io\/docker-tutorial\/create-docker-images-for-java\/#primaryimage"},"thumbnailUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/03\/blog-image.png","keywords":["docker","Containers","CI\/CD","java","maven"],"articleSection":["Docker Tutorials","Containers","How Tos"],"inLanguage":"en-US","potentialAction":[{"@type":"CommentAction","name":"Comment","target":["https:\/\/codefresh.io\/docker-tutorial\/create-docker-images-for-java\/#respond"]}]},{"@type":"Person","@id":"https:\/\/codefresh.io\/#\/schema\/person\/268e5c2e4740502fae6d803783a16c75","name":"Contributor","image":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#personlogo","inLanguage":"en-US","url":"https:\/\/secure.gravatar.com\/avatar\/26bd6dd87bf70f0c1a44721c8b3abbbd?s=96&d=blank&r=g","contentUrl":"https:\/\/secure.gravatar.com\/avatar\/26bd6dd87bf70f0c1a44721c8b3abbbd?s=96&d=blank&r=g","caption":"Contributor"},"url":"https:\/\/codefresh.io\/author\/contributor\/"}]}},"acf":[],"_links":{"self":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/15230"}],"collection":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/users\/125"}],"replies":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/comments?post=15230"}],"version-history":[{"count":0,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/15230\/revisions"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media\/15231"}],"wp:attachment":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media?parent=15230"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/categories?post=15230"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/tags?post=15230"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}