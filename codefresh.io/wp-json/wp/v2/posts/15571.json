{"id":15571,"date":"2020-05-06T07:30:41","date_gmt":"2020-05-06T15:30:41","guid":{"rendered":"http:\/\/codefresh.io\/?p=15571"},"modified":"2020-06-19T05:52:46","modified_gmt":"2020-06-19T13:52:46","slug":"okteto","status":"publish","type":"post","link":"https:\/\/codefresh.io\/kubernetes-tutorial\/okteto\/","title":{"rendered":"Local Kubernetes Development with Okteto"},"content":{"rendered":"<p>At Codefresh we understand how much Kubernetes has changed the local flow for developers and we have already covered not only local Kubernetes distributions for <a href=\"https:\/\/codefresh.io\/kubernetes-tutorial\/local-kubernetes-mac-minikube-vs-docker-desktop\/\">Mac<\/a>, <a href=\"https:\/\/codefresh.io\/howtos\/local-kubernetes-windows-minikube-vs-docker-desktop\/\">Windows <\/a>and <a href=\"https:\/\/codefresh.io\/kubernetes-tutorial\/local-kubernetes-linux-minikube-vs-microk8s\/\">Linux<\/a>, but also specialized tools such <a href=\"https:\/\/codefresh.io\/howtos\/local-k8s-draft-skaffold-garden\/\">draft, skaffold, garden.io<\/a> and <a href=\"https:\/\/codefresh.io\/kubernetes-tutorial\/local-kubernetes-development-tilt-dev\/\">tilt.dev<\/a> that are focused on developers who work with Kubernetes.<\/p>\n<p>This time we will look at <a href=\"https:\/\/okteto.com\/\">Okteto<\/a>, a brand new tool that aims to make developers more productive when using Kubernetes.<\/p>\n<p>If you are already familiar with most tools in this space you can think of Okteto as the union of different ideas from <a href=\"https:\/\/skaffold.dev\/\">Skaffold <\/a>and <a href=\"https:\/\/www.telepresence.io\/\">telepresence <\/a>while also putting into the mix a developer Docker registry, a remote build service,  an easy way to deploy docker images without manifests and much more.<\/p>\n<h2>The traditional way of developing applications locally<\/h2>\n<p>Before Kubernetes (and microservices), setting up a development environment was most times a straightforward process. A developer would install their favorite IDE (such as Intellij, or Visual studio code) along with the runtime of their favorite programming language (e..g. Java, Python, Ruby etc).<\/p>\n<figure id=\"attachment_15575\" aria-describedby=\"caption-attachment-15575\" style=\"width: 408px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/05\/before.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/05\/before.png\" alt=\"\" width=\"408\" height=\"312\" class=\"size-full wp-image-15575\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/05\/before.png 408w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/05\/before-300x229.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/05\/before-20x15.png 20w\" sizes=\"(max-width: 408px) 100vw, 408px\" \/><\/a><figcaption id=\"caption-attachment-15575\" class=\"wp-caption-text\">Before Kubernetes<\/figcaption><\/figure>\n<p>This made the basic development cycle very simple as one could make some changes within the source code and see the effect right away.<\/p>\n<p>Developers that used dynamic\/scripted languages also enjoyed the benefit of instant feedback as there was no intermediate compilation step needed compared to compiled languages.<\/p>\n<p>This application workflow is the ideal for developers as:<\/p>\n<ul>\n<li>Setting up the development environment is easy<\/li>\n<li>Changes to source code can be evaluated in a matter of seconds<\/li>\n<li>The application runs locally on the laptop\/workstation so no network resources are needed<\/li>\n<li>Testing, profiling, debugging and other associated developer activities also take place in the same environment with the native tools of the platform.<\/li>\n<\/ul>\n<p>Now, of course even if this is the best case scenario, in real life there are some more concerns here such as choosing the correct version of the dev environment (e.g. JDK, Node.js\/NPM) and in some cases an intermediate runtime (such as an application server in the case of Java or PHP), but in general, developers were happy with the feedback loop they gained with this approach.<\/p>\n<p>Remember also that we are talking about local development <strong>BEFORE <\/strong>a commit takes place (i.e. while the developer is still implementing the features). Once a commit happens, the CI\/CD system takes over and performs all the required verification actions, a process that might take some extra minutes.<\/p>\n<p>But for the basic cycle of code-> test-> run developers are accustomed to  spend only some seconds during the implementation phase of a feature (before the CI\/CD process).<\/p>\n<h2>Developing locally in the era of Kubernetes<\/h2>\n<p>With the emergence of Kubernetes as the defacto clustering standard, and the rise of microservices as the preferred software architecture all software teams had to change their workflows and habits.<\/p>\n<p>In the case of developers, the complexity of setting a local development environment greatly increased, as two more layers (Docker and Kubernetes) were now added into the mix.<\/p>\n<figure id=\"attachment_15576\" aria-describedby=\"caption-attachment-15576\" style=\"width: 980px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/05\/microservices.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/05\/microservices.png\" alt=\"\" width=\"980\" height=\"713\" class=\"size-full wp-image-15576\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/05\/microservices.png 980w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/05\/microservices-300x218.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/05\/microservices-768x559.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/05\/microservices-20x15.png 20w\" sizes=\"(max-width: 980px) 100vw, 980px\" \/><\/a><figcaption id=\"caption-attachment-15576\" class=\"wp-caption-text\">Microservice complexity<\/figcaption><\/figure>\n<p>The addition of Docker and Kubernetes not only makes deploying the application more complex, but also hinders local development in the worst possible ways:<\/p>\n<ul>\n<li>All native hot-reload and auto-refresh tools cannot be used anymore since the code is now in a docker image<\/li>\n<li>Incremental compilation and cache reuse is now a non-trivial task<\/li>\n<li>Debugging, tracing\/logging and testing tools are no longer available as code is not running on its own anymore and ports are redirected\/masked inside Kubernetes services<\/li>\n<li>All developer tools that are based on SSH functionality are no longer applicable as Kubernetes deployments are based on Docker images instead of VMs<\/li>\n<\/ul>\n<p>Any development team that adopts containers and Kubernetes typically resorts to the following 3 approaches for local development:<\/p>\n<ol>\n<li>Use Docker and Docker-compose locally<\/li>\n<li>Use Docker and a local Kubernetes cluster such as minikube, microk8s, etc.<\/li>\n<li>\nUse Docker locally and a remote Kubernetes cluster for developers.<\/li>\n<\/ol>\n<p>Let\u2019s examine these approaches in turn.<\/p>\n<h2>Using Docker-compose<\/h2>\n<p>Docker compose was originally conceived as a tool specifically for local development with containers. The idea is simple. It allows you to launch one or more containers locally with their own network and \u201cmimic\u201d how an application would look like in Kubernetes.<\/p>\n<p>The simplicity of Docker compose is one of its major strengths. Only Docker needs to be installed on the workstation and nothing else. It is also a great way to reuse the native hot-reload tools of your programming language as with the proper use of volumes these fast-reload mechanisms are still possible.<\/p>\n<p>The big problem of course is that running Docker compose is nothing like a Kubernetes cluster. Just because your application works on Docker compose, doesn\u2019t mean it will also work on the production Kubernetes cluster. This just converts the problem of \u201cworks on my machine\u201d to \u201cworks on my Docker compose installation\u201d.<\/p>\n<p>In summary the pros of Docker compose are:<\/p>\n<ul>\n<li>Very simple installation and management<\/li>\n<li>Docker compose is fairly easy to understand if you already have Docker knowledge<\/li>\n<li>Volumes can help with all the hot-reload tools and mechanisms<\/li>\n<li>You can use the same IDE and tools for local development as before<\/li>\n<li>If your laptop has enough capacity you can run the full application locally without any extra network resources<\/li>\n<\/ul>\n<p>The disadvantages are:<\/p>\n<ul>\n<li>Running an application in Docker compose is not the same as running it in a Kubernetes cluster<\/li>\n<li>Specialized resources (e.g. GPU nodes) are not available locally<\/li>\n<li>Kubernetes APIs are not available locally<\/li>\n<li>Extra infrastructure (e.g. configmaps and secrets) is not available<\/li>\n<li>You need to handle two different sets of manifest (for Kubernetes and for Docker compose) and keep them in sync<\/li>\n<\/ul>\n<p>The first disadvantage is essentially a big blocker when it comes to local development. Several production issues are caused because of differences between the production and staging environments. Using Docker compose for development and Kubernetes for production deployments is the embodiment of disparity between development and production.<\/p>\n<p>Trying to use docker-compose to mimic a Kubernetes environment is a losing battle. There are valid cases for Docker-compose as far as developers are concerned, but using it as the sole development tool is not advised for any non-trivial microservice application.<\/p>\n<h2>Using a local Kubernetes cluster<\/h2>\n<p>The second approach is to launch a local Kubernetes cluster on your laptop. This is the natural response of developers as this is what we have already been doing with traditional applications. If for example an application is destined to be deployed on a Java application server or Apache httpd, developers would install the same thing locally (making sure that the exact same version is used).<\/p>\n<figure id=\"attachment_15578\" aria-describedby=\"caption-attachment-15578\" style=\"width: 406px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/05\/after.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/05\/after.png\" alt=\"\" width=\"406\" height=\"412\" class=\"size-full wp-image-15578\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/05\/after.png 406w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/05\/after-296x300.png 296w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/05\/after-85x85.png 85w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/05\/after-20x20.png 20w\" sizes=\"(max-width: 406px) 100vw, 406px\" \/><\/a><figcaption id=\"caption-attachment-15578\" class=\"wp-caption-text\">Development with local Kubernetes cluster<\/figcaption><\/figure>\n<p>Following a similar approach with Kubernetes is much more complex though. The biggest problem here is that while there are several local Kubernetes distributions to choose from, getting an application deployed to a cluster is a non-trivial process.<\/p>\n<p>All the stages of the basic developer cycle of code->build->test are now completely broken:<\/p>\n<figure id=\"attachment_15579\" aria-describedby=\"caption-attachment-15579\" style=\"width: 772px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/05\/broken-cycle.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/05\/broken-cycle.png\" alt=\"\" width=\"772\" height=\"487\" class=\"size-full wp-image-15579\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/05\/broken-cycle.png 772w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/05\/broken-cycle-300x189.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/05\/broken-cycle-768x484.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/05\/broken-cycle-20x13.png 20w\" sizes=\"(max-width: 772px) 100vw, 772px\" \/><\/a><figcaption id=\"caption-attachment-15579\" class=\"wp-caption-text\">Long feedback cycle<\/figcaption><\/figure>\n<p>Stages shown in red, not only take time to finish (often minutes), but also are completely unrelated to the daily workflow of a developer, adding no extra value to feature development.<\/p>\n<p>Seeing the result of your changes is now a lengthy process and what used to take seconds now takes minutes. And while a local Kubernetes distribution does not require as much knowledge as a production instance, developers are still forced to learn about Kubernetes concepts (such as deployments and services) which are completely unneeded for their main goal (which is to write code and deliver features).<\/p>\n<p>Testing and debugging is also a much more complex process and special tools need to be used in order to access the Kubernetes cluster.<\/p>\n<p>In summary, using a local Kubernetes cluster is great for gaining Kubernetes knowledge, but there are much better solutions for developers as we will see with Okteto in the next sections.<\/p>\n<p>The advantages of using a local cluster are:<\/p>\n<ul>\n<li>The development environment is now much closer to production<\/li>\n<li>Kubernetes API and services (e.g. config-maps) are available<\/li>\n<li>No network resources are needed if the whole application can run on the laptop<\/li>\n<\/ul>\n<p>The disadvantages are:<\/p>\n<ul>\n<li>The main feedback loop is unnecessarily long<\/li>\n<li>Specialized resources (e.g. GPU nodes) are not available locally<\/li>\n<li>Launching the whole application might be impossible because of resource consumption<\/li>\n<li>Developers are forced to learn about Kubernetes managements and APIs<\/li>\n<li>Debugging\/testing tools and other IDE facilities cannot be used<\/li>\n<li>Hot-reload of code is not available<\/li>\n<li>The local cluster is still not the same as the production one<\/li>\n<li>The local cluster will still need support from the Operator\/IT team. Running a local Kubernetes cluster will still require some setup and maintenance.<\/li>\n<\/ul>\n<p>It is important to note that some tools (such as Skaffold and Draft) can help with the feedback loop, but some major disadvantages such as the resource consumption and the disparity between production and development still persist.<\/p>\n<h2>Using a Remote Kubernetes cluster<\/h2>\n<p>The third approach is to use a remote cluster which is very close to production (or even the same one as production)<\/p>\n<p>While this approach sounds very good in theory, in practice, the tools that make it work efficiently have only recently appeared (garden.io, tilt.dev and okteto).<\/p>\n<p>The advantages of using a remote cluster are:<\/p>\n<ul>\n<li>The development environment is the same as production<\/li>\n<li>Kubernetes APIs and services are available<\/li>\n<li>Specialized resources (e.g. GPU nodes) are available<\/li>\n<li>The whole application can be run on the cluster regardless of local resource on your laptop<\/li>\n<li>All developers use the exact same development environment which is completely unrelated to the OS of each laptop. <\/li>\n<\/ul>\n<p>The disadvantages are mostly the same as the ones mentioned in the previous section regarding local clusters. The big blocker is the long feedback loop and lack of support for hot-reloads and special IDE\/debug facilities.<\/p>\n<p>The importance of developing in an environment as close to production cannot be overstated. This advantage is so beneficial that until recently overshadowed everything else and makes the experience of developers really cumbersome when trying to use remote clusters.<br \/>\nAnother big benefit is that you are reducing the configuration surface of the developer&#8217;s machine. Less stuff to install and keep updated, less software to maintain, and less things to onboard when a new person joins a team.<\/p>\n<p>Okteto also follows this approach and is designed specifically for enabling development and their teams to operate efficiently with the remote cluster model.<\/p>\n<h2>How Okteto works<\/h2>\n<p>Now that we have seen all the issues with Kubernetes development, let\u2019s see how Okteto solves them.<\/p>\n<p>The <a href=\"https:\/\/github.com\/okteto\/okteto\">Okteto CLI<\/a> is open source and packaged as a single executable that works in the same manner for Mac, Windows, Linux. All the magic happens when you run <a href=\"https:\/\/okteto.com\/docs\/reference\/cli#up\">\u201cokteto up\u201d<\/a> inside the folder of your source code.<\/p>\n<figure id=\"attachment_15580\" aria-describedby=\"caption-attachment-15580\" style=\"width: 794px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/05\/okteto-up.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/05\/okteto-up.png\" alt=\"The Okteto workflow\" width=\"794\" height=\"365\" class=\"size-full wp-image-15580\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/05\/okteto-up.png 794w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/05\/okteto-up-300x138.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/05\/okteto-up-768x353.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/05\/okteto-up-20x9.png 20w\" sizes=\"(max-width: 794px) 100vw, 794px\" \/><\/a><figcaption id=\"caption-attachment-15580\" class=\"wp-caption-text\">The Okteto workflow<\/figcaption><\/figure>\n<p>Once you run this command okteto does the following:<\/p>\n<ol>\n<li>Connects to your remote cluster<\/li>\n<li>Goes to the deployment that has your application and changes the docker image with a different one that contains your development environment (e.g. maven and jdk, or npm, python, ruby etc) along with all your test tools (and optionally visual studio code integrations)<\/li>\n<li>Setups port-forwarding in both directions both for your app and for your debugging tools <\/li>\n<li>Setups automatic file synchronization in both directions so that everything you do locally is passed to the cluster and vice versa.<\/li>\n<li>Setups a tiny SSH server in the pod to make it easy to work with SSH based tools (i.e. remote workspaces in Visual studio Code)<\/li>\n<\/ol>\n<p>The end result if the remote cluster is seen by your IDE and tools as a local filesystem\/environment. You edit your code normally on your workstation and as soon as you save a file, the change goes to the remote cluster and your app instantly updates (taking advantage of any hot-reload mechanism you already have). This whole process happens in an instant. No docker images need to be created any more and no Kubernetes manifests need to be applied to the cluster. All that is taken care of by okteto.<\/p>\n<figure id=\"attachment_15581\" aria-describedby=\"caption-attachment-15581\" style=\"width: 1024px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/05\/ide.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/05\/ide-1024x552.png\" alt=\"Developing with Okteto\" width=\"1024\" height=\"552\" class=\"size-large wp-image-15581\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/05\/ide-1024x552.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/05\/ide-300x162.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/05\/ide-768x414.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/05\/ide-1536x828.png 1536w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/05\/ide-20x11.png 20w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/05\/ide.png 1921w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" \/><\/a><figcaption id=\"caption-attachment-15581\" class=\"wp-caption-text\">Developing with Okteto<\/figcaption><\/figure>\n<p>At the same time, if you want to view what your application is doing you can simply go to http:\/\/localhost:8080 (or any other port that you normally use) and it will just work. Behind the scenes okteto will forward your traffic to the actual Kubernetes cluster and the correct port of the docker container that has your application environment.<\/p>\n<p>This means that debugging with okteto is trivial. You simply use your local IDE and connect to your \u201clocal\u201d port that you already use for debugging purposes.<\/p>\n<p>It is important to notice that other than the CLI, okteto doesn\u2019t have any other dependencies on your local workstation. You don\u2019t need to have Docker or Kubernetes installed on your laptop. You don\u2019t even need a runtime (e.g. JDK, npm, python etc) on your laptop as well. All the programming tools are in the Docker image deployed on the cluster.<\/p>\n<p>The exact image that you use for development (along with other options such as what port to forward) are defined in a <a href=\"https:\/\/okteto.com\/docs\/reference\/manifest\">very simple yaml file called okteto.yml<\/a> which is located in your source folder. You don\u2019t need to create this file from scratch as the command \u201cokteto init\u201d will create one for you (and it will even try to autodetect your programming language).<\/p>\n<p>Okteto has great documentation and you can also find specific guides for your favorite programming language such <a href=\"https:\/\/okteto.com\/docs\/samples\/java\/index.html\">Java<\/a>, <a href=\"https:\/\/okteto.com\/docs\/samples\/node\/index.html\">Node<\/a>, <a href=\"https:\/\/okteto.com\/docs\/samples\/python\/index.html\">Python<\/a>, <a href=\"https:\/\/okteto.com\/docs\/samples\/ruby\">Ruby <\/a>etc.<\/p>\n<h2>Okteto cloud and other features<\/h2>\n<p>Using Okteto for local development is also possible even if you don\u2019t have your own cluster. Okteto Cloud is a SAAS version of a Kubernetes hosted service with some extra features such as<\/p>\n<ul>\n<li>Your own namespaces to be used for different applications<\/li>\n<li>A remote Docker build service<\/li>\n<li>A Docker registry<\/li>\n<li>Automatic SSL endpoints for your deployments<\/li>\n<li>A dashboard to inspect to inspect your Kubernetes cluster in a way <a href=\"https:\/\/okteto.com\/blog\/developer-first-experiences\/\">that is useful for developers<\/a><\/li>\n<li>A catalog of applications in the form of Helm charts (and the ability to add your own charts)<\/li>\n<\/ul>\n<figure id=\"attachment_15583\" aria-describedby=\"caption-attachment-15583\" style=\"width: 1024px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/05\/okteto-cloud.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/05\/okteto-cloud-1024x588.png\" alt=\"Okteto Cloud dashboard\" width=\"1024\" height=\"588\" class=\"size-large wp-image-15583\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/05\/okteto-cloud-1024x588.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/05\/okteto-cloud-300x172.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/05\/okteto-cloud-768x441.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/05\/okteto-cloud-20x11.png 20w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/05\/okteto-cloud.png 1404w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" \/><\/a><figcaption id=\"caption-attachment-15583\" class=\"wp-caption-text\">Okteto Cloud dashboard<\/figcaption><\/figure>\n<p>There is also a hosted version &#8211; <a href=\"https:\/\/okteto.com\/enterprise\/\">Okteto enterprise<\/a> that companies can use on their own premises instead of Okteto Cloud. However note that the Okteto CLI works with the standard Kubernetes API and is fully open source, so you can use it on your own cluster without any restrictions.<\/p>\n<p>The main goal of the Okteto team is to completely abstract Kubernetes as far as development is concerned. Developers should not have to deal with Kubernetes manifests or have deep cluster knowledge when they just want to write code and implement features.<\/p>\n<p>To this purpose, Okteto has several other complementary features for easy local development. First of all the Docker registry of Okteto can be used by the okteto CLI without actually installing Docker on your local machine. With just the okteto CLI you can build and push an image to the Okteto registry providing only a Dockerfile. You can also automatically build and update and existing deployment without the need for Kubernetes manifests.<\/p>\n<p>Okteto has also recently released initial support for <a href=\"https:\/\/okteto.com\/docs\/cloud\/stacks\/index.html\">stacks<\/a>. Okteto stacks are yaml definitions that sit between simple docker compose files and Kubernetes manifests. They allow developers to define dependencies of applications, but without the full complexity of Kubernetes manifests.<\/p>\n<h2>Conclusion<\/h2>\n<p>Okteto is a tool designed specifically for developers who want to work with Kubernetes but without actually being Kubernetes experts. It removes all the friction of developing for containers and Kubernetes without limiting their power.With okteto<\/p>\n<ul>\n<li>You don\u2019t need Docker or Kubernetes installed on your laptop anymore<\/li>\n<li>You don\u2019t need to build docker images and create deployments any time you make a source code change<\/li>\n<li>You still use your favorite IDE and debugging\/testing tools that you are accustomed to.<\/li>\n<li>You can still use incremental builds and hot-reloads as supported by your programming language.<\/li>\n<li>A remote Kubernetes clusters can be used as a \u201clocal\u201d filesystem\/environment on your workstation<\/li>\n<li>\nYou solve the \u201cworks on my machine\u201d problem as your application is developed inside the cluster it is destined to be deployed<\/li>\n<li>You can take advantage of all Kubernetes features and special resources (e.g. GPU nodes) for your application without any extra complexity.<\/li>\n<\/ul>\n<p>For similar tools see our <a href=\"https:\/\/codefresh.io\/howtos\/local-k8s-draft-skaffold-garden\/\">skaffold\/garden article<\/a> as well as <a href=\"https:\/\/codefresh.io\/kubernetes-tutorial\/local-kubernetes-development-tilt-dev\/\">tilt.dev<\/a>.<\/p>\n<input class=\"fooboxshare_post_id\" type=\"hidden\" value=\"15571\"\/>","protected":false},"excerpt":{"rendered":"<p>At Codefresh we understand how much Kubernetes has changed the local flow for developers and we have already covered not only local Kubernetes distributions for Mac, Windows and Linux, but also specialized tools such draft, skaffold, garden.io and tilt.dev that are focused on developers who work with Kubernetes. This time we will look at Okteto, &hellip; <a href=\"https:\/\/codefresh.io\/kubernetes-tutorial\/okteto\/\">Read more<\/a><\/p>\n","protected":false},"author":62,"featured_media":15572,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[3120,1657,1505,1538],"tags":[14,24,44,52,64,5114],"yoast_head":"<!-- This site is optimized with the Yoast SEO Premium plugin v17.9 (Yoast SEO v18.4.1) - https:\/\/yoast.com\/wordpress\/plugins\/seo\/ -->\n<title>Local Kubernetes Development with Okteto | Codefresh<\/title>\n<meta name=\"robots\" content=\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\" \/>\n<link rel=\"canonical\" href=\"https:\/\/codefresh.io\/kubernetes-tutorial\/okteto\/\" \/>\n<meta property=\"og:locale\" content=\"en_US\" \/>\n<meta property=\"og:type\" content=\"article\" \/>\n<meta property=\"og:title\" content=\"Local Kubernetes Development with Okteto\" \/>\n<meta property=\"og:description\" content=\"At Codefresh we understand how much Kubernetes has changed the local flow for developers and we have already covered not only local Kubernetes distributions for Mac, Windows and Linux, but also specialized tools such draft, skaffold, garden.io and tilt.dev that are focused on developers who work with Kubernetes. This time we will look at Okteto, &hellip; Read more\" \/>\n<meta property=\"og:url\" content=\"https:\/\/codefresh.io\/kubernetes-tutorial\/okteto\/\" \/>\n<meta property=\"og:site_name\" content=\"Codefresh\" \/>\n<meta property=\"article:publisher\" content=\"https:\/\/www.facebook.com\/codefresh.io\" \/>\n<meta property=\"article:published_time\" content=\"2020-05-06T15:30:41+00:00\" \/>\n<meta property=\"article:modified_time\" content=\"2020-06-19T13:52:46+00:00\" \/>\n<meta property=\"og:image\" content=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/05\/okteto-blog-image.png\" \/>\n\t<meta property=\"og:image:width\" content=\"1024\" \/>\n\t<meta property=\"og:image:height\" content=\"269\" \/>\n\t<meta property=\"og:image:type\" content=\"image\/png\" \/>\n<meta name=\"twitter:card\" content=\"summary_large_image\" \/>\n<meta name=\"twitter:creator\" content=\"@codefresh\" \/>\n<meta name=\"twitter:site\" content=\"@codefresh\" \/>\n<meta name=\"twitter:label1\" content=\"Written by\" \/>\n\t<meta name=\"twitter:data1\" content=\"Kostis Kapelonis\" \/>\n\t<meta name=\"twitter:label2\" content=\"Est. reading time\" \/>\n\t<meta name=\"twitter:data2\" content=\"14 minutes\" \/>\n<script type=\"application\/ld+json\" class=\"yoast-schema-graph\">{\"@context\":\"https:\/\/schema.org\",\"@graph\":[{\"@type\":\"Organization\",\"@id\":\"https:\/\/codefresh.io\/#organization\",\"name\":\"Codefresh\",\"url\":\"https:\/\/codefresh.io\/\",\"sameAs\":[\"https:\/\/www.facebook.com\/codefresh.io\",\"https:\/\/www.linkedin.com\/company\/codefresh\",\"https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg\",\"https:\/\/twitter.com\/codefresh\"],\"logo\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#logo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"width\":800,\"height\":800,\"caption\":\"Codefresh\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/#logo\"}},{\"@type\":\"WebSite\",\"@id\":\"https:\/\/codefresh.io\/#website\",\"url\":\"https:\/\/codefresh.io\/\",\"name\":\"Codefresh\",\"description\":\"\",\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"potentialAction\":[{\"@type\":\"SearchAction\",\"target\":{\"@type\":\"EntryPoint\",\"urlTemplate\":\"https:\/\/codefresh.io\/?s={search_term_string}\"},\"query-input\":\"required name=search_term_string\"}],\"inLanguage\":\"en-US\"},{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/okteto\/#primaryimage\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/05\/okteto-blog-image.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/05\/okteto-blog-image.png\",\"width\":1024,\"height\":269},{\"@type\":\"WebPage\",\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/okteto\/#webpage\",\"url\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/okteto\/\",\"name\":\"Local Kubernetes Development with Okteto | Codefresh\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/#website\"},\"primaryImageOfPage\":{\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/okteto\/#primaryimage\"},\"datePublished\":\"2020-05-06T15:30:41+00:00\",\"dateModified\":\"2020-06-19T13:52:46+00:00\",\"breadcrumb\":{\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/okteto\/#breadcrumb\"},\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"ReadAction\",\"target\":[\"https:\/\/codefresh.io\/kubernetes-tutorial\/okteto\/\"]}]},{\"@type\":\"BreadcrumbList\",\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/okteto\/#breadcrumb\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"name\":\"Home\",\"item\":\"https:\/\/codefresh.io\/\"},{\"@type\":\"ListItem\",\"position\":2,\"name\":\"Local Kubernetes Development with Okteto\"}]},{\"@type\":\"Article\",\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/okteto\/#article\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/okteto\/#webpage\"},\"author\":{\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87\"},\"headline\":\"Local Kubernetes Development with Okteto\",\"datePublished\":\"2020-05-06T15:30:41+00:00\",\"dateModified\":\"2020-06-19T13:52:46+00:00\",\"mainEntityOfPage\":{\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/okteto\/#webpage\"},\"wordCount\":2782,\"commentCount\":0,\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/okteto\/#primaryimage\"},\"thumbnailUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/05\/okteto-blog-image.png\",\"keywords\":[\"docker\",\"Containers\",\"Kubernetes\",\"devops\",\"microservices\",\"developers\"],\"articleSection\":[\"Continuous Deployment\/Delivery\",\"Kubernetes Tutorials\",\"Containers\",\"DevOps Tutorials\"],\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"CommentAction\",\"name\":\"Comment\",\"target\":[\"https:\/\/codefresh.io\/kubernetes-tutorial\/okteto\/#respond\"]}]},{\"@type\":\"Person\",\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87\",\"name\":\"Kostis Kapelonis\",\"image\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#personlogo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png\",\"caption\":\"Kostis Kapelonis\"},\"description\":\"Kostis is a software engineer\/technical-writer dual class character. He lives and breathes automation, good testing practices and stress-free deployments with GitOps.\",\"url\":\"https:\/\/codefresh.io\/author\/kostiscodefresh-io\/\"}]}<\/script>\n<!-- \/ Yoast SEO Premium plugin. -->","yoast_head_json":{"title":"Local Kubernetes Development with Okteto | Codefresh","robots":{"index":"index","follow":"follow","max-snippet":"max-snippet:-1","max-image-preview":"max-image-preview:large","max-video-preview":"max-video-preview:-1"},"canonical":"https:\/\/codefresh.io\/kubernetes-tutorial\/okteto\/","og_locale":"en_US","og_type":"article","og_title":"Local Kubernetes Development with Okteto","og_description":"At Codefresh we understand how much Kubernetes has changed the local flow for developers and we have already covered not only local Kubernetes distributions for Mac, Windows and Linux, but also specialized tools such draft, skaffold, garden.io and tilt.dev that are focused on developers who work with Kubernetes. This time we will look at Okteto, &hellip; Read more","og_url":"https:\/\/codefresh.io\/kubernetes-tutorial\/okteto\/","og_site_name":"Codefresh","article_publisher":"https:\/\/www.facebook.com\/codefresh.io","article_published_time":"2020-05-06T15:30:41+00:00","article_modified_time":"2020-06-19T13:52:46+00:00","og_image":[{"width":1024,"height":269,"url":"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/05\/okteto-blog-image.png","type":"image\/png"}],"twitter_card":"summary_large_image","twitter_creator":"@codefresh","twitter_site":"@codefresh","twitter_misc":{"Written by":"Kostis Kapelonis","Est. reading time":"14 minutes"},"schema":{"@context":"https:\/\/schema.org","@graph":[{"@type":"Organization","@id":"https:\/\/codefresh.io\/#organization","name":"Codefresh","url":"https:\/\/codefresh.io\/","sameAs":["https:\/\/www.facebook.com\/codefresh.io","https:\/\/www.linkedin.com\/company\/codefresh","https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg","https:\/\/twitter.com\/codefresh"],"logo":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#logo","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","width":800,"height":800,"caption":"Codefresh"},"image":{"@id":"https:\/\/codefresh.io\/#logo"}},{"@type":"WebSite","@id":"https:\/\/codefresh.io\/#website","url":"https:\/\/codefresh.io\/","name":"Codefresh","description":"","publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"potentialAction":[{"@type":"SearchAction","target":{"@type":"EntryPoint","urlTemplate":"https:\/\/codefresh.io\/?s={search_term_string}"},"query-input":"required name=search_term_string"}],"inLanguage":"en-US"},{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/okteto\/#primaryimage","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/05\/okteto-blog-image.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/05\/okteto-blog-image.png","width":1024,"height":269},{"@type":"WebPage","@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/okteto\/#webpage","url":"https:\/\/codefresh.io\/kubernetes-tutorial\/okteto\/","name":"Local Kubernetes Development with Okteto | Codefresh","isPartOf":{"@id":"https:\/\/codefresh.io\/#website"},"primaryImageOfPage":{"@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/okteto\/#primaryimage"},"datePublished":"2020-05-06T15:30:41+00:00","dateModified":"2020-06-19T13:52:46+00:00","breadcrumb":{"@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/okteto\/#breadcrumb"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https:\/\/codefresh.io\/kubernetes-tutorial\/okteto\/"]}]},{"@type":"BreadcrumbList","@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/okteto\/#breadcrumb","itemListElement":[{"@type":"ListItem","position":1,"name":"Home","item":"https:\/\/codefresh.io\/"},{"@type":"ListItem","position":2,"name":"Local Kubernetes Development with Okteto"}]},{"@type":"Article","@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/okteto\/#article","isPartOf":{"@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/okteto\/#webpage"},"author":{"@id":"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87"},"headline":"Local Kubernetes Development with Okteto","datePublished":"2020-05-06T15:30:41+00:00","dateModified":"2020-06-19T13:52:46+00:00","mainEntityOfPage":{"@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/okteto\/#webpage"},"wordCount":2782,"commentCount":0,"publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"image":{"@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/okteto\/#primaryimage"},"thumbnailUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/05\/okteto-blog-image.png","keywords":["docker","Containers","Kubernetes","devops","microservices","developers"],"articleSection":["Continuous Deployment\/Delivery","Kubernetes Tutorials","Containers","DevOps Tutorials"],"inLanguage":"en-US","potentialAction":[{"@type":"CommentAction","name":"Comment","target":["https:\/\/codefresh.io\/kubernetes-tutorial\/okteto\/#respond"]}]},{"@type":"Person","@id":"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87","name":"Kostis Kapelonis","image":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#personlogo","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png","caption":"Kostis Kapelonis"},"description":"Kostis is a software engineer\/technical-writer dual class character. He lives and breathes automation, good testing practices and stress-free deployments with GitOps.","url":"https:\/\/codefresh.io\/author\/kostiscodefresh-io\/"}]}},"acf":[],"_links":{"self":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/15571"}],"collection":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/users\/62"}],"replies":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/comments?post=15571"}],"version-history":[{"count":0,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/15571\/revisions"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media\/15572"}],"wp:attachment":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media?parent=15571"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/categories?post=15571"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/tags?post=15571"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}