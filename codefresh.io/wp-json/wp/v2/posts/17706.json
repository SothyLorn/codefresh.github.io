{"id":17706,"date":"2020-10-28T03:21:56","date_gmt":"2020-10-28T11:21:56","guid":{"rendered":"https:\/\/codefresh.io\/?p=17706"},"modified":"2020-11-05T06:07:12","modified_gmt":"2020-11-05T14:07:12","slug":"samurais-not-use-uis-using-cli-configure-codefresh-create-manage-kubernetes-pipelines","status":"publish","type":"post","link":"https:\/\/codefresh.io\/devops-tutorial\/samurais-not-use-uis-using-cli-configure-codefresh-create-manage-kubernetes-pipelines\/","title":{"rendered":"Samurais Do NOT Use UIs: Using CLI To Configure Codefresh And Create And Manage Kubernetes Pipelines"},"content":{"rendered":"<p>Are you a ninja?<\/p>\n<p>It&#8217;s a silly question. I know that you are most likely not a real ninja. But you might be considering yourself a ninja of software engineering. &#8220;What does Viktor mean by that?&#8221; I&#8217;m glad you asked.<\/p>\n<p>Ninjas appear, perform the mission, and disappear without leaving a trace behind.<\/p>\n<p>&#8220;Why is Viktor talking nonsense? What does that have to do with software engineering?&#8221; Again, I&#8217;m glad you asked.<\/p>\n<p>Software engineers that use UIs to perform actions act in the same way as ninjas. They tend to fill in some fields and click some buttons until they accomplish their goals. They do what needs to be done and leave no trace behind them. They come when we least expect them and disappear as soon when their job is done. Those are the same traits as those exhibit by ninjas. But there is a different breed of engineers.<\/p>\n<p>Some are team players, and some are not. Team players will always work in a way that their teammates can get insight into their knowledge, can reproduce their work, review it before going live, and provide feedback. Those are people who share their expertise through code stored in Git. They enable others to reproduce their work by creating scripts, code, declarative definitions, etc. They are documenting everything in the form of code and READMEs. They make pull requests and ask for feedback, enabling others to gain insight into their work.<\/p>\n<p>Now, to be fair, it is possible to document the steps from a UI, and it is possible to share that with others. It is possible, but not likely to happen. It is unrealistic for someone to document every step performed through a UI. It is impractical to wait for feedback until a button is pressed. It is impossible to expect that others will be able to reproduce every single step from a document based on actions in a UI. That&#8217;s open to interpretation. It is slow. Above all, it is done by humans who are incapable of doing the same thing over and over again.<\/p>\n<p>So, we have &#8220;real&#8221; team players writing code and scripts, creating pull requests, and expecting feedback. Then there are people who are mostly focused on doing things in isolation by clicking buttons in some UI. The former are team players, while the latter are ninjas. They work alone, and they leave no trace behind.<\/p>\n<p>However, we do not need ninjas. We need samurais. They fight as a team.<\/p>\n<p>UIs are great as a learning experience, but using them is slow, prone to errors, hard to reproduce, and results in hard-to-document processes. Writing code and scripts to accomplish the same results is a sign of maturity and experience. It is proof that we are capable of working in a team while also being an expert.<\/p>\n<p><em>I must admit that I exaggerated. There is value in UIs as well as in running commands and defining everything as code. Experts are often mixing all those methods. We at Codefresh believe that the best way to accomplish the goals is to combine all those. That&#8217;s why we built an awesome UI, but also why we believe that APIs, CLIs, and everything-can-be-defined-as-code are just as important. Nevertheless, today I&#8217;ll try to go into the extreme by showing you how to operate everything through CLI and declarative definitions stored in Git.<\/em><\/p>\n<p>That&#8217;s enough of an introduction into something that is not really related to ninjas or samurais. Our goal today is to accomplish through code and commands things that most people do through UIs. We are about to create, manage, and monitor a Codefresh pipeline and everything else we might need without opening the UI.<\/p>\n<p>How does that sound? Are you ready to become a samurai?<\/p>\n<h2>Discussing The Plan<\/h2>\n<p>The only thing I will assume you prepared in advance is a Kubernetes cluster. Create one if you haven&#8217;t already. You can use whichever process you are already using to create a cluster, or you might want to reuse an existing one if you already have it. You might even want to go through the &#8220;Applying GitOps And Continuous Delivery (CD) On Infrastructure Using Terraform And Codefresh&#8221; articles published separately for <a href=\"https:\/\/codefresh.io\/continuous-deployment\/applying-gitops-continuous-delivery-cd-infrastructure-using-terraform-codefresh-aws-elastic-kubernetes-service-eks\/\">AWS EKS<\/a>, <a href=\"https:\/\/codefresh.io\/kubernetes-tutorial\/applying-gitops-continuous-delivery-cd-infrastructure-using-terraform-codefresh-azure-kubernetes-service-aks\/\">Azure AKS<\/a>, or <a href=\"https:\/\/codefresh.io\/continuous-deployment\/applying-gitops-continuous-delivery-cd-infrastructure-using-terraform-codefresh-google-kubernetes-engine-gke\/\">Google Cloud GKE<\/a>.<\/p>\n<p>Ultimately, it does not matter how you created a Kubernetes cluster or what type it is, as long as you are aware of a few potential issues. To begin with, I tested all the examples using GKE, EKS, and AKS. They should work in any other Kubernetes platform, but I cannot guarantee that there isn&#8217;t a thing or two you&#8217;ll need to change in the examples that follow. Also, Codefresh needs to be able to access your cluster, so those running locally and without a public IP like, for example, Docker Desktop or Minikube, are out of the game.<\/p>\n<p>That&#8217;s it. That&#8217;s all I expect you to prepare in advance. Create a Kubernetes cluster, and make sure that Kube config is pointing to it.<\/p>\n<p>Before we create a pipeline, we need to have quite a few things. To begin with, we need to install <code>codefresh<\/code> CLI and authenticate it. We need a Git repository where we will store the resources we need to define. We will also need to create a Kubernetes ServiceAccount that will allow Codefresh to perform specific actions. For all that to make sense, we will need to tell Codefresh how to connect to the cluster.<\/p>\n<p>We will also need to provide info on connecting to our Git repository so that Codefresh can create a webhook that will notify it whenever we push a change. It will also need to pull specific commits and use them as the source code required by some of the pipeline steps.<\/p>\n<p>Finally, we&#8217;ll need to create a Codefresh project inside which the pipeline will reside.<\/p>\n<p>I probably forgot to mention a thing or two. We&#8217;ll figure out what we&#8217;re missing once we start doing whatever we need to do.<\/p>\n<p>What matters is that we will be able to create the pipeline only once we handle all the prerequisites.<\/p>\n<p>Does that make sense? Do we have a plan in place?<\/p>\n<p>I&#8217;ll assume that you&#8217;re nodding in agreement, so let&#8217;s get going.<\/p>\n<h2>Installing The <code>codefresh<\/code> CLI And Getting The Code<\/h2>\n<p>To begin with, we will need Codefresh CLI.<\/p>\n<p>If you are already using <a href=\"https:\/\/codefresh.io\/codefresh-signup\/?utm_source=Blog&amp;utm_medium=Post&amp;utm_campaign=vfarcic-cli\">codefresh.io<\/a>, you might be used to doing everything through the UI. Not today. We&#8217;ll use the CLI for all the operations we&#8217;ll need to do in Codefresh. You will not see the UI today.<\/p>\n<p>Please follow the instructions in the <a href=\"https:\/\/codefresh-io.github.io\/cli\/installation\/\">Codefresh CLI Installation<\/a> page. Once the CLI is installed, you should authenticate it. You&#8217;ll need an API key for that. If you do not have it already, go to the <a href=\"https:\/\/g.codefresh.io\/user\/settings\">User Settings<\/a> page and click the <em>GENERATE<\/em> button inside the <em>API Keys<\/em> section. Type <em>devops-catalog<\/em> as the <em>KEY NAME<\/em>, select the <em>SCOPES<\/em> checkbox, and click the <em>CREATE<\/em> button. Make sure to copy it by clicking the <em>Copy token to clipboard<\/em> link below the <em>API KEY<\/em> field.<\/p>\n<p><em>All the commands are available in the <a href=\"https:\/\/gist.github.com\/8719daeb09034dd4dfbeccd73fa8e301\">pipeline-cli.sh<\/a> Gist. Feel free to use it if you&#8217;re too lazy to type. There&#8217;s no shame in copy &amp; paste.<\/em><\/p>\n<p>Execute the command that follows once you have the token.<\/p>\n<p><em>Please replace <code>[...]<\/code> with the token you just copied to the clipboard.<\/em><\/p>\n<pre><code class=\"bash\"># Replace `[...]` with the token\ncodefresh auth \\\n    create-context devops-catalog \\\n    --api-key [...]\n<\/code><\/pre>\n<p><em>If you are a Windows user, I will assume that you are running the commands from a Bourne Again Shell (Bash) or a Z Shell (Zsh) and not PowerShell. That should not be a problem if you followed the instructions on setting up Windows Subsystem for Linux (WSL) explained in the <a href=\"https:\/\/youtu.be\/zSqugKeOa1Y\">Installing Windows Subsystem For Linux (WSL)<\/a> YouTube video. If you do not like WSL, a Bash emulator like GitBash should do. If none of those is an acceptable option, you might need to modify some of the commands in the examples that follow.<\/em><\/p>\n<p>Next, we should generate the definitions of the resources we need to create. But, given that I&#8217;m a good guy, I&#8217;ll save you from typing by letting you fork a repo I created. It contains everything we need.<\/p>\n<p>Let&#8217;s open it.<\/p>\n<p><em>If you do not have the <code>open<\/code> command (or the alias), you should replace <code>open<\/code> with <code>echo<\/code> and copy and paste the output into your favorite browser.<\/em><\/p>\n<pre><code class=\"bash\">open https:\/\/github.com\/vfarcic\/codefresh-cli-examples\n<\/code><\/pre>\n<p>Next, you will need to fork the repo. We&#8217;ll soon make some changes to the code, and you wouldn&#8217;t be able to push them to my repo. So, it needs to be yours.<\/p>\n<p><em>If you do not know how to fork a GitHub repo, the only thing I can say is &#8220;shame on you&#8221;. Google how to do that. I will not spend time explaining that.<\/em><\/p>\n<p>Next, we&#8217;ll clone the newly forked repository.<\/p>\n<p><em>Please replace <code>[...]<\/code> with your GitHub organization in the command that follows. If you forked the repo into your personal account, then the organization is your GitHub username.<\/em><\/p>\n<pre><code class=\"bash\"># Replace `[...]` with the GitHub organization\nexport GH_ORG=[...]\n\ngit clone \\\n    https:\/\/github.com\/$GH_ORG\/codefresh-cli-examples.git\n\ncd codefresh-cli-examples\n<\/code><\/pre>\n<p>Now we are ready to set up all the prerequisites.<\/p>\n<h2>Setting Up The Kubernetes Prerequisites<\/h2>\n<p>The first thing we need to do is provide sufficient permissions for Codefresh to be able to perform actions in your Kubernetes cluster. We need a ServiceAccount, bound to a role with the permissions, which we&#8217;ll store in the <code>codefresh<\/code> Namespace. Let&#8217;s take a look at an example.<\/p>\n<pre><code class=\"bash\">cat create-cluster.yaml\n<\/code><\/pre>\n<p>The output is as follows<\/p>\n<pre><code class=\"yaml\">---\n\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: codefresh\n\n---\n\nkind: ClusterRole\napiVersion: rbac.authorization.k8s.io\/v1\nmetadata:\n  name: codefresh\nrules:\n  - apiGroups: [ \"*\"]\n    resources: [\"*\"]\n    verbs: [\"get\", \"list\", \"watch\", \"create\", \"update\", \"patch\", \"delete\"]\n\n---\n\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: codefresh\n  namespace: codefresh\n\n---\n\napiVersion: rbac.authorization.k8s.io\/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: codefresh\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: codefresh\nsubjects:\n- kind: ServiceAccount\n  name: codefresh\n  namespace: codefresh\n<\/code><\/pre>\n<p>There is nothing special about that definition. Assuming that you have a basic understanding of Kubernetes, you should be able to figure out what is what. The only note worth mentioning is that we might be a bit too generous with the <code>rule<\/code> in the <code>ClusterRole<\/code>. You might want to be less permissive and limit further what Codefresh can do. But, for our examples, being generous might not be a bad thing.<\/p>\n<p>Let&#8217;s apply those resources.<\/p>\n<pre><code class=\"bash\">kubectl apply \\\n    --filename create-cluster.yaml\n<\/code><\/pre>\n<p>Now that we have the ServiceAccount with the permissions that restrict what can and what cannot be done inside the cluster, we can let Codefresh know how to connect to our cluster.<\/p>\n<h2>Adding Kubernetes Config<\/h2>\n<p>Next, we need to &#8220;create a cluster&#8221; in Codefresh. That&#8217;s a bit misleading name for what we&#8217;ll do. We are not really going to create a cluster. Instead, we will use the <code>create cluster<\/code> command to provide Codefresh with the information on connecting to your cluster.<\/p>\n<p><em>Before we proceed, I must warn you that there is a potential complication if you&#8217;re using <strong>Amazon Elastic Kubernetes Service (EKS)<\/strong>. Codefresh does not allow &#8220;special&#8221; characters in the name of the cluster. On the other hand, when you add EKS cluster to Kube config, the name is typically something like <code>arn:aws:eks:us-east-1:336151728602:cluster\/devops-catalog<\/code>. If that&#8217;s your case, please create a new Kube config context using the <code>--alias<\/code> argument to specify a non-default name. A command would be something like <code>aws eks update-kubeconfig ... --alias devops-catalog<\/code>. In other words, create Kube config like you usually do with <code>aws<\/code> CLI, but make sure that you add <code>--alias<\/code>. If you are unsure that the current name is, please output Kube config with <code>kubectl config view<\/code>.<\/em><\/p>\n<p>Adding Kubernetes config to Codefresh is easy. All we have to do is specify the ServiceAccount, the Namespace where it&#8217;s located, and the Kube context we want to pass to Codefresh. We have all but the context, so let&#8217;s retrieve it.<\/p>\n<pre><code class=\"bash\">export CURRENT_CONTEXT=$(\\\n    kubectl config current-context)\n<\/code><\/pre>\n<p>All that&#8217;s left is execute <code>codefresh create cluster<\/code>.<\/p>\n<pre><code class=\"bash\">codefresh create cluster \\\n    --kube-context $CURRENT_CONTEXT \\\n    --serviceaccount codefresh \\\n    --namespace codefresh\n<\/code><\/pre>\n<p>You should see the output message stating that the <code>Kubernetes context<\/code> was <code>added to Codefresh<\/code>. From now on, it should know how to connect to our cluster. Given that it uses a specific ServiceAccount, it is limited to whichever permissions we assigned it.<\/p>\n<p>If we are unsure whether the cluster config was indeed added, we can always retrieve them all.<\/p>\n<pre><code class=\"bash\">codefresh get clusters\n<\/code><\/pre>\n<p>The output, in my case, is as follows.<\/p>\n<pre><code>ID                       NAME          \n5f6b9a60e8d0861f02196a64 devops-catalog\n<\/code><\/pre>\n<p>The ability to connect to the cluster is not enough. We must also allow it to perform certain actions related to our Git provider of choice.<\/p>\n<h2>Adding Git Context<\/h2>\n<p>I am assuming that your Git provider is not open to everyone. You almost certainly restricted who can pull repos, who can push changes, who can create webhooks, and so on. Even open-source projects do not use the do-whatever-you-want model. There are always some restrictions.<\/p>\n<p>So, our next step is to create a token that will be specific to Codefresh and through which we can decide what it can and what it cannot do. From the Codefresh perspective, we need to add a Git context. But, before we do that, let&#8217;s see which ones we already have.<\/p>\n<pre><code class=\"bash\">codefresh get contexts\n<\/code><\/pre>\n<p>The output, in my case, is as follows.<\/p>\n<pre><code class=\"bash\">NAME            TYPE           \nCF_HELM_DEFAULT helm-repository\n<\/code><\/pre>\n<p>The only context I have is the one that comes out of the box and allows my pipelines to use Codefresh default Helm repository. We&#8217;ll ignore that one.<\/p>\n<p>In your case, there might already be a <code>git.github<\/code> context. You could use it if its already set up. However, the goal is to show how to do everything from scratch using CLI, so we&#8217;ll ignore whichever contexts you might already have.<\/p>\n<p>The first thing we need to do is generate a GitHub token.<\/p>\n<p><em>I&#8217;m using GitHub for the examples, and you should do the same, for now. Later on, you should be able to modify the examples to use whichever other Git provider you might be using. Codefresh currently supports *BitBucket<\/em>, <em>GitHub<\/em>, <em>GitLab<\/em>, and <em>Stash<\/em>, at least when operated through the CLI.*<\/p>\n<p>Let&#8217;s go to the GitHub&#8217;s <em>Personal access tokens<\/em> page.<\/p>\n<pre><code class=\"bash\">open https:\/\/github.com\/settings\/tokens\n<\/code><\/pre>\n<p>Please click the <em>Generate new token<\/em> button.<\/p>\n<p>Type <em>codefresh<\/em> in the <em>Note<\/em> field, and select all the checkboxes.<\/p>\n<p><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/10\/github-token-1024x637.png\" alt=\"\" width=\"1024\" height=\"637\" class=\"aligncenter size-large wp-image-17710\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/10\/github-token-1024x637.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/10\/github-token-300x186.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/10\/github-token-768x477.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/10\/github-token-1536x955.png 1536w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/10\/github-token-2048x1273.png 2048w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/10\/github-token-20x12.png 20w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" \/><\/p>\n<p><em>You should be much more restrictive than allowing Codefresh full access to your repos. Still, for the purpose of the exercises, we will go all in and save ourselves from a potentially lengthy discussion about the relationship between specific permissions and actions they might enable.<\/em><\/p>\n<p>Click the <em>Generate token<\/em> button, and make sure that you do NOT close the screen.<\/p>\n<p>This is the first and the last time you will ever see the token. Assuming that you do not have a photographic memory, we&#8217;ll need to store it somewhere. Today, that somewhere will be an environment variable and a file.<\/p>\n<p><em>Please replace <code>[...]<\/code> with the newly created token in the commands that follow.<\/em><\/p>\n<pre><code class=\"bash\">export GH_TOKEN=[...]\n\necho \"export GH_TOKEN=$GH_TOKEN\" \\\n    | tee env\n<\/code><\/pre>\n<p>Now you have the token stored locally in the <code>env<\/code> file. You should be able to retrieve it whenever you need it, either by outputting that file or executing <code>source env<\/code>. The latter will export the <code>GH_TOKEN<\/code> variable.<\/p>\n<p>Before you freak out, thinking that I just exposed you to the risk of accidentally pushing the token to GitHub, let me assure you that it will not happen.<\/p>\n<pre><code class=\"bash\">cat .gitignore\n<\/code><\/pre>\n<p>The output is as follows.<\/p>\n<pre><code>\/env\n<\/code><\/pre>\n<p>The <code>env<\/code> file is in <code>.gitignore<\/code>, so you are safe from accidents that happened to many before you.<\/p>\n<p>Now we are ready to create a <code>git<\/code> context that will enable Codefresh to work with your Git repositories.<\/p>\n<pre><code class=\"bash\">codefresh create context \\\n    git github devops-catalog \\\n    --access-token $GH_TOKEN\n<\/code><\/pre>\n<p>To be on the safe side, we&#8217;ll output all the contexts and confirm that the newly created one is indeed there.<\/p>\n<pre><code class=\"bash\">codefresh get contexts\n<\/code><\/pre>\n<p>The output is as follows.<\/p>\n<pre><code>NAME            TYPE           \nCF_HELM_DEFAULT helm-repository\ndevops-catalog  git.github\n<\/code><\/pre>\n<p>We are almost done with the prerequisites. Before we dive into the &#8220;real&#8221; goal, the only thing missing is to create a project where our pipelines will reside.<\/p>\n<h2>Creating A Project<\/h2>\n<p>Creating a project is the easiest and the most straightforward thing we&#8217;ll do today. Now, to be fair, everything else was easy as well. The complication was that we needed additional info like Kube config or GitHub access token. A project does not require any of those. We just need to tell Codefresh what the name of the project is.<\/p>\n<pre><code class=\"bash\">codefresh create project devops-catalog\n<\/code><\/pre>\n<p>The project was created, or maybe it wasn&#8217;t. It really depends on whether you already had a project with that name or not. If you did, you can ignore the <code>Project already exists: \"devops-catalog\"<\/code> error message, and move on.<\/p>\n<p>To be on the safe side, we&#8217;ll list all the projects and confirm that the one we created is indeed there.<\/p>\n<pre><code class=\"bash\">codefresh get projects\n<\/code><\/pre>\n<p>The output is as follows.<\/p>\n<pre><code>NAME           PIPELINES LAST_UPDATED TAGS                \ndevops-catalog 0         2020-09-23   \n<\/code><\/pre>\n<p>That&#8217;s it. Now we are ready to do what we are set to do. Now we can create a pipeline.<\/p>\n<h2>Creating A Pipeline<\/h2>\n<p>The goal is to create a pipeline that will demonstrate that we can use the resources we created. To be more specific, we&#8217;ll create a pipeline that will clone the code, use a particular Kube context, and retrieve all the Namespaces. That should prove that the Kube config and the GitHub token we added work as expected. Also, we&#8217;ll create a pipeline in the <code>devops-catalog<\/code> project to confirm that works as well. Finally, we&#8217;ll push a change to the git repo as a way to validate that Codefresh was capable of using the GitHub token to create a webhook.<\/p>\n<p>How does that sound?<\/p>\n<p>I&#8217;ll assume that the answer is &#8220;Great. Let&#8217;s do it!&#8221;, so we&#8217;ll move on.<\/p>\n<p>The goal is not to teach you how to write Codefresh pipelines or to walk you through everything we can do inside them. That would take too much time and is out of the scope of this article. So, I already prepared a sample one we can use. However, since I might have experimented with <code>codefresh.yml<\/code> at the root of this repo, first, we&#8217;ll copy the &#8220;golden&#8221; version from the <code>orig<\/code> directory.<\/p>\n<pre><code class=\"bash\">cp orig\/codefresh.yml .\n<\/code><\/pre>\n<p>Let&#8217;s see what we got.<\/p>\n<pre><code class=\"bash\">cat codefresh.yml\n<\/code><\/pre>\n<p>The output is as follows.<\/p>\n<pre><code class=\"yaml\">version: \"1.0\"\nkind: pipeline\nmetadata:\n  name: devops-catalog\/codefresh-cli\n  description: Argo CD production environment app\n  project: devops-catalog\nspec:\n  triggers:\n  - type: git\n    provider: github\n    name: main\n    repo: vfarcic\/codefresh-cli-examples\n    events:\n    - push\n    branchRegex: \/master\/gi\n    verified: true\n  contexts: []\n  steps:\n    main_clone:\n      title: Cloning main repository\n      type: git-clone\n      repo: '${{CF_REPO_OWNER}}\/${{CF_REPO_NAME}}'\n      revision: '${{CF_REVISION}}'\n      git: devops-catalog\n    apply_env:\n      title: Applying production environment\n      image: codefresh\/kubectl\n      commands:\n      - kubectl config use-context my-cluster\n      - kubectl get namespaces\n  stages: []\n<\/code><\/pre>\n<p>As I already mentioned, this is not a deep dive into Codefresh pipelines, so I will not explain in detail every single line of that file. Besides, you should be able to deduce what it does, even if you do not have prior experience.<\/p>\n<p>What matters is that we are using the <code>main_clone<\/code> step to get the code. Inside it, there is the instruction <code>git: devops-catalog<\/code> that tells Codefresh to use that specific Git context. That&#8217;s the one we created earlier.<\/p>\n<p>In the <code>apply_env<\/code> step, we set the current Kubernetes context to <code>my-cluster<\/code> and using the <code>kubectl get namespaces<\/code> command.<\/p>\n<p>The <code>use-context<\/code> command is a standard one, yet it might require a bit of explanation.<\/p>\n<p>Pipelines contain the collection of all Kube contexts we add through <code>codefresh create cluster<\/code> commands. Right now, we have only one, but there could be others. As such, it is essential to always choose which context should be used.<\/p>\n<p>You probably noticed that the pipeline is using the context <code>my-cluster<\/code>. That is probably not your context. I could not know in advance which one it will be, so I hard-coded it in the pipeline as a place-holder. Let&#8217;s change it to whichever context you are using through a bit of &#8220;<code>sed<\/code> magic&#8221;.<\/p>\n<pre><code class=\"bash\">cat codefresh.yml \\\n    | sed -e \"s@my-cluster@$CURRENT_CONTEXT@g\" \\\n    | tee codefresh.yml\n<\/code><\/pre>\n<p>That&#8217;s it. Our pipeline is ready, and all that&#8217;s left is to tell Codefresh to use it.<\/p>\n<pre><code class=\"bash\">codefresh create pipeline \\\n    -f codefresh.yml\n<\/code><\/pre>\n<p>You probably already noticed that I have a paranoid nature and want to double-check everything. This is not an exception, so we&#8217;ll check whether the pipeline was created.<\/p>\n<pre><code class=\"bash\">codefresh get pipelines\n<\/code><\/pre>\n<p>The output, in my case, is as follows.<\/p>\n<pre><code>NAME                         UPDATED           CREATED          \ndevops-catalog\/codefresh-cli a few seconds ago a few seconds ago\n<\/code><\/pre>\n<p>Let&#8217;s see whether we can run the newly created pipeline.<\/p>\n<h2>Running Pipeline Builds And Observing Logs<\/h2>\n<p>One obvious way to run a pipeline build is to execute it manually. We could do that through the UI or through the <code>codefresh run<\/code> command. But, more often than not, neither options are desirable.<\/p>\n<p>We should run pipeline builds as reactions to changes to our Git repository. The most common way to do that is through Git webhooks notifying Codefresh that there are changes in the source code.<\/p>\n<p>Codefresh should have created a Webhook that will trigger whenever we push changes to that repo. We could validate that by going to the repo&#8217;s webhooks screen, but we won&#8217;t. A better test is to push a change to the repo. If that triggers a pipeline build, we can rest assured that the webhook was indeed created and works correctly.<\/p>\n<pre><code class=\"bash\">git add .\n\ngit commit -m \"Adding app of apps\"\n\ngit push\n<\/code><\/pre>\n<p>Let&#8217;s see whether a new pipeline build was created due to pushing a change to the repo.<\/p>\n<pre><code class=\"bash\">codefresh get builds \\\n    --pipeline-name codefresh-cli\n<\/code><\/pre>\n<p>The output is as follows.<\/p>\n<pre><code>ID     PIPELINE-NAME     STATUS  CREATED       STARTED FINISHED TOTALTIME TRIGGER WEBHOOK REPOSITORY        BRANCH\n5f6... ...\/codefresh-cli delayed 2020-09-25...                  00:00:16  main    true    ...\/codefresh-cli master\n<\/code><\/pre>\n<p>There should be a single build for the <code>codefresh-cli<\/code> pipeline. Copy the ID. We&#8217;ll need it soon.<\/p>\n<p>Finally, sometimes, especially when builds fail, we might want to look at the logs. We can do that through CLI as well.<\/p>\n<p><em>Please replace <code>[...]<\/code> with the token you just copied to the clipboard.<\/em><\/p>\n<pre><code class=\"bash\">export BUILD_ID=[...] # e.g., `5f6e10b5c343f14d8b37fd19`\n\ncodefresh logs $BUILD_ID -f\n<\/code><\/pre>\n<p>The output, limited to the last entries, is as follows.<\/p>\n<pre><code>...\nExecuting command: kubectl get namespaces\nNAME              STATUS   AGE\nargocd            Active   12m\ncodefresh         Active   7m43s\ndefault           Active   17m\ningress-nginx     Active   13m\nkube-node-lease   Active   17m\nkube-public       Active   17m\nkube-system       Active   17m\nSuccessfully ran freestyle step: Applying production environment\nReading environment variable exporting file contents.\nReading environment variable exporting file contents.\n<\/code><\/pre>\n<p>We can see that the last step did indeed retrieve all the Namespaces in the cluster. That alone should confirm that we can communicate with the Kubernetes cluster from Codefresh pipelines.<\/p>\n<p>That&#8217;s it. We&#8217;re finished, and all that&#8217;s left is to cover our tracks.<\/p>\n<h2>Destroying What We Created<\/h2>\n<p>This will be the final test. If you pass it, you will become a samurai.<\/p>\n<p>We are about to remove any trace of what we did. We will cover our tracks so that no one can see what we did. We&#8217;ll remove any trace of our activities.<\/p>\n<p>Typically, we would not want to &#8220;hide&#8221; our work. That would be against teamwork and knowledge sharing. But this is only a practice that is not supposed to live longer than needed. We should always clean the mess after we&#8217;re finished playing. That is, at least, what I&#8217;m telling my daughter. I&#8217;m not very successful with her, but I hope you might be more open to my suggestions.<\/p>\n<p>First, we&#8217;ll remove the cluster from Codefresh records.<\/p>\n<pre><code class=\"bash\">codefresh delete cluster $CURRENT_CONTEXT\n<\/code><\/pre>\n<p>Next, we&#8217;ll remove the GitHub context.<\/p>\n<pre><code class=\"bash\">codefresh delete context devops-catalog\n<\/code><\/pre>\n<p>Finally, we&#8217;ll delete the pipeline.<\/p>\n<pre><code class=\"bash\">codefresh delete pipeline \\\n    devops-catalog\/codefresh-cli\n<\/code><\/pre>\n<p>We&#8217;ll even go out of the local copy of the repo and get back to where we started.<\/p>\n<pre><code class=\"bash\">cd ..\n<\/code><\/pre>\n<p>The only thing left untouched is your cluster. You created it without my help, so I&#8217;ll assume that you know how to destroy it. Do it. Remove it from the face of the earth.<\/p>\n<p>Now we are finished. We accomplished a set of tasks, and we removed any trace of our activities. We did all that through a terminal session without using Codefresh UI even once (excluding the creation of the API token).<\/p>\n<p>Congratulations. You graduated. You are a samurai now. Now you live in a two-dimensional monochromatic world of terminals.<\/p>\n<h2>UIs Are Not Evil<\/h2>\n<p>I was probably too harsh. UIs are useful, depending on the use case. There is no easier way to learn something than by exploring the options available in UIs. That&#8217;s how one finds out all the available possibilities a product offers. More importantly, UIs are great for getting insights. If we want to visualize our pipelines, we can do it through Codefresh UI. If we want to gain insights into the relation between commits, releases, JIRA tickets, and deployments, Codefresh UI is probably the best place. There are many other reasons for using UIs, but not today. The focus of this article was on the CLI.<\/p>\n<p>The point I&#8217;m trying to make, probably by going to extremes, is that there are use-cases when working from a terminal is the best choice and those when UIs are a more natural destination. Knowing how to use both allows us to pick the right tool for the job.<\/p>\n<p>Today, we explored Codefresh CLI. We&#8217;ll go through the UI some other time. Until then, I encourage you to explore it on your own. You can read the documents, but that is often not needed. It is intuitive, and it allows us to get emersed into all the possibilities Codefresh offers without a steep learning curve.<\/p>\n<input class=\"fooboxshare_post_id\" type=\"hidden\" value=\"17706\"\/>","protected":false},"excerpt":{"rendered":"<p>Are you a ninja? It&#8217;s a silly question. I know that you are most likely not a real ninja. But you might be considering yourself a ninja of software engineering. &#8220;What does Viktor mean by that?&#8221; I&#8217;m glad you asked. Ninjas appear, perform the mission, and disappear without leaving a trace behind. &#8220;Why is Viktor &hellip; <a href=\"https:\/\/codefresh.io\/devops-tutorial\/samurais-not-use-uis-using-cli-configure-codefresh-create-manage-kubernetes-pipelines\/\">Read more<\/a><\/p>\n","protected":false},"author":125,"featured_media":17788,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[3120,5467,1543,1538],"tags":[],"yoast_head":"<!-- This site is optimized with the Yoast SEO Premium plugin v17.9 (Yoast SEO v18.4.1) - https:\/\/yoast.com\/wordpress\/plugins\/seo\/ -->\n<title>Samurais Do NOT Use UIs: Using CLI To Configure Codefresh And Create And Manage Kubernetes Pipelines | Codefresh<\/title>\n<meta name=\"robots\" content=\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\" \/>\n<link rel=\"canonical\" href=\"https:\/\/codefresh.io\/devops-tutorial\/samurais-not-use-uis-using-cli-configure-codefresh-create-manage-kubernetes-pipelines\/\" \/>\n<meta property=\"og:locale\" content=\"en_US\" \/>\n<meta property=\"og:type\" content=\"article\" \/>\n<meta property=\"og:title\" content=\"Samurais Do NOT Use UIs: Using CLI To Configure Codefresh And Create And Manage Kubernetes Pipelines\" \/>\n<meta property=\"og:description\" content=\"Are you a ninja? It&#8217;s a silly question. I know that you are most likely not a real ninja. But you might be considering yourself a ninja of software engineering. &#8220;What does Viktor mean by that?&#8221; I&#8217;m glad you asked. Ninjas appear, perform the mission, and disappear without leaving a trace behind. &#8220;Why is Viktor &hellip; Read more\" \/>\n<meta property=\"og:url\" content=\"https:\/\/codefresh.io\/devops-tutorial\/samurais-not-use-uis-using-cli-configure-codefresh-create-manage-kubernetes-pipelines\/\" \/>\n<meta property=\"og:site_name\" content=\"Codefresh\" \/>\n<meta property=\"article:publisher\" content=\"https:\/\/www.facebook.com\/codefresh.io\" \/>\n<meta property=\"article:published_time\" content=\"2020-10-28T11:21:56+00:00\" \/>\n<meta property=\"article:modified_time\" content=\"2020-11-05T14:07:12+00:00\" \/>\n<meta property=\"og:image\" content=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/10\/samurais-do-not-use-uis.png\" \/>\n\t<meta property=\"og:image:width\" content=\"1492\" \/>\n\t<meta property=\"og:image:height\" content=\"496\" \/>\n\t<meta property=\"og:image:type\" content=\"image\/png\" \/>\n<meta name=\"twitter:card\" content=\"summary_large_image\" \/>\n<meta name=\"twitter:creator\" content=\"@codefresh\" \/>\n<meta name=\"twitter:site\" content=\"@codefresh\" \/>\n<meta name=\"twitter:label1\" content=\"Written by\" \/>\n\t<meta name=\"twitter:data1\" content=\"Contributor\" \/>\n\t<meta name=\"twitter:label2\" content=\"Est. reading time\" \/>\n\t<meta name=\"twitter:data2\" content=\"22 minutes\" \/>\n<script type=\"application\/ld+json\" class=\"yoast-schema-graph\">{\"@context\":\"https:\/\/schema.org\",\"@graph\":[{\"@type\":\"Organization\",\"@id\":\"https:\/\/codefresh.io\/#organization\",\"name\":\"Codefresh\",\"url\":\"https:\/\/codefresh.io\/\",\"sameAs\":[\"https:\/\/www.facebook.com\/codefresh.io\",\"https:\/\/www.linkedin.com\/company\/codefresh\",\"https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg\",\"https:\/\/twitter.com\/codefresh\"],\"logo\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#logo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"width\":800,\"height\":800,\"caption\":\"Codefresh\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/#logo\"}},{\"@type\":\"WebSite\",\"@id\":\"https:\/\/codefresh.io\/#website\",\"url\":\"https:\/\/codefresh.io\/\",\"name\":\"Codefresh\",\"description\":\"\",\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"potentialAction\":[{\"@type\":\"SearchAction\",\"target\":{\"@type\":\"EntryPoint\",\"urlTemplate\":\"https:\/\/codefresh.io\/?s={search_term_string}\"},\"query-input\":\"required name=search_term_string\"}],\"inLanguage\":\"en-US\"},{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/devops-tutorial\/samurais-not-use-uis-using-cli-configure-codefresh-create-manage-kubernetes-pipelines\/#primaryimage\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/10\/samurais-do-not-use-uis.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/10\/samurais-do-not-use-uis.png\",\"width\":1492,\"height\":496},{\"@type\":\"WebPage\",\"@id\":\"https:\/\/codefresh.io\/devops-tutorial\/samurais-not-use-uis-using-cli-configure-codefresh-create-manage-kubernetes-pipelines\/#webpage\",\"url\":\"https:\/\/codefresh.io\/devops-tutorial\/samurais-not-use-uis-using-cli-configure-codefresh-create-manage-kubernetes-pipelines\/\",\"name\":\"Samurais Do NOT Use UIs: Using CLI To Configure Codefresh And Create And Manage Kubernetes Pipelines | Codefresh\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/#website\"},\"primaryImageOfPage\":{\"@id\":\"https:\/\/codefresh.io\/devops-tutorial\/samurais-not-use-uis-using-cli-configure-codefresh-create-manage-kubernetes-pipelines\/#primaryimage\"},\"datePublished\":\"2020-10-28T11:21:56+00:00\",\"dateModified\":\"2020-11-05T14:07:12+00:00\",\"breadcrumb\":{\"@id\":\"https:\/\/codefresh.io\/devops-tutorial\/samurais-not-use-uis-using-cli-configure-codefresh-create-manage-kubernetes-pipelines\/#breadcrumb\"},\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"ReadAction\",\"target\":[\"https:\/\/codefresh.io\/devops-tutorial\/samurais-not-use-uis-using-cli-configure-codefresh-create-manage-kubernetes-pipelines\/\"]}]},{\"@type\":\"BreadcrumbList\",\"@id\":\"https:\/\/codefresh.io\/devops-tutorial\/samurais-not-use-uis-using-cli-configure-codefresh-create-manage-kubernetes-pipelines\/#breadcrumb\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"name\":\"Home\",\"item\":\"https:\/\/codefresh.io\/\"},{\"@type\":\"ListItem\",\"position\":2,\"name\":\"Samurais Do NOT Use UIs: Using CLI To Configure Codefresh And Create And Manage Kubernetes Pipelines\"}]},{\"@type\":\"Article\",\"@id\":\"https:\/\/codefresh.io\/devops-tutorial\/samurais-not-use-uis-using-cli-configure-codefresh-create-manage-kubernetes-pipelines\/#article\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/devops-tutorial\/samurais-not-use-uis-using-cli-configure-codefresh-create-manage-kubernetes-pipelines\/#webpage\"},\"author\":{\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/268e5c2e4740502fae6d803783a16c75\"},\"headline\":\"Samurais Do NOT Use UIs: Using CLI To Configure Codefresh And Create And Manage Kubernetes Pipelines\",\"datePublished\":\"2020-10-28T11:21:56+00:00\",\"dateModified\":\"2020-11-05T14:07:12+00:00\",\"mainEntityOfPage\":{\"@id\":\"https:\/\/codefresh.io\/devops-tutorial\/samurais-not-use-uis-using-cli-configure-codefresh-create-manage-kubernetes-pipelines\/#webpage\"},\"wordCount\":3811,\"commentCount\":0,\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/devops-tutorial\/samurais-not-use-uis-using-cli-configure-codefresh-create-manage-kubernetes-pipelines\/#primaryimage\"},\"thumbnailUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/10\/samurais-do-not-use-uis.png\",\"articleSection\":[\"Continuous Deployment\/Delivery\",\"Devops\",\"Continuous Integration\",\"DevOps Tutorials\"],\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"CommentAction\",\"name\":\"Comment\",\"target\":[\"https:\/\/codefresh.io\/devops-tutorial\/samurais-not-use-uis-using-cli-configure-codefresh-create-manage-kubernetes-pipelines\/#respond\"]}]},{\"@type\":\"Person\",\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/268e5c2e4740502fae6d803783a16c75\",\"name\":\"Contributor\",\"image\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#personlogo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/secure.gravatar.com\/avatar\/26bd6dd87bf70f0c1a44721c8b3abbbd?s=96&d=blank&r=g\",\"contentUrl\":\"https:\/\/secure.gravatar.com\/avatar\/26bd6dd87bf70f0c1a44721c8b3abbbd?s=96&d=blank&r=g\",\"caption\":\"Contributor\"},\"url\":\"https:\/\/codefresh.io\/author\/contributor\/\"}]}<\/script>\n<!-- \/ Yoast SEO Premium plugin. -->","yoast_head_json":{"title":"Samurais Do NOT Use UIs: Using CLI To Configure Codefresh And Create And Manage Kubernetes Pipelines | Codefresh","robots":{"index":"index","follow":"follow","max-snippet":"max-snippet:-1","max-image-preview":"max-image-preview:large","max-video-preview":"max-video-preview:-1"},"canonical":"https:\/\/codefresh.io\/devops-tutorial\/samurais-not-use-uis-using-cli-configure-codefresh-create-manage-kubernetes-pipelines\/","og_locale":"en_US","og_type":"article","og_title":"Samurais Do NOT Use UIs: Using CLI To Configure Codefresh And Create And Manage Kubernetes Pipelines","og_description":"Are you a ninja? It&#8217;s a silly question. I know that you are most likely not a real ninja. But you might be considering yourself a ninja of software engineering. &#8220;What does Viktor mean by that?&#8221; I&#8217;m glad you asked. Ninjas appear, perform the mission, and disappear without leaving a trace behind. &#8220;Why is Viktor &hellip; Read more","og_url":"https:\/\/codefresh.io\/devops-tutorial\/samurais-not-use-uis-using-cli-configure-codefresh-create-manage-kubernetes-pipelines\/","og_site_name":"Codefresh","article_publisher":"https:\/\/www.facebook.com\/codefresh.io","article_published_time":"2020-10-28T11:21:56+00:00","article_modified_time":"2020-11-05T14:07:12+00:00","og_image":[{"width":1492,"height":496,"url":"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/10\/samurais-do-not-use-uis.png","type":"image\/png"}],"twitter_card":"summary_large_image","twitter_creator":"@codefresh","twitter_site":"@codefresh","twitter_misc":{"Written by":"Contributor","Est. reading time":"22 minutes"},"schema":{"@context":"https:\/\/schema.org","@graph":[{"@type":"Organization","@id":"https:\/\/codefresh.io\/#organization","name":"Codefresh","url":"https:\/\/codefresh.io\/","sameAs":["https:\/\/www.facebook.com\/codefresh.io","https:\/\/www.linkedin.com\/company\/codefresh","https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg","https:\/\/twitter.com\/codefresh"],"logo":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#logo","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","width":800,"height":800,"caption":"Codefresh"},"image":{"@id":"https:\/\/codefresh.io\/#logo"}},{"@type":"WebSite","@id":"https:\/\/codefresh.io\/#website","url":"https:\/\/codefresh.io\/","name":"Codefresh","description":"","publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"potentialAction":[{"@type":"SearchAction","target":{"@type":"EntryPoint","urlTemplate":"https:\/\/codefresh.io\/?s={search_term_string}"},"query-input":"required name=search_term_string"}],"inLanguage":"en-US"},{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/devops-tutorial\/samurais-not-use-uis-using-cli-configure-codefresh-create-manage-kubernetes-pipelines\/#primaryimage","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/10\/samurais-do-not-use-uis.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/10\/samurais-do-not-use-uis.png","width":1492,"height":496},{"@type":"WebPage","@id":"https:\/\/codefresh.io\/devops-tutorial\/samurais-not-use-uis-using-cli-configure-codefresh-create-manage-kubernetes-pipelines\/#webpage","url":"https:\/\/codefresh.io\/devops-tutorial\/samurais-not-use-uis-using-cli-configure-codefresh-create-manage-kubernetes-pipelines\/","name":"Samurais Do NOT Use UIs: Using CLI To Configure Codefresh And Create And Manage Kubernetes Pipelines | Codefresh","isPartOf":{"@id":"https:\/\/codefresh.io\/#website"},"primaryImageOfPage":{"@id":"https:\/\/codefresh.io\/devops-tutorial\/samurais-not-use-uis-using-cli-configure-codefresh-create-manage-kubernetes-pipelines\/#primaryimage"},"datePublished":"2020-10-28T11:21:56+00:00","dateModified":"2020-11-05T14:07:12+00:00","breadcrumb":{"@id":"https:\/\/codefresh.io\/devops-tutorial\/samurais-not-use-uis-using-cli-configure-codefresh-create-manage-kubernetes-pipelines\/#breadcrumb"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https:\/\/codefresh.io\/devops-tutorial\/samurais-not-use-uis-using-cli-configure-codefresh-create-manage-kubernetes-pipelines\/"]}]},{"@type":"BreadcrumbList","@id":"https:\/\/codefresh.io\/devops-tutorial\/samurais-not-use-uis-using-cli-configure-codefresh-create-manage-kubernetes-pipelines\/#breadcrumb","itemListElement":[{"@type":"ListItem","position":1,"name":"Home","item":"https:\/\/codefresh.io\/"},{"@type":"ListItem","position":2,"name":"Samurais Do NOT Use UIs: Using CLI To Configure Codefresh And Create And Manage Kubernetes Pipelines"}]},{"@type":"Article","@id":"https:\/\/codefresh.io\/devops-tutorial\/samurais-not-use-uis-using-cli-configure-codefresh-create-manage-kubernetes-pipelines\/#article","isPartOf":{"@id":"https:\/\/codefresh.io\/devops-tutorial\/samurais-not-use-uis-using-cli-configure-codefresh-create-manage-kubernetes-pipelines\/#webpage"},"author":{"@id":"https:\/\/codefresh.io\/#\/schema\/person\/268e5c2e4740502fae6d803783a16c75"},"headline":"Samurais Do NOT Use UIs: Using CLI To Configure Codefresh And Create And Manage Kubernetes Pipelines","datePublished":"2020-10-28T11:21:56+00:00","dateModified":"2020-11-05T14:07:12+00:00","mainEntityOfPage":{"@id":"https:\/\/codefresh.io\/devops-tutorial\/samurais-not-use-uis-using-cli-configure-codefresh-create-manage-kubernetes-pipelines\/#webpage"},"wordCount":3811,"commentCount":0,"publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"image":{"@id":"https:\/\/codefresh.io\/devops-tutorial\/samurais-not-use-uis-using-cli-configure-codefresh-create-manage-kubernetes-pipelines\/#primaryimage"},"thumbnailUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/10\/samurais-do-not-use-uis.png","articleSection":["Continuous Deployment\/Delivery","Devops","Continuous Integration","DevOps Tutorials"],"inLanguage":"en-US","potentialAction":[{"@type":"CommentAction","name":"Comment","target":["https:\/\/codefresh.io\/devops-tutorial\/samurais-not-use-uis-using-cli-configure-codefresh-create-manage-kubernetes-pipelines\/#respond"]}]},{"@type":"Person","@id":"https:\/\/codefresh.io\/#\/schema\/person\/268e5c2e4740502fae6d803783a16c75","name":"Contributor","image":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#personlogo","inLanguage":"en-US","url":"https:\/\/secure.gravatar.com\/avatar\/26bd6dd87bf70f0c1a44721c8b3abbbd?s=96&d=blank&r=g","contentUrl":"https:\/\/secure.gravatar.com\/avatar\/26bd6dd87bf70f0c1a44721c8b3abbbd?s=96&d=blank&r=g","caption":"Contributor"},"url":"https:\/\/codefresh.io\/author\/contributor\/"}]}},"acf":[],"_links":{"self":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/17706"}],"collection":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/users\/125"}],"replies":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/comments?post=17706"}],"version-history":[{"count":0,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/17706\/revisions"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media\/17788"}],"wp:attachment":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media?parent=17706"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/categories?post=17706"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/tags?post=17706"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}