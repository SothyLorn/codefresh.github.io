{"id":17926,"date":"2020-11-16T08:37:19","date_gmt":"2020-11-16T16:37:19","guid":{"rendered":"https:\/\/codefresh.io\/?p=17926"},"modified":"2022-03-22T15:59:54","modified_gmt":"2022-03-22T15:59:54","slug":"creating-temporary-preview-environments-based-pull-requests-argo-cd-codefresh","status":"publish","type":"post","link":"https:\/\/codefresh.io\/continuous-deployment\/creating-temporary-preview-environments-based-pull-requests-argo-cd-codefresh\/","title":{"rendered":"Creating Temporary Preview Environments Based On Pull Requests With Argo CD And Codefresh"},"content":{"rendered":"<p>Creating preview environments as a result of making pull requests is one of those practices that have vast potential and are yet largely overlooked. There is a strong chance that you are not using them, even though they can drastically increase productivity.<\/p>\n<p>I will not explain what preview environments are, besides stating that they are <strong>temporary environments created when pull requests are made and destroyed when PRs are closed<\/strong>.<\/p>\n<p>We will not debate what preview environments are, what Argo CD is, and why Codefresh is likely the best choice for defining and running continuous delivery pipelines. Instead, we will jump straight into defining the requirements that we might need to keep in mind and, after that, directly into the practical hands-on exploration of the concept.<\/p>\n<p>I might even throw in a diagram or two for those of you too lazy to do the hands-on exercises and just want to pretend to understand how it all works. If that&#8217;s what you&#8217;re looking for, I will not make it easy for you by putting them all at once at the top. Instead, the diagrams will be spread around the examples. You will have to, at least, do some scrolling. Think of that as me forcing you to put in some effort, even if it is limited to exercising your finger while scrolling.<\/p>\n<p>So, the focus is not on theory but on the practical implementation of preview environments. We&#8217;ll use Argo CD for deploying applications and <a href=\"https:\/\/codefresh.io\/codefresh-signup\/?utm_source=Blog&amp;utm_medium=Post&amp;utm_campaign=vfarcic-previews\">Codefresh<\/a> for pipelines that will orchestrate all the steps required when working with pull requests.<\/p>\n<p><em>If you are not proficient with Argo CD, I strongly recommend watching the <a href=\"https:\/\/youtu.be\/vpWQeoaiRM4\">Argo CD: Applying GitOps Principles To Manage Production Environment In Kubernetes<\/a> first. After that, if you would like to see a manual version of what we are about to fully automate, please go through <a href=\"https:\/\/youtu.be\/cpAaI8p4R60\">Environments Based On Pull Requests (PRs): Using Argo CD To Apply GitOps Principles On Previews<\/a>.<\/em><\/p>\n<p>With the pleasantries out of the way, we will jump straight into the mission by quickly exploring the expectations and the requirements.<\/p>\n<h2>Discussing The Expectations And The Requirements<\/h2>\n<p>There are usually many ways to accomplish an objective, and which one will be taken often depends on the expectations, which might shape the requirements.<\/p>\n<p>Let&#8217;s start with the expectations I set in front of me when designing the solution we are about to explore. There are only three, so it won&#8217;t take much time to go through them.<\/p>\n<p>Every time a pull request (PR) is made against a repository of an application, a <strong>temporary environment should be created with the build of that PR<\/strong> and, potentially, the dependencies. That way, we should be able to evaluate the quality of the PR by running automated or manual tests. By using unique and temporary environments, we should not be limited in the number of release candidates we are evaluating. Unlike static environments, like staging and production, that are forcing us to queue deployments, temporary preview environments should pose no such restrictions.<\/p>\n<p>Every time a pull request is closed, the <strong>temporary environment should be removed<\/strong>. That way, we should save on costs. There is no need to have a temporary environment based on a PR running after that PR is closed or merged.<\/p>\n<p>Finally, there is <strong>no need for anyone or anything to have direct access to the cluster<\/strong>. One of the most powerful features of Argo CD is to sync automatically with the desired state stored in Git. Today, with the tools we have at our disposal, there is no justifiable reason to lower the security requirements. We shouldn&#8217;t allow people, or even other tools, to interact with the cluster, as long as that does not impact productivity and does not introduce unnecessary delays.<\/p>\n<p><em>Please read <a href=\"https:\/\/codefresh.io\/devops\/gitops-patterns-auto-sync-vs-manual-sync\/\">GitOps Patterns \u2013 Auto-Sync Vs. Manual Sync<\/a> for an overview of the reasons behind enabling the auto-sync feature.<\/em><\/p>\n<p>That&#8217;s it. Those are all the expectations we are striving to fulfill.<\/p>\n<p>Now that the expectations are clear, or, at least, not wholly obscured, let&#8217;s define the requirements.<\/p>\n<p>We&#8217;ll need a <strong>Kubernetes cluster<\/strong> with <strong>Argo CD<\/strong> installed. You can create a cluster any way you like, anywhere you want. Similarly, it does not matter much how you install Argo CD, as long as you do, and as long as <strong>Ingress is enabled<\/strong> so that we can access it. If you need inspiration, I published a series of articles on how to create and manage Kubernetes clusters in <a href=\"https:\/\/codefresh.io\/continuous-deployment\/applying-gitops-continuous-delivery-cd-infrastructure-using-terraform-codefresh-google-kubernetes-engine-gke\/\">Google Cloud (GKE)<\/a>, <a href=\"https:\/\/codefresh.io\/continuous-deployment\/applying-gitops-continuous-delivery-cd-infrastructure-using-terraform-codefresh-aws-elastic-kubernetes-service-eks\/\">AWS (EKS)<\/a>, and <a href=\"https:\/\/codefresh.io\/kubernetes-tutorial\/applying-gitops-continuous-delivery-cd-infrastructure-using-terraform-codefresh-azure-kubernetes-service-aks\/\">Azure (AKS)<\/a>, as well as <a href=\"https:\/\/codefresh.io\/continuous-deployment\/installing-managing-argo-cd-continuous-delivery-pipelines-using-codefresh-google-kubernetes-engine-gke-aws-elastic-kubernetes-service-eks-azure-kubernetes-service-aks\/\">instructions on how to automate the installation and management of Argo CD itself<\/a>.<\/p>\n<p>You do not have to follow any of those instructions if you do not want to. As long as you have a Kubernetes cluster and you installed Argo CD, it does not matter how you did it.<\/p>\n<p>There are a few other requirements, though. I will assume that you created an environment variable <code>INGRESS_HOST<\/code> with the IP of your Ingress controller through which we can access the applications inside the cluster.<\/p>\n<p>Finally, I will assume that you installed <a href=\"https:\/\/codefresh-io.github.io\/cli\/getting-started\/\">Codefresh CLI<\/a> and authenticated it against your Codefresh account. If you haven&#8217;t, I encourage you to watch <a href=\"https:\/\/youtu.be\/B9wmBf6lElc\">Using CLI To Configure Codefresh And Create And Manage Kubernetes Pipelines<\/a>, which provides a quick introduction through practical hands-on examples into the <code>codefresh<\/code> CLI.<\/p>\n<p>Now we&#8217;re ready to start defining everything we need for creating pull requests.<\/p>\n<h2>Creating The Project And App Of Apps<\/h2>\n<p>Before we dive into pull requests and preview environments, we&#8217;ll need to create a few things that will define the framework of everything else we&#8217;ll do.<\/p>\n<p><em>All the commands are available in the <a href=\"https:\/\/gist.github.com\/b4e94c9e443c33e0a506a08b31a7e643\">previews.sh<\/a> Gist. Feel free to use it if you&#8217;re too lazy to type. There&#8217;s no shame in copy &amp; paste.<\/em><\/p>\n<p>To begin with, we need a Git repository where we will define preview environments. Luckily for you, I already created such a repository, so all we have to do is fork it.<\/p>\n<p><em>If you are a <strong>Linux<\/strong> or a <strong>WSL<\/strong> user, the <code>open<\/code> command might not work. If that is the case, you should replace <code>open<\/code> with <code>echo<\/code> and copy and paste the output into your favorite browser.<\/em><\/p>\n<pre><code class=\"bash\">open https:\/\/github.com\/vfarcic\/argocd-previews\r\n<\/code><\/pre>\n<p>Next, you will need to fork the repo. We&#8217;ll soon make some changes to the code, and you wouldn&#8217;t be able to push them to my repo. So, it needs to be yours.<\/p>\n<p><em>If you do not know how to fork a GitHub repo, the only thing I can say is &#8220;shame on you&#8221;. Google how to do that. I will not spend time explaining that.<\/em><\/p>\n<p>Next, we&#8217;ll clone the newly forked repository.<\/p>\n<p><em>Please replace <code>[...]<\/code> with your GitHub organization in the command that follows. If you forked the repo into your personal account, then the organization is your GitHub username.<\/em><\/p>\n<pre><code class=\"bash\">export GH_ORG=[...]\r\n\r\ngit clone https:\/\/github.com\/$GH_ORG\/argocd-previews.git\r\n\r\ncd argocd-previews\r\n<\/code><\/pre>\n<p>If you already forked that repository before, while going through some other exercises of mine, you might want to merge with the upstream. That should ensure that you have the latest changes I might have added.<\/p>\n<p><em>Please execute the commands that follow only if you already forked the repository earlier.<\/em><\/p>\n<pre><code class=\"bash\">git remote add upstream \\\r\n    https:\/\/github.com\/vfarcic\/argocd-previews\r\n\r\ngit fetch upstream\r\n\r\ngit merge upstream\/master\r\n<\/code><\/pre>\n<p>Now we can explore a few critical files. The first one is the Argo CD project that will group all the preview environments.<\/p>\n<pre><code class=\"bash\">cat project.yaml\r\n<\/code><\/pre>\n<p>The output is as follows.<\/p>\n<pre><code class=\"yaml\">apiVersion: argoproj.io\/v1alpha1\r\nkind: AppProject\r\nmetadata:\r\n  name: previews\r\n  namespace: argocd\r\n  finalizers:\r\n    - resources-finalizer.argocd.argoproj.io\r\nspec:\r\n  description: Previews\r\n  sourceRepos:\r\n  - '*'\r\n  destinations:\r\n  - namespace: previews\r\n    server: https:\/\/kubernetes.default.svc\r\n  - namespace: \"pr-*\"\r\n    server: https:\/\/kubernetes.default.svc\r\n  - namespace: argocd\r\n    server: https:\/\/kubernetes.default.svc\r\n  clusterResourceWhitelist:\r\n  - group: ''\r\n    kind: Namespace\r\n  namespaceResourceWhitelist:\r\n  - group: \"*\"\r\n    kind: \"*\"\r\n<\/code><\/pre>\n<p>The only &#8220;special&#8221; thing about that project is that it allows <code>pr-*<\/code> as the <code>namespace<\/code> where we might deploy applications that belong to that project. As you can probably guess, <code>*<\/code> is the wildcard character, so that entry means that any Namespace with the name that starts with <code>pr-<\/code> is allowed.<\/p>\n<p>We are whitelisting (<code>clusterResourceWhitelist<\/code>) the <code>Namespace<\/code> as a resource that can be created on the cluster level. That should allow Argo CD to create those associated with preview environments.<\/p>\n<p>I&#8217;m sure you can figure out the meaning of the rest of that definition yourself, so let&#8217;s move on and <code>apply<\/code> it.<\/p>\n<pre><code class=\"bash\">kubectl apply --filename project.yaml\r\n<\/code><\/pre>\n<p>*Normally, we would not create any resource manually from a terminal. In this specific case, we should probably trigger a pipeline build on changes to that repo. The pipeline would be executing the same <code>kubectl apply<\/code> command. We&#8217;re not doing that right now for brevity reasons. I want us to get to the subject at hand as fast as possible.<\/p>\n<p>Next, we&#8217;ll create an app of apps. It will be an Argo CD application that will be used mostly as a reference for it to know where to look for the applications related to preview environments.<\/p>\n<p>Just as before, I already created the definition we can use, so let&#8217;s take a quick look at it.<\/p>\n<pre><code class=\"bash\">cat apps.yaml\r\n<\/code><\/pre>\n<p>The output is as follows.<\/p>\n<pre><code class=\"yaml\">apiVersion: argoproj.io\/v1alpha1\r\nkind: Application\r\nmetadata:\r\n  name: previews\r\n  namespace: argocd\r\n  finalizers:\r\n    - resources-finalizer.argocd.argoproj.io\r\nspec:\r\n  project: previews\r\n  source:\r\n    repoURL: https:\/\/github.com\/vfarcic\/argocd-previews.git\r\n    targetRevision: HEAD\r\n    path: helm\r\n  destination:\r\n    server: https:\/\/kubernetes.default.svc\r\n    namespace: previews\r\n<\/code><\/pre>\n<p>That YAML defines Argo CD <code>Application<\/code> that will monitor a specific <code>repoURL<\/code> and <code>path<\/code>. Whatever is defined in there will be considered the desired state, and Argo CD will ensure that the actual state is converged into it.<\/p>\n<p>The definition uses the <code>previews<\/code> project that we created a few moments ago.<\/p>\n<p>Before we proceed, we need to modify the <code>repoURL<\/code>. It is currently pointing to my repository, so we should change it to use the fork you created earlier. We&#8217;ll do that with a bit of &#8220;<code>sed<\/code> magic&#8221;.<\/p>\n<pre><code class=\"bash\">cat apps.yaml \\\r\n    | sed -e \"s@vfarcic@$GH_ORG@g\" \\\r\n    | tee apps.yaml\r\n<\/code><\/pre>\n<p>Let&#8217;s push that change to the Git repo. It&#8217;s of no use to keep it local.<\/p>\n<pre><code class=\"bash\">git add .\r\n\r\ngit commit -m \"Initial commit\"\r\n\r\ngit push\r\n<\/code><\/pre>\n<p>We&#8217;re almost finished with the resources in the previews repo. All that&#8217;s left is to <code>apply<\/code> the definition in the <code>apps.yaml<\/code>.<\/p>\n<pre><code class=\"bash\">kubectl apply --filename apps.yaml\r\n<\/code><\/pre>\n<p>There is one more thing we might want to observe.<\/p>\n<p>As you already saw, the Argo CD <code>Application<\/code> we just created will monitor the <code>helm<\/code> directory inside that repo. As you can probably guess from the name, it is a Helm chart. That&#8217;s where we&#8217;ll be adding, modifying, and removing files to match the desired state of our preview environment. Typically, it should be empty at the start. We did not yet create any PR, so there shouldn&#8217;t be any environments. However, Helm does not allow us to deploy a chart without any definition. So, there must be something, even though, right now, we want nothing. As a workaround, I created a dummy Helm template that will serve no purpose but as a workaround for Helm&#8217;s inability to have a Chart without a single resource.<\/p>\n<p>Let&#8217;s take a look at the dummy.<\/p>\n<pre><code class=\"bash\">ls -1 helm\/templates\r\n<\/code><\/pre>\n<p>The output is a single <code>namespace.yaml<\/code> file. Inside is a definition of a Namespace <code>previews<\/code>, and nothing else. You can ignore it. I mentioned it only because I do not want there to be any secrets between us.<\/p>\n<p>We will not need to interact with the previews repo anymore, at least not directly, so let&#8217;s get out of the local copy.<\/p>\n<pre><code class=\"bash\">cd ..\r\n<\/code><\/pre>\n<p>Now we are ready to dive into pull requests themselves.<\/p>\n<h2>Creating The Pipeline<\/h2>\n<p>The actions we might want to perform when creating pull requests are the same as when syncing and reopening them.<\/p>\n<p>That would probably sound strange if I said it ten years ago when most of us treated applications as mutable entities. Back then, we would create an environment and deploy a temporary release whenever a pull request is made. We would probably update that deployment after syncing it (pushing changes). I&#8217;m not even sure what we would do as a reaction to reopening a pull request. Would we recreate the preview environment? In any case, back then, the actions performed on opening PRs would be different from those when syncing or reopening them.<\/p>\n<p>Today, we can tie all those three types of events into one set of actions, thanks to the immutability behind container images and the idempotency of Kubernetes resources. Whenever a pull request is created, synced, or reopened, we can tell Kubernetes that we want specific resources to be running inside the cluster and let it handle the rest.<\/p>\n<p>However, since we are trying to apply GitOps principles, we will not tell Kubernetes anything. Instead, we&#8217;ll change the definitions in a dedicated Git repository and let Argo CD figure out what to do to comply with our desires.<\/p>\n<p>The ideal situation would be to use one of your applications for the exercises. But that would also increase the number of potential permutations of the things I would need to explain. I could not guess in advance how to build the binaries and to perform whichever actions might be specific to your situation. Instead, we&#8217;ll use one of my demo apps with the assumption that you should have no problems translating the lessons-learned. If you read my other posts or watched some of my videos, you can probably guess which application it is. It&#8217;s okay if you can&#8217;t. The app is as simple as it can get. It&#8217;s so basic that it is not worth even explaining what it does. What matters is the process rather than the architecture of the app anyway.<\/p>\n<p>Let&#8217;s open the repository of the app.<\/p>\n<pre><code class=\"bash\">open https:\/\/github.com\/vfarcic\/devops-toolkit\r\n<\/code><\/pre>\n<p>You know what&#8217;s coming next. Fork the repo first and execute the commands that follow to clone it.<\/p>\n<pre><code class=\"bash\">git clone https:\/\/github.com\/$GH_ORG\/devops-toolkit.git\r\n\r\ncd devops-toolkit\r\n<\/code><\/pre>\n<p>If you already forked that repository before while going through some other exercises of mine, you might want to merge with upstream. That should ensure that you have the latest changes I might have added.<\/p>\n<p><em>Please execute the commands that follow only if you already forked the repository earlier.<\/em><\/p>\n<pre><code class=\"bash\">git remote add upstream \\\r\n    https:\/\/github.com\/vfarcic\/devops-toolkit\r\n\r\ngit fetch upstream\r\n\r\ngit merge upstream\/master\r\n<\/code><\/pre>\n<p>If we are to create preview environments based on pull requests as Argo CD applications, we need to have a template we can use. It cannot be a generic Argo CD application since the way apps are deployed might differ from one application to another. Some applications might require extra dependencies, others might have different ways to define tags, and so on and so forth. If we are using Helm, most of those differences can be described as Helm values. In other words, which values will be overwritten for preview environments might differ from one application to another. With that in mind, we might need a template (of sorts) dedicated to each app.<\/p>\n<p>Given that I believe that a repository of an app should contain everything that app needs when running in isolation, the logical place for the template of the Argo CD app that describes it is in the repo of the application. If we combine that with my love of naming conventions, we get to the idea that each repo of applications could contain a file called <code>preview.yaml<\/code>. That file can be the template we need for deploying apps in preview environments.<\/p>\n<p>Let&#8217;s look at the one I already prepared.<\/p>\n<pre><code class=\"bash\">cat preview.yaml\r\n<\/code><\/pre>\n<p>The output is as follows.<\/p>\n<pre><code class=\"yaml\">apiVersion: argoproj.io\/v1alpha1\r\nkind: Application\r\nmetadata:\r\n  name: \"{{.APP_ID}}\"\r\n  namespace: argocd\r\n  finalizers:\r\n    - resources-finalizer.argocd.argoproj.io\r\nspec:\r\n  project: previews\r\n  source:\r\n    path: helm\r\n    repoURL: https:\/\/github.com\/vfarcic\/devops-toolkit.git\r\n    targetRevision: HEAD\r\n    helm:\r\n      values: |\r\n        image:\r\n          repository: vfarcic\/devops-toolkit\r\n          tag: {{.IMAGE_TAG}}\r\n        ingress:\r\n          host: {{.APP_ID}}.devopstoolkitseries.com\r\n      version: v3\r\n  destination:\r\n    namespace: \"{{.APP_ID}}\"\r\n    server: https:\/\/kubernetes.default.svc\r\n  syncPolicy:\r\n    automated:\r\n      selfHeal: true\r\n      prune: true\r\n    syncOptions:\r\n    - CreateNamespace=true\r\n<\/code><\/pre>\n<p>To begin with, that file is not a typical YAML file. I already mentioned that is should be a template, and not the file that contains the final definition.<\/p>\n<p>We will be using <a href=\"https:\/\/github.com\/frigus02\/kyml\">kyml<\/a>, given that it might be the simplest way to convert a template into the final file.<\/p>\n<p>The <code>preview.yaml<\/code> contains a couple of entries specific to kyaml. Those are the ones surrounded by double curly braces (<code>{{<\/code> and <code>}}<\/code>). To be more precise, templated values are those that are likely going to change from one preview (one PR) to another.<\/p>\n<p>Each <code>Application<\/code> <code>name<\/code> needs to be unique. So, we are having <code>{{.APP_ID}}<\/code> as the value of <code>metadata.name<\/code>.<\/p>\n<p>Further on, we are overwriting a few Helm <code>values<\/code>. Specifically, the <code>image.tag<\/code> needs to be the one that we will build through the pipelines. Also, <code>ingress.host<\/code> should be unique so that each PR preview can be accessed independently of others.<\/p>\n<p>Finally, the <code>spec.destination.namespace<\/code> should also be unique, so it contains the same <code>{{.APP_ID}}<\/code> we are using for the <code>metadata.name<\/code>.<\/p>\n<p>Before we proceed, there are values that will always be the same, but they are currently set to what works for me, not for you. Given that they will not change from one PR to another, it would be pointless to have them as templated values. They can stay hard-coded, but to the values that match your situation. Specifically, the <code>repoURL<\/code> should be pointing to your GitHub organization, the <code>image.repository<\/code> should use your Docker Hub account, and the domain should be whatever is the domain of your cluster.<\/p>\n<p>Given that I could not be sure that you have a domain at your disposal, we&#8217;ll use <a href=\"http:\/\/xip.io\/\">xip.io<\/a> to &#8220;simulate&#8221; it. That&#8217;s why I said that the environment variable <code>INGRESS_HOST<\/code> is one of the requirements. Let&#8217;s confirm that you did follow my instructions and set it up.<\/p>\n<pre><code class=\"bash\">echo $INGRESS_HOST\r\n<\/code><\/pre>\n<p>The output should be the IP through which you can access Ingress. If it is empty, you forgot to declare it or, more likely, you did not follow my instructions from the beginning of the article.<\/p>\n<p>You should already have the GitHub organization stored inside the environment variable <code>GH_ORG<\/code>, so the only value missing is your Docker Hub user. Please make sure that <a href=\"https:\/\/hub.docker.com\/\">you are registered<\/a>, and replace <code>[...]<\/code> with the username in the command that follows.<\/p>\n<pre><code class=\"bash\">export DH_USER=[...]\r\n<\/code><\/pre>\n<p>The only thing left when <code>preview.yaml<\/code> template is concerned, is to replace those hard-coded values.<\/p>\n<pre><code class=\"bash\">cat preview.yaml \\\r\n    | sed -e \"s@github.com\/vfarcic@github.com\/$GH_ORG@g\" \\\r\n    | sed -e \"s@repository: vfarcic@repository: $DH_USER@g\" \\\r\n    | sed -e \"s@devopstoolkitseries.com@$INGRESS_HOST.xip.io@g\" \\\r\n    | tee preview.yaml\r\n<\/code><\/pre>\n<p>Finally, we will need a Codefresh pipeline that will make sure that all the steps are executed whenever we create a pull request. I already created one we can use. Given that I might be experimenting with that repo quite a lot, I stored the &#8220;golden&#8221; copy of the pipeline we will use in the <code>codefresh<\/code> directory. Let&#8217;s copy it to the root of the local copy of the repo and see what&#8217;s inside.<\/p>\n<pre><code class=\"bash\">cp codefresh\/codefresh-pr-open.yml \\\r\n    codefresh-pr-open.yml\r\n\r\ncat codefresh-pr-open.yml\r\n<\/code><\/pre>\n<p>The output is as follows.<\/p>\n<pre><code class=\"yaml\">version: \"1.0\"\r\nkind: pipeline\r\nmetadata:\r\n  name: devops-toolkit-pr-open\r\n  description: Triggered when a PR is opened or synced\r\nspec:\r\n  triggers:\r\n  - type: git\r\n    provider: github\r\n    context: github\r\n    name: pr-open\r\n    repo: vfarcic\/devops-toolkit\r\n    events:\r\n    - pullrequest.opened\r\n    - pullrequest.reopened\r\n    - pullrequest.synchronize\r\n    pullRequestAllowForkEvents: true\r\n    pullRequestTargetBranchRegex: \/master\/gi\r\n    verified: true\r\n  contexts: []\r\n  stages:\r\n    - release\r\n    - deploy\r\n  steps:\r\n    main_clone:\r\n      title: Cloning repository\r\n      type: git-clone\r\n      arguments:\r\n        repo: \"${{CF_REPO_OWNER}}\/${{CF_REPO_NAME}}\"\r\n        git: github\r\n        revision: \"${{CF_BRANCH}}\"\r\n      stage: release\r\n    build_app:\r\n      title: Building Hugo\r\n      image: klakegg\/hugo:0.75.1-ext-alpine\r\n      commands:\r\n      - .\/build.sh\r\n      - cf_export REPO_PATH=$PWD\r\n      - cf_export APP_ID=pr-$CF_REPO_NAME-$CF_PULL_REQUEST_NUMBER\r\n      stage: release\r\n    build_image:\r\n      title: Building container image\r\n      type: build\r\n      arguments:\r\n        image_name: vfarcic\/devops-toolkit\r\n        tags:\r\n        - ${{CF_SHORT_REVISION}}\r\n        registry: docker-hub\r\n      stage: release\r\n    clone_env_repo:\r\n      title: Cloning preview env. repo\r\n      type: git-clone\r\n      arguments:\r\n        repo: vfarcic\/argocd-previews\r\n        git: github\r\n      stage: deploy\r\n    define_preview:\r\n      image: vfarcic\/argocd-pipeline:1.0.ee76b7a\r\n      title: Defining preview environment app\r\n      working_directory: \"${{clone_env_repo}}\" \r\n      commands:\r\n      - export IMAGE_TAG=$CF_SHORT_REVISION\r\n      - cat $REPO_PATH\/preview.yaml | kyml tmpl -e APP_ID -e IMAGE_TAG | tee helm\/templates\/$APP_ID.yaml\r\n      - git add .\r\n      stage: deploy\r\n    push_env_repo:\r\n      title: Pushing preview env. changes to the repo\r\n      type: git-commit\r\n      arguments:\r\n        repo: vfarcic\/argocd-previews\r\n        git: github\r\n        commit_message: \"Adding PR ${{CF_PULL_REQUEST_NUMBER}} from ${{CF_REPO_NAME}}\"\r\n        git_user_name: \"${{CF_COMMIT_AUTHOR}}\"\r\n        working_directory: \"\/codefresh\/volume\/argocd-previews\"\r\n      stage: deploy\r\n<\/code><\/pre>\n<p><em>If you are already using Codefresh (as I hope you do), you might not be used to creating pipelines with <code>codefresh<\/code> CLI and from definitions stored in Git. If you&#8217;re not, remember that the <a href=\"https:\/\/youtu.be\/B9wmBf6lElc\">Using CLI To Configure Codefresh And Create And Manage Kubernetes Pipelines<\/a> guides you through the first steps towards moving away from the UI. I will not go deep into the pipeline definition in front of us, assuming that you already watched that video. If you prefer written material, please follow the link to the <a href=\"https:\/\/codefresh.io\/devops-tutorial\/samurais-not-use-uis-using-cli-configure-codefresh-create-manage-kubernetes-pipelines\/\">more in-depth article<\/a>.<\/em>\u00aa<\/p>\n<p>Inside the <code>spec.triggers<\/code>, we are defining a single entry that defines which events will trigger builds. Those are <code>opened<\/code>, <code>reopened<\/code>, and <code>synchronize<\/code> events associated with PRs.<\/p>\n<p>The &#8220;real&#8221; action is happening in the <code>steps<\/code>.<\/p>\n<p>We are cloning the repository of the application (<code>main_clone<\/code>), building the app (<code>build_app<\/code>), and building the container image, and pushing to the registry (<code>build_image<\/code>). Those steps can be considered common to any type of pipeline that creates releases. The rest is specific to preview environments.<\/p>\n<p>Further on, we are cloning the <code>argocd-previews<\/code> repository (<code>clone_env_repo<\/code>) that should contain all the preview environments, not only those related to this application. The next step (<code>define_preview<\/code>) is the key. It takes the <code>preview.yaml<\/code> file we explored earlier, passes it through <code>kyaml<\/code> that replaces the <code>APP_ID<\/code> and <code>IMAGE_TAG<\/code> placeholders, and stores the result inside the <code>helm\/templates<\/code> directory as a file with a unique name. The <code>APP_ID<\/code> variable (defined in the <code>build_app<\/code> step) is a combination of the <code>pr-<\/code> prefix, the repository name, and the PR number. That makes it not only unique but easy to find. If we know the repo and the PR, we should have no trouble figuring out where it is defined and running inside the cluster.<\/p>\n<p>Finally, the last step (<code>push_env_repo<\/code>) is pushing the changes we made to the previews repo.<\/p>\n<p><em>Please note that a pipeline would have quite a few other steps. Normally, we would run tests, do security scanning, and so on. But, for simplicity reasons, we are exploring only those related to the deployment of preview environments.<\/em><\/p>\n<p>There is one more crucial thing left to note. But, this time, it is not about what we have, but what is missing.<\/p>\n<p>We are not using <code>kubectl apply<\/code>, <code>helm upgrade<\/code>, or any similar command. We are not communicating with the cluster in any form of way. For all we know, neither Codefresh nor we have access to the cluster. We might not even know where that cluster is. The pipeline is only building artifacts and pushing some changes to the repository that defines the desired state of preview environments. Argo CD is the one that will do the work of converging the actual state into our desires. It is already monitoring that repository and making sure that the changes to the <code>helm<\/code> directory are applied. As a result, no person or process needs to have access to the cluster.<\/p>\n<p>The problem with that pipeline is that it works for me, but not necessarily for you. We might need to change a few things to make it yours. For example, the Git repo organization (owner) is set to <code>vfarcic<\/code>, it assumes that the Git context defined in Codefresh is called <code>github<\/code>, and so on. We already have most of the information we need in environment variables, except for the Codefresh Git context and registry with container images. The good news is that we can easily find out what those are.<\/p>\n<pre><code class=\"bash\">codefresh get contexts\r\n<\/code><\/pre>\n<p>The output, in my case, is as follows.<\/p>\n<pre><code>NAME            TYPE\r\n...\r\ngithub-2        git.github\r\n<\/code><\/pre>\n<p>I, for example, have the <code>context<\/code> named <code>github-2<\/code>. Yours might be different. What matters is that you do have a context of type <code>git.github<\/code>. If you do not, please create one. If you&#8217;re confused about how to do it, you did not take my advice and watched the <a href=\"https:\/\/youtu.be\/B9wmBf6lElc\">Using CLI To Configure Codefresh And Create And Manage Kubernetes Pipelines<\/a> video. Maybe you did, but it wasn&#8217;t as helpful as I thought it would be. In that case, consult the official documentation or, simply, execute the <code>codefresh create context git github --help<\/code> command to find out how to create a <code>github<\/code> context.<\/p>\n<p>Whether you already had the <code>github<\/code> context or you created a new one just now, please replace <code>[...]<\/code> with the name.<\/p>\n<pre><code class=\"bash\">export CF_GIT_CONTEXT=[...]\r\n<\/code><\/pre>\n<p>Similarly to the <code>github<\/code> context, we&#8217;ll need the registry&#8217;s name, where we&#8217;ll push preview images. Let&#8217;s see whether you have one.<\/p>\n<pre><code class=\"bash\">codefresh get registry\r\n<\/code><\/pre>\n<p>The output, in my case, is as follows.<\/p>\n<pre><code>ID      PROVIDER  NAME       KIND     BEHINDFIREWALL DEFAULT\r\n5f84... dockerhub docker-hub standard false          true   \r\n<\/code><\/pre>\n<p>If you already have it, you&#8217;re my hero. If you don&#8217;t, that&#8217;s okay as well. Create it. Just do not tell me that you do not know-how, since that would mean that you ignored my repeated attempts at forcing you to watch the <a href=\"https:\/\/youtu.be\/B9wmBf6lElc\">Using CLI To Configure Codefresh And Create And Manage Kubernetes Pipelines<\/a>. That would hurt my feelings, and I tend to be very mean to those who break my heart.<\/p>\n<p>Anyway, I will assume that you have the name of the registry you want to use, so please replace <code>[...]<\/code> in the command that follows with whatever the name is.<\/p>\n<pre><code class=\"bash\">export CF_REGISTRY=[...]\r\n<\/code><\/pre>\n<p>Let&#8217;s resort to &#8220;<code>sed<\/code> magic&#8221; one more time, and push the changes to the repo.<\/p>\n<pre><code class=\"bash\">cat codefresh-pr-open.yml \\\r\n    | sed -e \"s@repo: vfarcic@repo: $GH_ORG@g\" \\\r\n    | sed -e \"s@image_name: vfarcic@image_name: $DH_USER@g\" \\\r\n    | sed -e \"s@IMAGE: vfarcic@IMAGE: $DH_USER\/devops-toolkit@g\" \\\r\n    | sed -e \"s@context: github@context: $CF_GIT_CONTEXT@g\" \\\r\n    | sed -e \"s@git: github@git: $CF_GIT_CONTEXT@g\" \\\r\n    | sed -e \"s@GIT_PROVIDER_NAME: github@GIT_PROVIDER_NAME: $CF_GIT_CONTEXT@g\" \\\r\n    | sed -e \"s@registry: docker-hub@registry: $CF_REGISTRY@g\" \\\r\n    | tee codefresh-pr-open.yml\r\n\r\ngit add .\r\n\r\ngit commit -m \"Corrections\"\r\n\r\ngit push\r\n<\/code><\/pre>\n<p>All that&#8217;s left before we start creating PRs and enjoying the liberating feeling of full automation is to create the pipeline we defined.<\/p>\n<pre><code class=\"bash\">codefresh create pipeline \\\r\n    -f codefresh-pr-open.yml\r\n<\/code><\/pre>\n<p>Now we are ready to see the effect of orchestrating the creation of preview environments through pipelines and Argo CD.<\/p>\n<h2>Creating, Syncing, And Reopening Pull Requests<\/h2>\n<p>We can finally reap the fruits of our labor by pretending to work on a new feature that will result in a pull request.<\/p>\n<p>Let&#8217;s <code>checkout<\/code> a branch, make a silly change as a way to simulate that we worked on a &#8220;real&#8221; feature, and push the changes.<\/p>\n<pre><code class=\"bash\">git checkout -b pr-1\r\n\r\necho \"A silly change\" | tee README.md\r\n\r\ngit add .\r\n\r\ngit commit -m \"A silly change\"\r\n\r\ngit push --set-upstream origin pr-1\r\n<\/code><\/pre>\n<p>I am obsessed with being able to do everything from a terminal using CLIs. Assuming that you have no saying how we do the exercises, I will continue passing that obsession to you by creating a PR from the terminal sessions. We&#8217;ll need GitHub CLI (<code>gh<\/code>) for that. If you do not have it already, please visit the <a href=\"https:\/\/github.com\/cli\/cli#installation\">Installation<\/a> page and follow the instructions.<\/p>\n<pre><code class=\"bash\">gh pr create \\\r\n    --repo $GH_ORG\/devops-toolkit \\\r\n    --title \"A silly change\" \\\r\n    --body \"A silly change indeed\"\r\n<\/code><\/pre>\n<p>We&#8217;ll need the PR number soon, so we&#8217;ll store it in yet another environment variable.<\/p>\n<p>*Please replace <code>[...]<\/code> with the PR number available in the output of the <code>gh pr create<\/code> command. It is probably <code>1<\/code>.<\/p>\n<pre><code class=\"bash\">export PR_NUMBER=[...]\r\n<\/code><\/pre>\n<p>This will be the first true test of whether the pipeline we created works and whether we configured the triggers correctly. If everything is going according to the plan, a new pipeline build should be running. GitHub should have fired a webhook request to Codefresh, notifying it that a new PR was created. In turn, Codefresh should have spun up an instance of the pipeline. We can confirm that by outputting <code>devops-toolkit-pr-open<\/code> builds.<\/p>\n<pre><code class=\"bash\">codefresh get builds \\\r\n    --pipeline-name devops-toolkit-pr-open\r\n<\/code><\/pre>\n<p>There should be a single build of that pipeline. We&#8217;ll need it if we want to look at the logs, so let&#8217;s store it inside an environment variable.<\/p>\n<p>*Please replace <code>[...]<\/code> in the command that follows with the ID of the build.<\/p>\n<pre><code class=\"bash\">export BUILD_ID=[...]\r\n<\/code><\/pre>\n<p>Unless you&#8217;re a &#8220;freak&#8221; like me, you might be tired of looking only at the terminal. If that&#8217;s not the case and you&#8217;d like to stay in the monochrome world, you can follow the build logs through <code>codefresh logs $BUILD_ID -f<\/code>. Otherwise, let&#8217;s open the build in a browser.<\/p>\n<pre><code class=\"bash\">open https:\/\/g.codefresh.io\/build\/$BUILD_ID\r\n<\/code><\/pre>\n<p>All that&#8217;s left is to wait for a few moments until the build is finished.<\/p>\n<p>Once the build is finished, Argo CD will detect that a change was made to the previews repo and, soon afterward, it will deploy the preview based on the PR we created earlier. We can observe the status of Argo CD synchronization through CLI but, given that we already switched to the browser, we might do that through the Argo CD UI. But, before we do that, we need to &#8220;discover&#8221; the address.<\/p>\n<pre><code class=\"bash\">ARGOCD_ADDR=$(kubectl \\\r\n    --namespace argocd \\\r\n    get ingress argocd-server \\\r\n    --output jsonpath=\"{.spec.rules[0].host}\")\r\n\r\necho $ARGOCD_ADDR\r\n<\/code><\/pre>\n<p>If the first command threw an error or the value of <code>echo<\/code> is empty, you probably forgot to enable Argo CD Ingress. Shame on you. You should have followed my instructions on how to set it up. Now you&#8217;re on your own. Go and figure out how to enable Ingress for Argo CD through the official docs.<\/p>\n<p>Let&#8217;s open the UI and see what we&#8217;ll get.<\/p>\n<pre><code class=\"bash\">open http:\/\/$ARGOCD_ADDR\r\n<\/code><\/pre>\n<p>We can see that there are two applications. The <em>previews<\/em> is the app of the apps. We can think of it as a group of applications stored in the referenced repo. The <em>pr-devops-toolkit-1<\/em> is the preview environment created as a result of us making the PR. If that&#8217;s confusing, it will hopefully become more apparent if we open the <em>previews<\/em> app.<\/p>\n<p>Click somewhere on the <em>previews<\/em> box.<\/p>\n<p>We can see that the <em>previews<\/em> Application contains two resources. There is the <em>previews<\/em> Namespace, which, if you remember, is the dummy resource we have in the Helm chart. We&#8217;re using it to avoid potential problems with charts without any resources.<\/p>\n<p>The <em>pr-devops-toolkit-1<\/em> Application is the one we just created. We can see that it is considered as part of the <em>previews<\/em> app.<\/p>\n<p>Click the <em>open application<\/em> icon in the <em>pr-devops-toolkit-1<\/em> Application, and you should see all the resources it contains. There is a Deployment, an Ingress, a Service, and so on.<\/p>\n<p>Even though I promised that I will put my need to do everything from a terminal on hold and allow you to see some colors through UIs, this was as much as I could take it. Prolonged exposure to UIs hearts my eyes, so we&#8217;ll go back to the terminal.<\/p>\n<p>Let&#8217;s take a look at what&#8217;s going on with the Namespaces.<\/p>\n<pre><code class=\"bash\">kubectl get namespaces\r\n<\/code><\/pre>\n<p>The output, limited to the relevant parts, is as follows.<\/p>\n<pre><code>NAME                  STATUS   AGE\r\n...\r\npr-devops-toolkit-1   Active   7m22s\r\n...\r\n<\/code><\/pre>\n<p>We can see that a new Namespace (<code>pr-devops-toolkit-1<\/code>) was created. It is unique and reserved for the preview environment related to the PR we opened earlier.<\/p>\n<p>All that might be great, but the real test of the process is whether the application is indeed up and running and can be accessed through a unique subdomain. We could easily &#8220;guess&#8221; what that subdomain is given that it is based on the name of the repo and the PR number. Nevertheless, why would we &#8220;stretch&#8221; our brain if we can retrieve it by querying Kubernetes?<\/p>\n<p><em>Ideally, we should have instructed the pipeline to write a comment to the PR with the address through which the app is accessible. It could have been something like &#8220;A preview environment was created and is accessible through __________.&#8221; But we didn&#8217;t do that since that is out of the scope of this article. I had to draw the line somewhere. Otherwise, this text was on the way towards becoming just as big as <a href=\"https:\/\/en.wikipedia.org\/wiki\/War_and_Peace\">War and Peace<\/a>.<\/em><\/p>\n<pre><code class=\"bash\">export APP_ADDR=$(kubectl \\\r\n    --namespace pr-devops-toolkit-$PR_NUMBER \\\r\n    get ingresses \\\r\n    --output jsonpath=\"{.items[0].spec.rules[0].host}\")\r\n\r\necho $APP_ADDR\r\n<\/code><\/pre>\n<p>The output, in my case, is as follows.<\/p>\n<pre><code>pr-devops-toolkit-1.54.88.253.179.xip.io\r\n<\/code><\/pre>\n<p>Let&#8217;s open the app in a browser and pretend that we are testing it manually while dreaming that the tests are being executed by pipeline builds.<\/p>\n<pre><code class=\"bash\">open http:\/\/$APP_ADDR\r\n<\/code><\/pre>\n<p>That&#8217;s it. We created a PR, which triggered a pipeline which built the binaries, pushed them to registries, and modified the previews repo. Argo CD detected those changes and interpreted them as a new desired state. It converged the actual state into the new desired state. As a result, the preview environment is up-and-running inside the cluster. Neither we nor pipeline builds instructed Kubernetes to change the state. All that changed is the desired state stored in Git.<\/p>\n<p>Let&#8217;s keep things clean and <code>checkout<\/code> the <code>master<\/code> branch.<\/p>\n<pre><code class=\"bash\">git checkout master\r\n<\/code><\/pre>\n<p>We&#8217;re halfway through when PRs are concerned. We created a process that is executed whenever a PR is created, synced, or reopened. We&#8217;ll soon move into the second part of the story and define what should happen when PRs are closed. But, before we do, I have a task for you.<\/p>\n<p>Create a few more PRs and observe the results. Think of the &#8220;process&#8221; as a new toy you might want to play with. Get familiar with that part of the process before we move on.<\/p>\n<h2>Closing Pull Requests<\/h2>\n<p>We saw how we can create as many environments as there are open pull requests. As a result, no one will ever need to wait until their pull request is reviewed and tested. Or, at least, if there is some waiting time, that will be due to people&#8217;s inability to do their part of the work, and not because a release candidate not being deployed and tested.<\/p>\n<p>Still, this approach has a potentially huge issue that needs to be resolved. It might be too expensive. We can solve that problem in two ways.<\/p>\n<p>To begin with, we can make preview environments run only when someone is using them. We could accomplish that through, let&#8217;s say, <a href=\"https:\/\/knative.dev\/\">Knative<\/a>, that would scale the application to zero replicas when not in use and back up when machines are running tests or validating it manually. But that is not the subject today, so we&#8217;ll skip Knative (for now).<\/p>\n<p>The other important thing we can do to lower the cost is to remove preview environments as soon as PRs are closed. That is indeed within the scope of this article, so let&#8217;s get going and do that.<\/p>\n<p>Just as we created a pipeline that is triggered whenever a pull request is opened, synced, or reopened, we&#8217;ll make another one that will be used when PRs are closed. As you can probably guess, I already prepared one we can use. It&#8217;s stored in the <code>codefresh<\/code> directory, so let&#8217;s copy it to the root and see what&#8217;s inside.<\/p>\n<pre><code class=\"bash\">cp codefresh\/codefresh-pr-close.yml \\\r\n    codefresh-pr-close.yml\r\n\r\ncat codefresh-pr-close.yml\r\n<\/code><\/pre>\n<p>The output is as follows.<\/p>\n<pre><code class=\"yaml\">version: \"1.0\"\r\nkind: pipeline\r\nmetadata:\r\n  name: devops-toolkit-pr-close\r\n  description: Triggered when a PR is closed\r\nspec:\r\n  triggers:\r\n  - type: git\r\n    provider: github\r\n    context: github\r\n    name: pr-close\r\n    repo: vfarcic\/devops-toolkit\r\n    events:\r\n    - pullrequest.closed\r\n    pullRequestAllowForkEvents: true\r\n    pullRequestTargetBranchRegex: \/master\/gi\r\n    verified: true\r\n  contexts: []\r\n  stages:\r\n    - deploy\r\n  steps:\r\n    clone_env_repo:\r\n      title: Cloning preview env. repo\r\n      type: git-clone\r\n      arguments:\r\n        git: github\r\n        repo: vfarcic\/argocd-previews\r\n      stage: deploy\r\n    remove_preview:\r\n      image: vfarcic\/argocd-pipeline:1.0.ee76b7a\r\n      title: Removing preview environment app\r\n      working_directory: \"${{clone_env_repo}}\" \r\n      commands:\r\n      - export APP_ID=pr-$CF_REPO_NAME-$CF_PULL_REQUEST_NUMBER\r\n      - rm -f helm\/templates\/$APP_ID.yaml\r\n      - git add .\r\n      stage: deploy\r\n    push_env_repo:\r\n      title: Push preview env. changes to the repo\r\n      type: git-commit\r\n      arguments:\r\n        git: github\r\n        repo: vfarcic\/argocd-previews\r\n        commit_message: \"Adding PR ${{CF_PULL_REQUEST_NUMBER}} from ${{CF_REPO_NAME}}\"\r\n        git_user_name: \"${{CF_COMMIT_AUTHOR}}\"\r\n        working_directory: \"\/codefresh\/volume\/argocd-previews\"\r\n      stage: deploy\r\n<\/code><\/pre>\n<p>This pipeline is even simpler than the previous one. We do not need to clone the application&#8217;s repo, to build binaries, to store them in registries, nor any other action we might normally do when PRs are opened. The only job of that pipeline is to remove the Argo CD application from the previews repository.<\/p>\n<p>We can see that the <code>spec.triggers<\/code> entry has a single event <code>pullrequest.closed<\/code>.<\/p>\n<p>Further on, inside the <code>steps<\/code> section, we are cloning the environment repository (<code>clone_env_repo<\/code>), removing the preview app associated with the PR (<code>remove_preview<\/code>), and pushing changes back to the repo (<code>push_env_repo<\/code>).<\/p>\n<p>That&#8217;s it. That&#8217;s all the pipeline does. Simplicity is a good thing, isn&#8217;t it?<\/p>\n<p>Just as before, we&#8217;ll need to replace a few hard-coded values specific to my setup and push the changes back to the repo.<\/p>\n<pre><code class=\"bash\">cat codefresh-pr-close.yml \\\r\n    | sed -e \"s@repo: vfarcic@repo: $GH_ORG@g\" \\\r\n    | sed -e \"s@context: github@context: $CF_GIT_CONTEXT@g\" \\\r\n    | sed -e \"s@git: github@git: $CF_GIT_CONTEXT@g\" \\\r\n    | tee codefresh-pr-close.yml\r\n\r\ngit add .\r\n\r\ngit commit -m \"Corrections\"\r\n\r\ngit push\r\n<\/code><\/pre>\n<p>All that&#8217;s left before we see it in action is to create the pipeline.<\/p>\n<pre><code class=\"bash\">codefresh create pipeline \\\r\n    -f codefresh-pr-close.yml\r\n<\/code><\/pre>\n<p>Let&#8217;s open the PR and see what we have so far.<\/p>\n<pre><code class=\"bash\">open https:\/\/github.com\/$GH_ORG\/devops-toolkit\/pull\/$PR_NUMBER\r\n<\/code><\/pre>\n<p>Please click the <em>Show all checks<\/em> link, and you&#8217;ll see that the build initiated as a result of creating the pull request passed.<\/p>\n<p>We could close the PR in two ways. One possible action would be to merge it into the mainline. That would trigger two events, merge and close. However, since we might still want to check whether the previous pipeline works on the reopen event, we&#8217;ll choose the other option and close the PR instead of merging it. From the perspective of that pipeline, both merge and close actions are the same since both are firing the <code>closed<\/code> event.<\/p>\n<p>Please click the <em>Close pull request<\/em> button.<\/p>\n<p>Let&#8217;s take a quick look at whether a new build of the <code>devops-toolkit-pr-close<\/code> pipeline was created and is running.<\/p>\n<pre><code class=\"bash\">codefresh get builds \\\r\n    --pipeline-name devops-toolkit-pr-close\r\n<\/code><\/pre>\n<p>There should be a single build. Let&#8217;s see what it&#8217;s doing.<\/p>\n<p><em>Please replace <code>[...]<\/code> in the command that follows with the ID of the build.<\/em><\/p>\n<pre><code class=\"bash\">export BUILD_ID=[...] # Replace `[...]` with the ID of the last build\r\n\r\nopen https:\/\/g.codefresh.io\/build\/$BUILD_ID\r\n<\/code><\/pre>\n<p>We should see the three steps that constitute the pipeline. One of them might still be running. If that&#8217;s the case, please wait until the whole pipeline build is finished. Feel free to entertain yourself by observing the logs of one of the steps.<\/p>\n<p>Let&#8217;s take a look at what happened with the Namespace of the preview environment associated with the PR we just closed.<\/p>\n<pre><code class=\"bash\">kubectl get namespaces\r\n<\/code><\/pre>\n<p>The output, limited to the relevant parts, is as follows.<\/p>\n<pre><code>NAME                STATUS AGE\r\n...\r\npr-devops-toolkit-1 Active 47m\r\n...\r\n<\/code><\/pre>\n<p>The Namespace is still there. That&#8217;s disappointing, isn&#8217;t it? The preview environment was supposed to be removed, but the Namespace is still there. But, if you take a closer look at the pipeline, seeing that the Namespace is still there should come as no surprise. We removed the application from the previews repo. We changed the desired state by saying that we do not want the preview application anymore. We did not say that we do not want the Namespace that was created automatically. If everything went as planned, Argo CD should have removed the app while leaving the Namespace intact. Let&#8217;s confirm that.<\/p>\n<pre><code class=\"bash\">kubectl --namespace pr-devops-toolkit-$PR_NUMBER \\\r\n    get pods\r\n<\/code><\/pre>\n<p>The output should show that <code>No resources<\/code> were <code>found in pr-devops-toolkit-1 namespace.<\/code><\/p>\n<p><em>If, in your case, the Pods are still there, you probably did not give Argo CD enough time to synchronize. Wait for a few moments, and retrieve the Pods again.<\/em><\/p>\n<p>The application is indeed gone. As a result, we are not wasting resources on a PR that does not exist anymore. The empty Namespace left behind is not using any CPU or memory. It&#8217;s just annoying that it is there. We could have solved that as well, but not through the pipeline. One of the requirements is to NOT allow access to the cluster to anyone or anything, including pipelines. I&#8217;ll leave that to you as &#8220;special homework&#8221;. There are a few ways to solve that, and I&#8217;m curious which one you will come up with. Please let me know how you did it.<\/p>\n<p>Now, let&#8217;s go back to the previous pipeline and confirm that the trigger associated with reopening PRs works as well. We&#8217;ll imagine that we closed the pull request by error or that we changed our mind and would want it after all.<\/p>\n<pre><code class=\"bash\">open https:\/\/github.com\/$GH_ORG\/devops-toolkit\/pull\/$PR_NUMBER\r\n<\/code><\/pre>\n<p>Please click the <em>Reopen pull request<\/em> button.<\/p>\n<p>You should already know what happens next and what we will do to observe the outcome.<\/p>\n<p>Reopening the pull request triggered an even that was sent to Codefresh. Given that the <code>devops-toolkit-pr-open<\/code> pipeline has a trigger that corresponds with that event, a new build was created. We can confirm that by retrieving all the builds of that pipeline.<\/p>\n<pre><code class=\"bash\">codefresh get builds \\\r\n    --pipeline-name devops-toolkit-pr-open\r\n<\/code><\/pre>\n<p><em>Please copy the latest build&#8217;s ID, and paste it instead of <code>[...]<\/code> in the commands that follow.<\/em><\/p>\n<pre><code class=\"bash\">export BUILD_ID=[...] # Replace `[...]` with the ID of the last build\r\n\r\nopen https:\/\/g.codefresh.io\/build\/$BUILD_ID\r\n<\/code><\/pre>\n<p>Next, we should wait until the build is finished. Once it&#8217;s done, the definition of the preview app associated with that PR should be pushed to the previews repo. Argo CD, on the other hand, is monitoring that same repo, and, soon afterward, it should initiate the convergence of the actual into the desired state.<\/p>\n<pre><code class=\"bash\">kubectl --namespace pr-devops-toolkit-$PR_NUMBER \\\r\n    get pods\r\n<\/code><\/pre>\n<p>What we can see in front of us might vary. There might be no Pods if Argo CD synchronization did not yet execute. There might be one Pod if Argo CD did synchronize, but HorizontalPodAutoscaler (HPA) did not yet do its job. Or there might already be two Pods. In any case, sooner or later, the actual state should stabilize, and there should be a minimum of two Pods given the lower limit set in the HPA.<\/p>\n<p>That&#8217;s it. We saw how to fully automate the creation, management, and destruction of preview environments based on events created through pull requests.<\/p>\n<p>We are victorious!<\/p>\n<p>Feel free to &#8220;play&#8221; with what we created. We&#8217;ll destroy everything once you&#8217;re done.<\/p>\n<h2>Destroying The Evidence<\/h2>\n<p>I prefer leaving no trace of my exercises once I&#8217;m finished. That follows my philosophy that we should always be ready to create everything we need and destroy the things that are of no use. Think of it as a &#8220;leave no trace, I was never there&#8221; type of approach. So, let&#8217;s destroy everything we created.<\/p>\n<p>Let&#8217;s start by getting out of the app repo.<\/p>\n<pre><code class=\"bash\">cd ..\r\n<\/code><\/pre>\n<p>Next, we&#8217;ll delete the pipelines we created.<\/p>\n<pre><code class=\"bash\">codefresh delete pipeline \\\r\n    devops-toolkit-pr-open\r\n\r\ncodefresh delete pipeline \\\r\n    devops-toolkit-pr-close\r\n<\/code><\/pre>\n<p>We&#8217;ll also remove the repositories you forked.<\/p>\n<pre><code class=\"bash\">open https:\/\/github.com\/$GH_ORG\/argocd-previews\/settings\r\n\r\n# Click the *Delete this repository* button and follow the instructions\r\n\r\nopen https:\/\/github.com\/$GH_ORG\/devops-toolkit\/settings\r\n\r\n# Click the *Delete this repository* button and follow the instructions\r\n<\/code><\/pre>\n<p>Next, there is no need to keep the local copies of the repos.<\/p>\n<pre><code class=\"bash\">rm -rf \\\r\n    devops-toolkit \\\r\n    argocd-previews\r\n<\/code><\/pre>\n<p>Finally, destroy the cluster itself, unless you are using it for other purposes. If you insist on keeping it, delete the Namespaces we created (e.g., <code>argocd<\/code>, <code>previews<\/code>, etc.).<\/p>\n<p>That&#8217;s it. We started from nothing, and we ended with nothing. It&#8217;s like we haven&#8217;t done anything. If there is no evidence, there is no trial.<\/p>\n<input class=\"fooboxshare_post_id\" type=\"hidden\" value=\"17926\"\/>","protected":false},"excerpt":{"rendered":"<p>Creating preview environments as a result of making pull requests is one of those practices that have vast potential and are yet largely overlooked. There is a strong chance that you are not using them, even though they can drastically increase productivity. I will not explain what preview environments are, besides stating that they are &hellip; <a href=\"https:\/\/codefresh.io\/continuous-deployment\/creating-temporary-preview-environments-based-pull-requests-argo-cd-codefresh\/\">Read more<\/a><\/p>\n","protected":false},"author":125,"featured_media":18078,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[3120,5467,1657,1505],"tags":[44,651,2954,3083,5506,5507,5515,5522,5523,5524,5538,5539,5540,5541],"yoast_head":"<!-- This site is optimized with the Yoast SEO Premium plugin v17.9 (Yoast SEO v18.4.1) - https:\/\/yoast.com\/wordpress\/plugins\/seo\/ -->\n<title>Create Temporary Argo CD Preview Environments Based On Pull Requests<\/title>\n<meta name=\"description\" content=\"Creating Argo CD preview environments as a result of making pull requests is one of those practices that have vast potential and are yet largely overlooked.\" \/>\n<meta name=\"robots\" content=\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\" \/>\n<link rel=\"canonical\" href=\"https:\/\/codefresh.io\/continuous-deployment\/creating-temporary-preview-environments-based-pull-requests-argo-cd-codefresh\/\" \/>\n<meta property=\"og:locale\" content=\"en_US\" \/>\n<meta property=\"og:type\" content=\"article\" \/>\n<meta property=\"og:title\" content=\"Creating Temporary Preview Environments Based On Pull Requests With Argo CD And Codefresh\" \/>\n<meta property=\"og:description\" content=\"Creating Argo CD preview environments as a result of making pull requests is one of those practices that have vast potential and are yet largely overlooked.\" \/>\n<meta property=\"og:url\" content=\"https:\/\/codefresh.io\/continuous-deployment\/creating-temporary-preview-environments-based-pull-requests-argo-cd-codefresh\/\" \/>\n<meta property=\"og:site_name\" content=\"Codefresh\" \/>\n<meta property=\"article:publisher\" content=\"https:\/\/www.facebook.com\/codefresh.io\" \/>\n<meta property=\"article:published_time\" content=\"2020-11-16T16:37:19+00:00\" \/>\n<meta property=\"article:modified_time\" content=\"2022-03-22T15:59:54+00:00\" \/>\n<meta property=\"og:image\" content=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/11\/creating-temporary-preview-environments.jpg\" \/>\n\t<meta property=\"og:image:width\" content=\"1492\" \/>\n\t<meta property=\"og:image:height\" content=\"496\" \/>\n\t<meta property=\"og:image:type\" content=\"image\/jpeg\" \/>\n<meta name=\"twitter:card\" content=\"summary_large_image\" \/>\n<meta name=\"twitter:creator\" content=\"@codefresh\" \/>\n<meta name=\"twitter:site\" content=\"@codefresh\" \/>\n<meta name=\"twitter:label1\" content=\"Written by\" \/>\n\t<meta name=\"twitter:data1\" content=\"Contributor\" \/>\n\t<meta name=\"twitter:label2\" content=\"Est. reading time\" \/>\n\t<meta name=\"twitter:data2\" content=\"37 minutes\" \/>\n<script type=\"application\/ld+json\" class=\"yoast-schema-graph\">{\"@context\":\"https:\/\/schema.org\",\"@graph\":[{\"@type\":\"Organization\",\"@id\":\"https:\/\/codefresh.io\/#organization\",\"name\":\"Codefresh\",\"url\":\"https:\/\/codefresh.io\/\",\"sameAs\":[\"https:\/\/www.facebook.com\/codefresh.io\",\"https:\/\/www.linkedin.com\/company\/codefresh\",\"https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg\",\"https:\/\/twitter.com\/codefresh\"],\"logo\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#logo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"width\":800,\"height\":800,\"caption\":\"Codefresh\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/#logo\"}},{\"@type\":\"WebSite\",\"@id\":\"https:\/\/codefresh.io\/#website\",\"url\":\"https:\/\/codefresh.io\/\",\"name\":\"Codefresh\",\"description\":\"\",\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"potentialAction\":[{\"@type\":\"SearchAction\",\"target\":{\"@type\":\"EntryPoint\",\"urlTemplate\":\"https:\/\/codefresh.io\/?s={search_term_string}\"},\"query-input\":\"required name=search_term_string\"}],\"inLanguage\":\"en-US\"},{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/continuous-deployment\/creating-temporary-preview-environments-based-pull-requests-argo-cd-codefresh\/#primaryimage\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/11\/creating-temporary-preview-environments.jpg\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/11\/creating-temporary-preview-environments.jpg\",\"width\":1492,\"height\":496},{\"@type\":\"WebPage\",\"@id\":\"https:\/\/codefresh.io\/continuous-deployment\/creating-temporary-preview-environments-based-pull-requests-argo-cd-codefresh\/#webpage\",\"url\":\"https:\/\/codefresh.io\/continuous-deployment\/creating-temporary-preview-environments-based-pull-requests-argo-cd-codefresh\/\",\"name\":\"Create Temporary Argo CD Preview Environments Based On Pull Requests\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/#website\"},\"primaryImageOfPage\":{\"@id\":\"https:\/\/codefresh.io\/continuous-deployment\/creating-temporary-preview-environments-based-pull-requests-argo-cd-codefresh\/#primaryimage\"},\"datePublished\":\"2020-11-16T16:37:19+00:00\",\"dateModified\":\"2022-03-22T15:59:54+00:00\",\"description\":\"Creating Argo CD preview environments as a result of making pull requests is one of those practices that have vast potential and are yet largely overlooked.\",\"breadcrumb\":{\"@id\":\"https:\/\/codefresh.io\/continuous-deployment\/creating-temporary-preview-environments-based-pull-requests-argo-cd-codefresh\/#breadcrumb\"},\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"ReadAction\",\"target\":[\"https:\/\/codefresh.io\/continuous-deployment\/creating-temporary-preview-environments-based-pull-requests-argo-cd-codefresh\/\"]}]},{\"@type\":\"BreadcrumbList\",\"@id\":\"https:\/\/codefresh.io\/continuous-deployment\/creating-temporary-preview-environments-based-pull-requests-argo-cd-codefresh\/#breadcrumb\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"name\":\"Home\",\"item\":\"https:\/\/codefresh.io\/\"},{\"@type\":\"ListItem\",\"position\":2,\"name\":\"Creating Temporary Preview Environments Based On Pull Requests With Argo CD And Codefresh\"}]},{\"@type\":\"Article\",\"@id\":\"https:\/\/codefresh.io\/continuous-deployment\/creating-temporary-preview-environments-based-pull-requests-argo-cd-codefresh\/#article\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/continuous-deployment\/creating-temporary-preview-environments-based-pull-requests-argo-cd-codefresh\/#webpage\"},\"author\":{\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/268e5c2e4740502fae6d803783a16c75\"},\"headline\":\"Creating Temporary Preview Environments Based On Pull Requests With Argo CD And Codefresh\",\"datePublished\":\"2020-11-16T16:37:19+00:00\",\"dateModified\":\"2022-03-22T15:59:54+00:00\",\"mainEntityOfPage\":{\"@id\":\"https:\/\/codefresh.io\/continuous-deployment\/creating-temporary-preview-environments-based-pull-requests-argo-cd-codefresh\/#webpage\"},\"wordCount\":6061,\"commentCount\":1,\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/continuous-deployment\/creating-temporary-preview-environments-based-pull-requests-argo-cd-codefresh\/#primaryimage\"},\"thumbnailUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/11\/creating-temporary-preview-environments.jpg\",\"keywords\":[\"Kubernetes\",\"K8s\",\"git\",\"github\",\"Argo CD\",\"ArgoCD\",\"tutorial\",\"pull requests\",\"pull request\",\"pr\",\"pull request environments\",\"PRs\",\"preview\",\"preview environment\"],\"articleSection\":[\"Continuous Deployment\/Delivery\",\"Devops\",\"Kubernetes Tutorials\",\"Containers\"],\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"CommentAction\",\"name\":\"Comment\",\"target\":[\"https:\/\/codefresh.io\/continuous-deployment\/creating-temporary-preview-environments-based-pull-requests-argo-cd-codefresh\/#respond\"]}]},{\"@type\":\"Person\",\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/268e5c2e4740502fae6d803783a16c75\",\"name\":\"Contributor\",\"image\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#personlogo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/secure.gravatar.com\/avatar\/26bd6dd87bf70f0c1a44721c8b3abbbd?s=96&d=blank&r=g\",\"contentUrl\":\"https:\/\/secure.gravatar.com\/avatar\/26bd6dd87bf70f0c1a44721c8b3abbbd?s=96&d=blank&r=g\",\"caption\":\"Contributor\"},\"url\":\"https:\/\/codefresh.io\/author\/contributor\/\"}]}<\/script>\n<!-- \/ Yoast SEO Premium plugin. -->","yoast_head_json":{"title":"Create Temporary Argo CD Preview Environments Based On Pull Requests","description":"Creating Argo CD preview environments as a result of making pull requests is one of those practices that have vast potential and are yet largely overlooked.","robots":{"index":"index","follow":"follow","max-snippet":"max-snippet:-1","max-image-preview":"max-image-preview:large","max-video-preview":"max-video-preview:-1"},"canonical":"https:\/\/codefresh.io\/continuous-deployment\/creating-temporary-preview-environments-based-pull-requests-argo-cd-codefresh\/","og_locale":"en_US","og_type":"article","og_title":"Creating Temporary Preview Environments Based On Pull Requests With Argo CD And Codefresh","og_description":"Creating Argo CD preview environments as a result of making pull requests is one of those practices that have vast potential and are yet largely overlooked.","og_url":"https:\/\/codefresh.io\/continuous-deployment\/creating-temporary-preview-environments-based-pull-requests-argo-cd-codefresh\/","og_site_name":"Codefresh","article_publisher":"https:\/\/www.facebook.com\/codefresh.io","article_published_time":"2020-11-16T16:37:19+00:00","article_modified_time":"2022-03-22T15:59:54+00:00","og_image":[{"width":1492,"height":496,"url":"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/11\/creating-temporary-preview-environments.jpg","type":"image\/jpeg"}],"twitter_card":"summary_large_image","twitter_creator":"@codefresh","twitter_site":"@codefresh","twitter_misc":{"Written by":"Contributor","Est. reading time":"37 minutes"},"schema":{"@context":"https:\/\/schema.org","@graph":[{"@type":"Organization","@id":"https:\/\/codefresh.io\/#organization","name":"Codefresh","url":"https:\/\/codefresh.io\/","sameAs":["https:\/\/www.facebook.com\/codefresh.io","https:\/\/www.linkedin.com\/company\/codefresh","https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg","https:\/\/twitter.com\/codefresh"],"logo":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#logo","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","width":800,"height":800,"caption":"Codefresh"},"image":{"@id":"https:\/\/codefresh.io\/#logo"}},{"@type":"WebSite","@id":"https:\/\/codefresh.io\/#website","url":"https:\/\/codefresh.io\/","name":"Codefresh","description":"","publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"potentialAction":[{"@type":"SearchAction","target":{"@type":"EntryPoint","urlTemplate":"https:\/\/codefresh.io\/?s={search_term_string}"},"query-input":"required name=search_term_string"}],"inLanguage":"en-US"},{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/continuous-deployment\/creating-temporary-preview-environments-based-pull-requests-argo-cd-codefresh\/#primaryimage","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/11\/creating-temporary-preview-environments.jpg","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/11\/creating-temporary-preview-environments.jpg","width":1492,"height":496},{"@type":"WebPage","@id":"https:\/\/codefresh.io\/continuous-deployment\/creating-temporary-preview-environments-based-pull-requests-argo-cd-codefresh\/#webpage","url":"https:\/\/codefresh.io\/continuous-deployment\/creating-temporary-preview-environments-based-pull-requests-argo-cd-codefresh\/","name":"Create Temporary Argo CD Preview Environments Based On Pull Requests","isPartOf":{"@id":"https:\/\/codefresh.io\/#website"},"primaryImageOfPage":{"@id":"https:\/\/codefresh.io\/continuous-deployment\/creating-temporary-preview-environments-based-pull-requests-argo-cd-codefresh\/#primaryimage"},"datePublished":"2020-11-16T16:37:19+00:00","dateModified":"2022-03-22T15:59:54+00:00","description":"Creating Argo CD preview environments as a result of making pull requests is one of those practices that have vast potential and are yet largely overlooked.","breadcrumb":{"@id":"https:\/\/codefresh.io\/continuous-deployment\/creating-temporary-preview-environments-based-pull-requests-argo-cd-codefresh\/#breadcrumb"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https:\/\/codefresh.io\/continuous-deployment\/creating-temporary-preview-environments-based-pull-requests-argo-cd-codefresh\/"]}]},{"@type":"BreadcrumbList","@id":"https:\/\/codefresh.io\/continuous-deployment\/creating-temporary-preview-environments-based-pull-requests-argo-cd-codefresh\/#breadcrumb","itemListElement":[{"@type":"ListItem","position":1,"name":"Home","item":"https:\/\/codefresh.io\/"},{"@type":"ListItem","position":2,"name":"Creating Temporary Preview Environments Based On Pull Requests With Argo CD And Codefresh"}]},{"@type":"Article","@id":"https:\/\/codefresh.io\/continuous-deployment\/creating-temporary-preview-environments-based-pull-requests-argo-cd-codefresh\/#article","isPartOf":{"@id":"https:\/\/codefresh.io\/continuous-deployment\/creating-temporary-preview-environments-based-pull-requests-argo-cd-codefresh\/#webpage"},"author":{"@id":"https:\/\/codefresh.io\/#\/schema\/person\/268e5c2e4740502fae6d803783a16c75"},"headline":"Creating Temporary Preview Environments Based On Pull Requests With Argo CD And Codefresh","datePublished":"2020-11-16T16:37:19+00:00","dateModified":"2022-03-22T15:59:54+00:00","mainEntityOfPage":{"@id":"https:\/\/codefresh.io\/continuous-deployment\/creating-temporary-preview-environments-based-pull-requests-argo-cd-codefresh\/#webpage"},"wordCount":6061,"commentCount":1,"publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"image":{"@id":"https:\/\/codefresh.io\/continuous-deployment\/creating-temporary-preview-environments-based-pull-requests-argo-cd-codefresh\/#primaryimage"},"thumbnailUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/11\/creating-temporary-preview-environments.jpg","keywords":["Kubernetes","K8s","git","github","Argo CD","ArgoCD","tutorial","pull requests","pull request","pr","pull request environments","PRs","preview","preview environment"],"articleSection":["Continuous Deployment\/Delivery","Devops","Kubernetes Tutorials","Containers"],"inLanguage":"en-US","potentialAction":[{"@type":"CommentAction","name":"Comment","target":["https:\/\/codefresh.io\/continuous-deployment\/creating-temporary-preview-environments-based-pull-requests-argo-cd-codefresh\/#respond"]}]},{"@type":"Person","@id":"https:\/\/codefresh.io\/#\/schema\/person\/268e5c2e4740502fae6d803783a16c75","name":"Contributor","image":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#personlogo","inLanguage":"en-US","url":"https:\/\/secure.gravatar.com\/avatar\/26bd6dd87bf70f0c1a44721c8b3abbbd?s=96&d=blank&r=g","contentUrl":"https:\/\/secure.gravatar.com\/avatar\/26bd6dd87bf70f0c1a44721c8b3abbbd?s=96&d=blank&r=g","caption":"Contributor"},"url":"https:\/\/codefresh.io\/author\/contributor\/"}]}},"acf":[],"_links":{"self":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/17926"}],"collection":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/users\/125"}],"replies":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/comments?post=17926"}],"version-history":[{"count":2,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/17926\/revisions"}],"predecessor-version":[{"id":21617,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/17926\/revisions\/21617"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media\/18078"}],"wp:attachment":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media?parent=17926"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/categories?post=17926"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/tags?post=17926"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}