{"id":18029,"date":"2020-11-14T01:34:20","date_gmt":"2020-11-14T09:34:20","guid":{"rendered":"https:\/\/codefresh.io\/?p=18029"},"modified":"2021-04-19T03:04:08","modified_gmt":"2021-04-19T11:04:08","slug":"pains-gitops-1-0","status":"publish","type":"post","link":"https:\/\/codefresh.io\/about-gitops\/pains-gitops-1-0\/","title":{"rendered":"The pains of GitOps 1.0"},"content":{"rendered":"<p>GitOps as a practice for releasing software has several advantages, but like all other solutions before it, has also several shortcomings. It seems that the honeymoon period is now over, and we can finally talk about the issues of GitOps (and the current generation of GitOps tools)<\/p>\n<p>In the article we will see the following pain points of GitOps:<\/p>\n<ol>\n<li>GitOps covers only a subset of the software lifecycle<\/li>\n<li>Splitting CI and CD with GitOps is not straightforward<\/li>\n<li>GitOps doesn\u2019t address promotion of releases between environments<\/li>\n<li>There is no standard practice for modeling multi-environment configurations<\/li>\n<li>GitOps breaks down with auto-scaling and dynamic resources<\/li>\n<li>There is no standard practice for GitOps rollbacks<\/li>\n<li>Observability for GitOps (and Git) is immature<\/li>\n<li>Auditing is problematic despite having all information in Git<\/li>\n<li>Running GitOps at scale is difficult<\/li>\n<li>GitOps and Helm do not always work well together<\/li>\n<li>Continuous Deployment and GitOps do not mix together<\/li>\n<li>There is no standard practice for managing secrets<\/li>\n<\/ol>\n<h2>GitOps tools cover only a subset of the software lifecycle<\/h2>\n<p>This is the running theme of the current crop of GitOp tools. Even though GitOps (the methodology) has some interesting characteristics and selling points, the current GitOps tools focus only on the deployment part of an application and nothing else. They solve the \u201cI want to put in my cluster what is described in Git\u201d problem, but all other aspects of software development are NOT covered:<\/p>\n<figure id=\"attachment_18030\" aria-describedby=\"caption-attachment-18030\" style=\"width: 1000px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/11\/subset.png\"><img class=\"size-full wp-image-18030\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/11\/subset.png\" alt=\"Gitops coverage\" width=\"1000\" height=\"514\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/11\/subset.png 1000w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/11\/subset-300x154.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/11\/subset-768x395.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/11\/subset-20x10.png 20w\" sizes=\"(max-width: 1000px) 100vw, 1000px\" \/><\/a><figcaption id=\"caption-attachment-18030\" class=\"wp-caption-text\">Gitops coverage<\/figcaption><\/figure>\n<p>I am mentioning this because GitOps tools are sometimes marketed as the one-size-fits-all solution that will solve all your release problems and this is simply not true. First of all, GitOps requires that your deployment artifacts are already there. This means that tasks such as:<\/p>\n<ul>\n<li>Compiling code<\/li>\n<li>Running unit\/integration tests<\/li>\n<li>Security scanning<\/li>\n<li>Static analysis<\/li>\n<\/ul>\n<p>are not a concern of GitOps tools and are assumed to already be in place.<\/p>\n<p>Even several deployment concerns (such as promotion between environments, secret handling, smoke testing) are conveniently left out of the GitOps paradigm, and teams that adopt GitOps need to create their own best practices for all aspects of software delivery.<\/p>\n<p>Therefore you cannot simply \u201cadopt a GitOps solution\u201d and call it a day. GitOps is only part of your whole development strategy and you should make sure that all other processes and workflows are ready to work with GitOps.<\/p>\n<h2>Splitting CI and CD with GitOps is not straightforward<\/h2>\n<p>GitOps has been heralded as a way to decouple CI from deployments. In the classic use of a CI\/CD system, the last step in the pipeline is a deployment step.<\/p>\n<figure id=\"attachment_18035\" aria-describedby=\"caption-attachment-18035\" style=\"width: 1024px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/11\/classic-pipeline.png\"><img class=\"size-large wp-image-18035\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/11\/classic-pipeline-1024x144.png\" alt=\"Classic pipeline\" width=\"1024\" height=\"144\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/11\/classic-pipeline-1024x144.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/11\/classic-pipeline-300x42.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/11\/classic-pipeline-768x108.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/11\/classic-pipeline-1536x216.png 1536w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/11\/classic-pipeline-20x3.png 20w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/11\/classic-pipeline.png 1618w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" \/><\/a><figcaption id=\"caption-attachment-18035\" class=\"wp-caption-text\">Classic pipeline<\/figcaption><\/figure>\n<p>With GitOps you can keep your CI process pristine (by just preparing a candidate release) and end it with a Git commit instead of a deployment. The Git commit is picked up by a deployment solution that monitors the Git repository and takes care of the actual deployment by pulling changes in your cluster (and thus making the cluster state the same as the Git state).<\/p>\n<p>This scenario is great in theory and is certainly applicable to simple scenarios, but it quickly breaks down when it comes to advanced deployments adopted by big organizations.<\/p>\n<p>The canonical example of mixing CI and CD is with smoke testing. Let\u2019s say that you want to run some smoke tests AFTER a deployment has finished and the result of the tests will decide if a rollback will take place or not.<\/p>\n<figure id=\"attachment_18037\" aria-describedby=\"caption-attachment-18037\" style=\"width: 978px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/11\/smoke-tests.png\"><img class=\"size-full wp-image-18037\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/11\/smoke-tests.png\" alt=\"Smoke tests\" width=\"978\" height=\"375\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/11\/smoke-tests.png 978w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/11\/smoke-tests-300x115.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/11\/smoke-tests-768x294.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/11\/smoke-tests-20x8.png 20w\" sizes=\"(max-width: 978px) 100vw, 978px\" \/><\/a><figcaption id=\"caption-attachment-18037\" class=\"wp-caption-text\">Smoke tests<\/figcaption><\/figure>\n<p>As I said in the previous point, GitOps deals only with deployment artifacts and normally does not touch (or know about) source code. But in most cases, in order to run unit tests, you need access to the source code of the application.<\/p>\n<p>The current crop of GitOps tools cannot run unit\/integration tests. That would require visibility in the source code along with all the testing frameworks and libraries needed for the tests. This means that you are forced to use your CI solution again in order to run the smoke tests.<\/p>\n<p>The end result is a mixture of CI-CD-CI-CD components that goes against the main spirit of GitOps. There are also several underlying issues such as not knowing exactly when your environment has finished with the deployment in order to trigger the tests.<\/p>\n<p>The same scenario is trivial to execute with a traditional CI\/CD pipeline.<\/p>\n<h2>GitOps doesn\u2019t address promotion of releases between environments<\/h2>\n<p>This is probably one of the most well-known issues with GitOps and one of the first topics discussed when it comes to how GitOps can work in big organizations.<\/p>\n<figure id=\"attachment_18038\" aria-describedby=\"caption-attachment-18038\" style=\"width: 851px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/11\/promotion.png\"><img class=\"size-full wp-image-18038\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/11\/promotion.png\" alt=\"Environment promotion\" width=\"851\" height=\"218\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/11\/promotion.png 851w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/11\/promotion-300x77.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/11\/promotion-768x197.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/11\/promotion-20x5.png 20w\" sizes=\"(max-width: 851px) 100vw, 851px\" \/><\/a><figcaption id=\"caption-attachment-18038\" class=\"wp-caption-text\">Environment promotion<\/figcaption><\/figure>\n<p>The basic scenario for one environment is obvious. You merge (or create a commit) in Git, and your cluster for environment X is now getting the new version. But how do you promote this release to environment Y?<\/p>\n<p>Every time somebody declares that adopting GitOps is an easy process, I always ask how promotion between different environments works in their case. And I always get different answers:<\/p>\n<ol>\n<li>\u201cWe use our CI system to do this.\u201d This means that you are again mixing CI with CD and you admit that GitOps does not cover this scenario.<\/li>\n<li>\u201cWe open a new pull request to the other environment.\u201d This means that you are forced to have different Git branches for each environment (more on this later) and you also introduce further manual steps just for release promotion.<\/li>\n<li>\u201cWe only have one environment.\u201d Great for small companies, but not feasible in other cases.<\/li>\n<\/ol>\n<p>I am really disappointed that even the <a href=\"https:\/\/www.gitops.tech\/\">page specifically created for addressing GitOps<\/a> questions says:<\/p>\n<p>\u201cGitOps doesn\u2019t provide a solution to propagating changes from one stage to the next one. We recommend using only a single environment and avoid stage propagation altogether.\u201d<\/p>\n<p>The most popular way of handling different environments seems to be by using different Git branches. This solution has several disadvantages:<\/p>\n<ul>\n<li>It opens the gates for people to do commits to specific branches and include environment-specific code.<\/li>\n<li>It makes your project coupled to specific environments (instead of being generic).<\/li>\n<li>It requires extra effort to keep all branches in sync (in case of hotfixes or configuration changes).<\/li>\n<li>It puts unnecessary strain on the CI system that has to check\/rebuild\/unit test each individual branch.<\/li>\n<\/ul>\n<p>Also, if you have a large number of environments, handling multiple branches can get quickly out of hand.<\/p>\n<h2>There is no standard practice for modeling multi-environment configurations<\/h2>\n<p>A corollary to the previous point is that if your software strategy requires multi-environment deployments, GitOps cannot help you in any way. In fact, it will make things harder for you by forcing you to adopt a specific Git branching pattern (branch per environment).<\/p>\n<p>A classic example is when you have different environments per geographical region (per continent or per country).<\/p>\n<p>Let\u2019s say that my application is deployed to 10 countries and I want to promote a release to one after the other. What is the GitOps solution?<\/p>\n<ul>\n<li>A single repository with 10 branches. This means that you need to open\/close 10 pull requests each time you do a release.<\/li>\n<li>10 Git repositories. This means that you need to write your own solution that copies commits between the repositories (or uses Pull Requests between them).<\/li>\n<li>A single Git repository with 10 subfolders. Again you need an external solution to make sure that changes are propagated between folders.<\/li>\n<\/ul>\n<p>In all cases, the promotion process is very cumbersome and <a href=\"https:\/\/github.com\/fluxcd\/flux\/issues\/1071\">current GitOps tools do not have an easy answer<\/a> on what is the correct approach.<\/p>\n<h2>GitOps breaks down with auto-scaling and dynamic resources<\/h2>\n<p>One of the critical points in GitOps is that after a deployment has finished the cluster state is EXACTLY the same as what is described in the Git repository.<\/p>\n<p>This is true in most simple cases, but as soon as you have dynamic values in your manifests, your GitOps tool will start fighting against you. Some classic examples are:<\/p>\n<ul>\n<li>The replica count if you have an autoscaler in your cluster<\/li>\n<li>The resource limits if you have an optimizer in your cluster<\/li>\n<li>Several other extra properties added by external tools (especially values with dates or timestamps)<\/li>\n<\/ul>\n<p>As soon as your cluster state changes, your GitOps tool will try to sync the initial value from Git and in most cases, this is not what you want.<\/p>\n<figure id=\"attachment_18039\" aria-describedby=\"caption-attachment-18039\" style=\"width: 1024px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/11\/diff.png\"><img class=\"size-large wp-image-18039\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/11\/diff-1024x571.png\" alt=\"State difference\" width=\"1024\" height=\"571\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/11\/diff-1024x571.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/11\/diff-300x167.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/11\/diff-768x428.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/11\/diff-20x11.png 20w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/11\/diff.png 1280w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" \/><\/a><figcaption id=\"caption-attachment-18039\" class=\"wp-caption-text\">State difference<\/figcaption><\/figure>\n<p>Argo supports <a href=\"https:\/\/argoproj.github.io\/argo-cd\/user-guide\/diffing\/\">custom diffs<\/a> and Flux<a href=\"https:\/\/docs.fluxcd.io\/en\/1.17.0\/faq.html#how-can-i-prevent-flux-overriding-the-replicas-when-using-hpa\"> has a recommendation<\/a> but I consider these workarounds as simple hacks that move away from the main GitOps promise and <a href=\"https:\/\/github.com\/argoproj\/argo-cd\/issues\/2913\">create several other issues<\/a> in the long run.<\/p>\n<h2>There is no standard practice for GitOps rollbacks<\/h2>\n<p>The fact that all your cluster history is in Git makes rollbacks in GitOps (supposedly) very easy.<br \/>\nIf you want to rollback to a previous version, you simply use a past commit for your sync operation.<\/p>\n<p>In practice, however, it is not entirely clear what exactly we mean by \u201cuse a previous commit\u201d. Different people use different ways to rollback:<\/p>\n<ol>\n<li>You can simply point your cluster to a previous Git hash and let your GitOps tool sync that hash. This is the fastest way to rollback, but by definition leaves your cluster in an inconsistent state as the cluster does not contain what is described in the last Git commit.<\/li>\n<li>You can use the standard Git reset, Git revert commands, and again let your GitOps tool perform the sync operation as usual. This keeps the GitOps promise (of having in the cluster what is in the Git repo) but of course, requires manual intervention.<\/li>\n<li>You can have a combination where the GitOps tool itself both syncs a previous Git hash to the cluster and auto-commits (or reverts) to the git repo in order to keep the consistency. This is very complex to accomplish and not all teams want to let their deployment solution have write access to their Git repo.<\/li>\n<\/ol>\n<p>It goes without saying that different people might want a completely different approach for rollbacks. At the time of writing, however, the present GitOps tools have very little support and guidance on how you perform a rollback in a standard way.<\/p>\n<h2>Observability for GitOps (and Git) is immature<\/h2>\n<p>GitOps is great for looking at your cluster state having the guarantee that it matches your Git state. Git hashes and commits however are only useful to developers and operators. Business stakeholders have no interest in which Git hash is now deployed at the cluster.<\/p>\n<p>Therefore, while GitOps is great for observability on a technical level, it is important to remember that some of the most useful questions in a software team are the following:<\/p>\n<ul>\n<li>Does our production environment contain feature X?<\/li>\n<li>Has feature X cleared our staging environment?<\/li>\n<li>Are bugs X, Y present only in staging or also in production as well?<\/li>\n<\/ul>\n<p>These kinds of questions are pretty important for most product owners and project managers and finding an answer should be as quick as possible.<\/p>\n<p>Currently, GitOps tools work at the lowest level (i.e. Git hash) and don\u2019t have any connections to the business value of each deployment. It is up to developers\/operators to find the correlation between a production deployment and the value it brings to the business.<\/p>\n<p>At their current state, GitOps tools are great for observing the content of a cluster on a technical level but fail miserably on monitoring the business metrics of each deployment.<\/p>\n<h2>Auditing is problematic despite having all information in Git<\/h2>\n<p>A corollary to the previous point is that just because you have access to the whole deployment history of a cluster in the form of Git commits, doesn\u2019t mean that you can easily audit its functionality.<\/p>\n<p>The current crop of Git tools are great for managing Git hashes but when it comes to searching and understanding business value, they can only provide simple free-text search capabilities as Adam mentioned already in <a href=\"https:\/\/blog.container-solutions.com\/gitops-the-bad-and-the-ugly\">Lack of Visibility<\/a>.<\/p>\n<p>Let\u2019s say that you are using GitOps for a specific project and you know that the Git history matches your cluster history. How quickly can you answer the following questions just by looking at the Git History?<\/p>\n<ul>\n<li>How long did feature X stay in the staging environment before going to production?<\/li>\n<li>What is the worst, best, and average lead time (period starting from a developer performing a commit until the time it actually reached production) of the previous 2 months?<\/li>\n<li>What percentage of deployments to environment X were successful and what had to be rolled back?<\/li>\n<li>How many features exist in environment X but are not in environment Y yet?<\/li>\n<\/ul>\n<p>These questions are very common in a large software team and unless you have a specialized tool on top of your deployment platform, it is very hard to answer them by only having access to a Git repository and its history.<\/p>\n<h2>Running GitOps at scale is difficult<\/h2>\n<p>This point was also touched by Adam in the part \u201c<a href=\"https:\/\/blog.container-solutions.com\/gitops-the-bad-and-the-ugly\">the proliferation of Git repositories<\/a>\u201d. If you adopt GitOps in a large company with a big number of environments and applications, the number of Git repositories quickly skyrockets.<\/p>\n<p>This makes it very hard to keep track of what is going on in each environment and can quickly lead to configuration duplication or people making commits to specific environments (instead of using shared configuration).<\/p>\n<p>For example, if you have 20 git repositories with Kubernetes manifests and you need to make a central change (e.g. adding a new company-wide label on each deployment) you need to manually make 20 Git commits or create some glue code that does it for you.<\/p>\n<p>On the other end of the spectrum, you could have a single Git repository for all environments (or clusters) where all people collaborate along with the CI\/CD systems.<br \/>\nThis creates the problem of Git conflicts (where your git repos are touched by many CI processes and pushes are failing because the git repository was changed in between) as already explained by Adam.<\/p>\n<p>Having also a single gigantic Git repository can quickly become a bottleneck in your GitOps processes introducing performance issues when the repository is scanned for changes.<\/p>\n<h2>GitOps and Helm do not always work well together<\/h2>\n<p>Helm is the package manager for Kubernetes and is typically seen as the de-facto standard for deploying 3rd party applications in your cluster. It can also be used for your own deployments.<\/p>\n<p>Helm works by marrying a set of templates for Kubernetes manifests along with their runtime values that are merged to create the end result of what is deployed in the cluster.<\/p>\n<p>While you can provide a values.yml file on the fly when a Helm release is installed, a best practice is to also commit the values file to Git. You can have different value values for each environment (e.g. qa\/staging\/production).<\/p>\n<p>Helm on its own does not dictate where those 3 components (source code, manifests, values) should reside. You can keep all of them in the same Git repository or 3 different repositories. The accepted practice however is that if you have values for different environments, you don\u2019t keep them in the same place as the templates. The templates (the chart itself) is stored in a chart repository and the specific values for each environment are stored in a git repository.<\/p>\n<p>This means that during a deployment the following must happen:<\/p>\n<ol>\n<li>The chart should be downloaded from the chart repository<\/li>\n<li>The values should be fetched from a Git repository<\/li>\n<li>The values and the chart should be merged in order to create a set of Kubernetes manifests<\/li>\n<li>The manifests should be applied to the cluster.<\/li>\n<\/ol>\n<p>This is only for the initial deployment. Following the GitOps paradigm, the Git repository that contains the values file should be monitored along with the chart that exists in the chart repo. If their merge result is different from the cluster state a new deployment should take place.<\/p>\n<p>At the time of writing, neither <a href=\"https:\/\/docs.fluxcd.io\/projects\/helm-operator\/en\/latest\/helmrelease-guide\/automation\/#helm-repository-chart-updates\">Flux <\/a>nor <a href=\"https:\/\/github.com\/argoproj\/argo-cd\/issues\/2789\">ArgoCD<\/a> support this basic Helm scenario. There are several workarounds and limitations that you have to accept if you wish to use GitOps with Helm charts making the process much more complex than needed.<\/p>\n<h2>Continuous Deployment and GitOps do not mix together<\/h2>\n<p>GitOps is great as a Continuous Delivery solution, where each commit results in a release candidate ready to be pushed in production. Continuous deployment on the other hand is the full journey of a commit straight into production <a href=\"https:\/\/codefresh.io\/continuous-deployment\/heck-continuous-integration-ci-delivery-cd-deployment-cdp\/\">without any human intervention<\/a>.<\/p>\n<p>You are practicing Continuous Deployment if as a developer you can commit something Friday afternoon and then immediately start your weekend. In a few minutes, your commit should land in production after it passes all quality gates and tests.<\/p>\n<p>GitOps by definition is powered by Pull requests on a repository that contains your manifests. And in most cases, a human needs to look and approve these pull requests. This means that practicing GitOps involves at least some manual steps for handling these Pull requests.<br \/>\nIn theory, one could practice Continuous Deployment while still adopting GitOps by fully automating the Pull request part. Current GitOps (and Git) tools are not however created with this automation in mind, so you are on your own if you want to take this route.<\/p>\n<p>Remember that Continuous Deployment is not the holy grail. For several organizations, Continuous Delivery is already enough and in some cases, you might even be bound by legislation and have to specifically disallow fully automated deployments.<\/p>\n<p>But if you want to have the faster lead time possible, GitOps is not the best solution out there.<\/p>\n<h2>There is no standard practice for managing secrets with GitOps<\/h2>\n<p>This is a very well known problem with GitOps, so I am including it for completeness. Secret handling is one of the most important aspects of software deployment and yet, GitOps does not address them.<\/p>\n<p>There is no single accepted practice on how secrets should be managed. If they are stored in Git, they need to be encrypted and thus have their own workflow process during a deployment. If they are not stored in Git, then the whole idea of having your cluster state the same as Git is not true anymore.<\/p>\n<p>Secrets management is one of those areas where each company does their own thing, so at the very least I would expect GitOps tools to offer an out of the box solution for them.<\/p>\n<h2>Moving to GitOps 2.0<\/h2>\n<p>You might have noticed the version at the title of this article. GitOps in its present state is affected by all issues we outlined. But it doesn\u2019t have to be this way forever!<\/p>\n<p>As with normal software releases, we can continuously iterate on our approach and improve the shortcomings in subsequent versions. This is why we (at Codefresh) already <a href=\"https:\/\/codefresh.io\/devops\/vision-gitops-2-0\/\">envision a new version of GitOps<\/a> (named 2.0) which will become the next chapter in the GitOps saga and address all the present issues.<\/p>\n<p>Cover photo by <a href=\"https:\/\/unsplash.com\/photos\/36Vbwo1OiZU\">Unsplash<\/a>.<\/p>\n<input class=\"fooboxshare_post_id\" type=\"hidden\" value=\"18029\"\/>","protected":false},"excerpt":{"rendered":"<p>GitOps as a practice for releasing software has several advantages, but like all other solutions before it, has also several shortcomings. It seems that the honeymoon period is now over, and we can finally talk about the issues of GitOps (and the current generation of GitOps tools) In the article we will see the following &hellip; <a href=\"https:\/\/codefresh.io\/about-gitops\/pains-gitops-1-0\/\">Read more<\/a><\/p>\n","protected":false},"author":62,"featured_media":18042,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[5467,5703],"tags":[4322],"yoast_head":"<!-- This site is optimized with the Yoast SEO Premium plugin v17.9 (Yoast SEO v18.4.1) - https:\/\/yoast.com\/wordpress\/plugins\/seo\/ -->\n<title>The pains of GitOps 1.0 | Codefresh<\/title>\n<meta name=\"robots\" content=\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\" \/>\n<link rel=\"canonical\" href=\"https:\/\/codefresh.io\/about-gitops\/pains-gitops-1-0\/\" \/>\n<meta property=\"og:locale\" content=\"en_US\" \/>\n<meta property=\"og:type\" content=\"article\" \/>\n<meta property=\"og:title\" content=\"The pains of GitOps 1.0\" \/>\n<meta property=\"og:description\" content=\"GitOps as a practice for releasing software has several advantages, but like all other solutions before it, has also several shortcomings. It seems that the honeymoon period is now over, and we can finally talk about the issues of GitOps (and the current generation of GitOps tools) In the article we will see the following &hellip; Read more\" \/>\n<meta property=\"og:url\" content=\"https:\/\/codefresh.io\/about-gitops\/pains-gitops-1-0\/\" \/>\n<meta property=\"og:site_name\" content=\"Codefresh\" \/>\n<meta property=\"article:publisher\" content=\"https:\/\/www.facebook.com\/codefresh.io\" \/>\n<meta property=\"article:published_time\" content=\"2020-11-14T09:34:20+00:00\" \/>\n<meta property=\"article:modified_time\" content=\"2021-04-19T11:04:08+00:00\" \/>\n<meta property=\"og:image\" content=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/11\/blog-picture.jpg\" \/>\n\t<meta property=\"og:image:width\" content=\"1024\" \/>\n\t<meta property=\"og:image:height\" content=\"340\" \/>\n\t<meta property=\"og:image:type\" content=\"image\/jpeg\" \/>\n<meta name=\"twitter:card\" content=\"summary_large_image\" \/>\n<meta name=\"twitter:creator\" content=\"@codefresh\" \/>\n<meta name=\"twitter:site\" content=\"@codefresh\" \/>\n<meta name=\"twitter:label1\" content=\"Written by\" \/>\n\t<meta name=\"twitter:data1\" content=\"Kostis Kapelonis\" \/>\n\t<meta name=\"twitter:label2\" content=\"Est. reading time\" \/>\n\t<meta name=\"twitter:data2\" content=\"16 minutes\" \/>\n<script type=\"application\/ld+json\" class=\"yoast-schema-graph\">{\"@context\":\"https:\/\/schema.org\",\"@graph\":[{\"@type\":\"Organization\",\"@id\":\"https:\/\/codefresh.io\/#organization\",\"name\":\"Codefresh\",\"url\":\"https:\/\/codefresh.io\/\",\"sameAs\":[\"https:\/\/www.facebook.com\/codefresh.io\",\"https:\/\/www.linkedin.com\/company\/codefresh\",\"https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg\",\"https:\/\/twitter.com\/codefresh\"],\"logo\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#logo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"width\":800,\"height\":800,\"caption\":\"Codefresh\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/#logo\"}},{\"@type\":\"WebSite\",\"@id\":\"https:\/\/codefresh.io\/#website\",\"url\":\"https:\/\/codefresh.io\/\",\"name\":\"Codefresh\",\"description\":\"\",\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"potentialAction\":[{\"@type\":\"SearchAction\",\"target\":{\"@type\":\"EntryPoint\",\"urlTemplate\":\"https:\/\/codefresh.io\/?s={search_term_string}\"},\"query-input\":\"required name=search_term_string\"}],\"inLanguage\":\"en-US\"},{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/about-gitops\/pains-gitops-1-0\/#primaryimage\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/11\/blog-picture.jpg\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/11\/blog-picture.jpg\",\"width\":1024,\"height\":340},{\"@type\":\"WebPage\",\"@id\":\"https:\/\/codefresh.io\/about-gitops\/pains-gitops-1-0\/#webpage\",\"url\":\"https:\/\/codefresh.io\/about-gitops\/pains-gitops-1-0\/\",\"name\":\"The pains of GitOps 1.0 | Codefresh\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/#website\"},\"primaryImageOfPage\":{\"@id\":\"https:\/\/codefresh.io\/about-gitops\/pains-gitops-1-0\/#primaryimage\"},\"datePublished\":\"2020-11-14T09:34:20+00:00\",\"dateModified\":\"2021-04-19T11:04:08+00:00\",\"breadcrumb\":{\"@id\":\"https:\/\/codefresh.io\/about-gitops\/pains-gitops-1-0\/#breadcrumb\"},\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"ReadAction\",\"target\":[\"https:\/\/codefresh.io\/about-gitops\/pains-gitops-1-0\/\"]}]},{\"@type\":\"BreadcrumbList\",\"@id\":\"https:\/\/codefresh.io\/about-gitops\/pains-gitops-1-0\/#breadcrumb\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"name\":\"Home\",\"item\":\"https:\/\/codefresh.io\/\"},{\"@type\":\"ListItem\",\"position\":2,\"name\":\"The pains of GitOps 1.0\"}]},{\"@type\":\"Article\",\"@id\":\"https:\/\/codefresh.io\/about-gitops\/pains-gitops-1-0\/#article\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/about-gitops\/pains-gitops-1-0\/#webpage\"},\"author\":{\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87\"},\"headline\":\"The pains of GitOps 1.0\",\"datePublished\":\"2020-11-14T09:34:20+00:00\",\"dateModified\":\"2021-04-19T11:04:08+00:00\",\"mainEntityOfPage\":{\"@id\":\"https:\/\/codefresh.io\/about-gitops\/pains-gitops-1-0\/#webpage\"},\"wordCount\":3158,\"commentCount\":2,\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/about-gitops\/pains-gitops-1-0\/#primaryimage\"},\"thumbnailUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/11\/blog-picture.jpg\",\"keywords\":[\"GitOps\"],\"articleSection\":[\"Devops\",\"GitOps\"],\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"CommentAction\",\"name\":\"Comment\",\"target\":[\"https:\/\/codefresh.io\/about-gitops\/pains-gitops-1-0\/#respond\"]}]},{\"@type\":\"Person\",\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87\",\"name\":\"Kostis Kapelonis\",\"image\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#personlogo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png\",\"caption\":\"Kostis Kapelonis\"},\"description\":\"Kostis is a software engineer\/technical-writer dual class character. He lives and breathes automation, good testing practices and stress-free deployments with GitOps.\",\"url\":\"https:\/\/codefresh.io\/author\/kostiscodefresh-io\/\"}]}<\/script>\n<!-- \/ Yoast SEO Premium plugin. -->","yoast_head_json":{"title":"The pains of GitOps 1.0 | Codefresh","robots":{"index":"index","follow":"follow","max-snippet":"max-snippet:-1","max-image-preview":"max-image-preview:large","max-video-preview":"max-video-preview:-1"},"canonical":"https:\/\/codefresh.io\/about-gitops\/pains-gitops-1-0\/","og_locale":"en_US","og_type":"article","og_title":"The pains of GitOps 1.0","og_description":"GitOps as a practice for releasing software has several advantages, but like all other solutions before it, has also several shortcomings. It seems that the honeymoon period is now over, and we can finally talk about the issues of GitOps (and the current generation of GitOps tools) In the article we will see the following &hellip; Read more","og_url":"https:\/\/codefresh.io\/about-gitops\/pains-gitops-1-0\/","og_site_name":"Codefresh","article_publisher":"https:\/\/www.facebook.com\/codefresh.io","article_published_time":"2020-11-14T09:34:20+00:00","article_modified_time":"2021-04-19T11:04:08+00:00","og_image":[{"width":1024,"height":340,"url":"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/11\/blog-picture.jpg","type":"image\/jpeg"}],"twitter_card":"summary_large_image","twitter_creator":"@codefresh","twitter_site":"@codefresh","twitter_misc":{"Written by":"Kostis Kapelonis","Est. reading time":"16 minutes"},"schema":{"@context":"https:\/\/schema.org","@graph":[{"@type":"Organization","@id":"https:\/\/codefresh.io\/#organization","name":"Codefresh","url":"https:\/\/codefresh.io\/","sameAs":["https:\/\/www.facebook.com\/codefresh.io","https:\/\/www.linkedin.com\/company\/codefresh","https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg","https:\/\/twitter.com\/codefresh"],"logo":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#logo","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","width":800,"height":800,"caption":"Codefresh"},"image":{"@id":"https:\/\/codefresh.io\/#logo"}},{"@type":"WebSite","@id":"https:\/\/codefresh.io\/#website","url":"https:\/\/codefresh.io\/","name":"Codefresh","description":"","publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"potentialAction":[{"@type":"SearchAction","target":{"@type":"EntryPoint","urlTemplate":"https:\/\/codefresh.io\/?s={search_term_string}"},"query-input":"required name=search_term_string"}],"inLanguage":"en-US"},{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/about-gitops\/pains-gitops-1-0\/#primaryimage","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/11\/blog-picture.jpg","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/11\/blog-picture.jpg","width":1024,"height":340},{"@type":"WebPage","@id":"https:\/\/codefresh.io\/about-gitops\/pains-gitops-1-0\/#webpage","url":"https:\/\/codefresh.io\/about-gitops\/pains-gitops-1-0\/","name":"The pains of GitOps 1.0 | Codefresh","isPartOf":{"@id":"https:\/\/codefresh.io\/#website"},"primaryImageOfPage":{"@id":"https:\/\/codefresh.io\/about-gitops\/pains-gitops-1-0\/#primaryimage"},"datePublished":"2020-11-14T09:34:20+00:00","dateModified":"2021-04-19T11:04:08+00:00","breadcrumb":{"@id":"https:\/\/codefresh.io\/about-gitops\/pains-gitops-1-0\/#breadcrumb"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https:\/\/codefresh.io\/about-gitops\/pains-gitops-1-0\/"]}]},{"@type":"BreadcrumbList","@id":"https:\/\/codefresh.io\/about-gitops\/pains-gitops-1-0\/#breadcrumb","itemListElement":[{"@type":"ListItem","position":1,"name":"Home","item":"https:\/\/codefresh.io\/"},{"@type":"ListItem","position":2,"name":"The pains of GitOps 1.0"}]},{"@type":"Article","@id":"https:\/\/codefresh.io\/about-gitops\/pains-gitops-1-0\/#article","isPartOf":{"@id":"https:\/\/codefresh.io\/about-gitops\/pains-gitops-1-0\/#webpage"},"author":{"@id":"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87"},"headline":"The pains of GitOps 1.0","datePublished":"2020-11-14T09:34:20+00:00","dateModified":"2021-04-19T11:04:08+00:00","mainEntityOfPage":{"@id":"https:\/\/codefresh.io\/about-gitops\/pains-gitops-1-0\/#webpage"},"wordCount":3158,"commentCount":2,"publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"image":{"@id":"https:\/\/codefresh.io\/about-gitops\/pains-gitops-1-0\/#primaryimage"},"thumbnailUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/11\/blog-picture.jpg","keywords":["GitOps"],"articleSection":["Devops","GitOps"],"inLanguage":"en-US","potentialAction":[{"@type":"CommentAction","name":"Comment","target":["https:\/\/codefresh.io\/about-gitops\/pains-gitops-1-0\/#respond"]}]},{"@type":"Person","@id":"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87","name":"Kostis Kapelonis","image":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#personlogo","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png","caption":"Kostis Kapelonis"},"description":"Kostis is a software engineer\/technical-writer dual class character. He lives and breathes automation, good testing practices and stress-free deployments with GitOps.","url":"https:\/\/codefresh.io\/author\/kostiscodefresh-io\/"}]}},"acf":[],"_links":{"self":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/18029"}],"collection":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/users\/62"}],"replies":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/comments?post=18029"}],"version-history":[{"count":0,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/18029\/revisions"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media\/18042"}],"wp:attachment":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media?parent=18029"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/categories?post=18029"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/tags?post=18029"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}