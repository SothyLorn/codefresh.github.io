{"id":18194,"date":"2020-12-07T04:02:51","date_gmt":"2020-12-07T12:02:51","guid":{"rendered":"https:\/\/codefresh.io\/?p=18194"},"modified":"2021-04-19T03:07:20","modified_gmt":"2021-04-19T11:07:20","slug":"combining-progressive-delivery-gitops-continuous-delivery-argo-cd-argo-rollouts-codefresh","status":"publish","type":"post","link":"https:\/\/codefresh.io\/about-gitops\/combining-progressive-delivery-gitops-continuous-delivery-argo-cd-argo-rollouts-codefresh\/","title":{"rendered":"Combining Progressive Delivery With GitOps and Continuous Delivery Through Argo CD, Argo Rollouts, and Codefresh"},"content":{"rendered":"<p>Progressive delivery is arguably the most reliable and advanced set of deployment practices based on a simple idea. Instead of shutting down the old release and deploying a new one in its place, progressive delivery takes an iterative approach. It gradually increases the reach of a new release. That gives us quite a few benefits like zero-downtime deployments, reduced blast radius, increased security, and so on and so forth.<\/p>\n<p>I will not go into depth about what progressive delivery is. Instead, I will assume that you are already familiar with it. If that&#8217;s not the case, please watch <a href=\"https:\/\/youtu.be\/HKkhD6nokC8\">Progressive Delivery Explained &#8211; Big Bang (Recreate), Blue-Green, Rolling Updates, Canaries<\/a>.<\/p>\n<p>Today, we are going to go further than merely applying progressive delivery alone. Instead, we will combine it with GitOps and wrap it all up in a continuous delivery pipeline. Just as with progressive delivery, I will assume that you do understand what those are. If you don&#8217;t, please watch <a href=\"https:\/\/youtu.be\/qwyRJlmG5ew\">What Is GitOps And Why Do We Want It?<\/a> and <a href=\"https:\/\/youtu.be\/hxJP1JoG4zM\">Continuous Delivery (CD) Is Not What Some Are Trying To Sell You<\/a>.<\/p>\n<p>Now, before we embark on a quest to combine those three practices, we&#8217;ll need to pick the tools we will use.<\/p>\n<p>We&#8217;ll choose <a href=\"https:\/\/youtu.be\/84Ky0aPbHvY\">Argo Rollouts<\/a> for progressive delivery, <a href=\"https:\/\/youtu.be\/vpWQeoaiRM4\">Argo CD<\/a> for GitOps style of deployments, and <a href=\"https:\/\/codefresh.io\/codefresh-signup\/?utm_source=Blog&amp;utm_medium=Post&amp;utm_campaign=vfarcic-progressive\">Codefresh<\/a> for continuous delivery pipelines. Follow the links if you&#8217;re not familiar with any of them.<\/p>\n<p>Finally, we&#8217;ll need to pick a progressive delivery strategy we will use. Today that will be canary deployments, even though the examples should apply to any other flavor with only a few minor tweaks.<\/p>\n<p>That&#8217;s it. Off we go.<\/p>\n<h2>Discussing The Pre-Requirements<\/h2>\n<p>The first thing we&#8217;ll need is a Kubernetes cluster. Create it any way you like. It can be a &#8220;real&#8221; cluster in Cloud providers like AWS EKS, Google Cloud GKE, or Azure AKS. It can also be on-prem, or it can be a local cluster like Minikube or Docker Desktop. It does not matter how you create a cluster, as long as you have one that can be used for the exercises that follow.<\/p>\n<p>Further on, we&#8217;ll use Istio service mesh. It could have been ALB, NGINX Ingress, or any implementation of Service Mesh Interface (SMI) like, for example, LinkerD. I chose Istio mostly because I had to pick something, and Istio is the one I use a lot lately.<\/p>\n<p>So, go ahead and install <a href=\"https:\/\/argoproj.github.io\/argo-cd\/getting_started\/\">Argo CD<\/a> and <a href=\"https:\/\/istio.io\/latest\/docs\/setup\/\">Istio<\/a> if you do not have them already running in your cluster. Once you do, make sure to get the IP through which <code>istio-ingressgateway<\/code> is accessible and store it in environment variable <code>ISTIO_HOST<\/code>. We&#8217;ll need it later when we generate the address through which we should be able to reach the application we are about to deploy.<\/p>\n<p><em>If you are a Windows user, I will assume that you are running the commands from a Bourne Again Shell (Bash) or a Z Shell (Zsh) and not PowerShell. That should not be a problem if you followed the instructions on setting up Windows Subsystem for Linux (WSL) explained in the <a href=\"https:\/\/youtu.be\/zSqugKeOa1Y\">Installing Windows Subsystem For Linux (WSL)<\/a> YouTube video. If you do not like WSL, a Bash emulator like GitBash should do. If none of those is an acceptable option, you might need to modify some of the commands in the examples that follow.<\/em><\/p>\n<p><em>All the commands are available in the <a href=\"https:\/\/gist.github.com\/8b4d3350bb42d5d2b82f1b11786767c2\">progressive.sh<\/a> Gist. Feel free to use it if you&#8217;re too lazy to type. There&#8217;s no shame in copy &amp; paste.<\/em><\/p>\n<p>That&#8217;s it. Those are all the pre-requirements. Now we are ready to set up the production cluster or, to be more precise, a simulation of production. That will be the first use-case for GitOps through Argo CD.<\/p>\n<h2>Setting Up Production<\/h2>\n<p>Since we are applying GitOps principles, everything is defined as code, and code is stored in Git. Among other things, that means that the desired state of our production environment should be in a Git repo as well.<\/p>\n<p>To make things simple, I already created a repo with all the definitions, so all we have to do is fork it and clone the fork.<\/p>\n<blockquote><p>\n  If you are a <strong>Linux<\/strong> or a <strong>WSL<\/strong> user, I will assume that you created the <code>alias<\/code> <code>open<\/code> and set it to the <code>xdg-open<\/code> command. If you do not have the <code>open<\/code> command (or the alias), you should replace <code>open<\/code> with <code>echo<\/code> and copy and paste the output into your favorite browser.\n<\/p><\/blockquote>\n<pre><code class=\"bash\">open https:\/\/github.com\/vfarcic\/argocd-production\n<\/code><\/pre>\n<p>Please fork the repository.<\/p>\n<p><em>If you do not know how to fork a GitHub repo, the only thing I can say is &#8220;shame on you&#8221;. Google how to do it. I will not spend time explaining that.<\/em><\/p>\n<p>Next, we&#8217;ll clone the newly forked repository.<\/p>\n<p><em>Please replace <code>[...]<\/code> with your GitHub organization in the command that follows. If you forked the repo into your personal account, then the organization is your GitHub username.<\/em><\/p>\n<pre><code class=\"bash\">#\u00a0Replace `[...]` with your GitHub organization\nexport GH_ORG=[...]\n\ngit clone \\\nhttps:\/\/github.com\/$GH_ORG\/argocd-production.git\n\ncd argocd-production\n<\/code><\/pre>\n<p>If, by any chance, you already had that repository from one of my previous exercises, you might want to merge it with <code>upstream<\/code> just in case I made some improvements in the meantime.<\/p>\n<p><em>Please execute the commands that follow only if you already forked the repo before.<\/em><\/p>\n<pre><code class=\"bash\">git remote add upstream \\\nhttps:\/\/github.com\/vfarcic\/argocd-production.git\n\ngit fetch upstream\n\ngit merge upstream\/master\n<\/code><\/pre>\n<p>Next, we&#8217;ll create an Argo CD project that will act as a placeholder for all the applications we&#8217;ll deploy to the production environment.<\/p>\n<p>*I will no go into details of how Argo CD works since that would take too much time and is not the main subject of this article. So, I&#8217;ll assume that you are already familiar with it. If that&#8217;s not the case, please read <a href=\"https:\/\/codefresh.io\/continuous-deployment\/creating-temporary-preview-environments-based-pull-requests-argo-cd-codefresh\/\">Creating Temporary Preview Environments Based On Pull Requests With Argo CD And Codefresh<\/a> as an example of an implementation of Argo CD processes.<\/p>\n<pre><code class=\"bash\">kubectl apply --filename project.yaml\n<\/code><\/pre>\n<p>Feel free to explore <code>project.yaml<\/code> file to see all the details of what we defined. For now, the only important note is that the <code>production<\/code> project we just created will be a placeholder for all the applications we&#8217;ll deploy and manage in production.<\/p>\n<p>Next, we&#8217;ll need a few tools in production. Specifically, we&#8217;ll need Prometheus to retrieve and store metrics that we&#8217;ll use to evaluate whether to roll forward or roll back releases of our applications. The definition is stored in the <code>orig<\/code> directory. However, as you will see soon, we&#8217;ll configure Argo CD to manage only the manifests in the <code>helm\/templates<\/code> directory of that same repo, so let&#8217;s copy it there.<\/p>\n<pre><code class=\"bash\">cp orig\/prometheus.yaml \\\nhelm\/templates\/.\n<\/code><\/pre>\n<p>Let&#8217;s take a quick look at the definition.<\/p>\n<pre><code class=\"bash\">cat helm\/templates\/prometheus.yaml\n<\/code><\/pre>\n<p>The output is as follows.<\/p>\n<pre><code class=\"yaml\">apiVersion: argoproj.io\/v1alpha1\nkind: Application\nmetadata:\nname: prometheus\nnamespace: argocd\nfinalizers:\n- resources-finalizer.argocd.argoproj.io\nspec:\nproject: production\nsource:\npath: charts\/prometheus\nrepoURL: https:\/\/github.com\/prometheus-community\/helm-charts\ntargetRevision: HEAD\ndestination:\nnamespace: monitoring\nserver: https:\/\/kubernetes.default.svc\nsyncPolicy:\nautomated:\nselfHeal: true\nprune: true\nsyncOptions:\n- CreateNamespace=true\n<\/code><\/pre>\n<p>There is nothing special about that <code>Application<\/code>. It uses the &#8220;official&#8221; chart stored in the <a href=\"https:\/\/github.com\/prometheus-community\/helm-charts\">prometheus-community\/helm-charts<\/a> repo, it will be running inside the <code>monitoring<\/code> Namespace, and synchronization will be fully <code>automated<\/code>.<\/p>\n<p>Similarly, we&#8217;ll need Argo Rollouts as well. Like with Prometheus, we&#8217;ll just copy the definition into the <code>helm\/templates<\/code> directory, assuming that Argo CD will make sure that it is up-and-running.<\/p>\n<pre><code class=\"bash\">cp orig\/argo-rollouts.yaml \\\nhelm\/templates\/.\n<\/code><\/pre>\n<p>Let&#8217;s take a quick look at the definition.<\/p>\n<pre><code class=\"bash\">cat helm\/templates\/argo-rollouts.yaml\n<\/code><\/pre>\n<p>The output is as follows.<\/p>\n<pre><code class=\"yaml\">apiVersion: argoproj.io\/v1alpha1\nkind: Application\nmetadata:\nname: argo-rollouts\nnamespace: argocd\nfinalizers:\n- resources-finalizer.argocd.argoproj.io\nspec:\nproject: production\nsource:\npath: charts\/argo-rollouts\nrepoURL: https:\/\/github.com\/argoproj\/argo-helm\ntargetRevision: HEAD\ndestination:\nnamespace: argo-rollouts\nserver: https:\/\/kubernetes.default.svc\nsyncPolicy:\nautomated:\nselfHeal: true\nprune: true\nsyncOptions:\n- CreateNamespace=true\n<\/code><\/pre>\n<p>As you can see, the definition follows the same pattern as the one we used for Prometheus. It will use the chart from the [argoproj\/argo-helm]8https:\/\/github.com\/argoproj\/argo-helm) repo and it will deploy it inside the <code>argo-rollouts<\/code> Namespace.<\/p>\n<p>Finally, there is one more application we&#8217;ll need to deploy. We&#8217;ll need a demo app to demonstrate the whole continuous delivery process combined with GitOps and progressive delivery. We&#8217;ll use one of my applications for that, and the definition is stored in <em>orig\/devops-toolkit-rollouts.yaml<\/em>. But, before we copy it to <code>helm\/templates<\/code>, we&#8217;ll need to change the <code>host<\/code> to something that will work inside your cluster.<\/p>\n<p><em>We&#8217;ll use <a href=\"http:\/\/xip.io\/\">xip.io<\/a> since I could not assume that you have a &#8220;real&#8221; domain that you can use for the exercises or, if you do, that you configured its DNS to point to the cluster.<\/em><\/p>\n<p>We&#8217;ll use <code>sed<\/code> to replace the hard-coded <code>devopstoolkitseries.com<\/code> host with the one based on <code>xip.io<\/code> and store the output into the <code>helm\/templates<\/code> directory.<\/p>\n<p><em>The command that follows assumes that you have the IP through which the Istio Gateway Service can be accessed. That is typically the <code>istio-ingressgateway<\/code> Service.<\/em><\/p>\n<pre><code class=\"bash\">cat orig\/devops-toolkit-rollouts.yaml \\\n| sed -e \\\n\"s@devopstoolkitseries.com@devops-toolkit.$ISTIO_HOST.xip.io@g\" \\\n| tee helm\/templates\/devops-toolkit.yaml\n<\/code><\/pre>\n<p>The output is as follows.<\/p>\n<pre><code class=\"yaml\">apiVersion: argoproj.io\/v1alpha1\nkind: Application\nmetadata:\nname: devops-toolkit\nnamespace: argocd\nfinalizers:\n- resources-finalizer.argocd.argoproj.io\nspec:\nproject: production\nsource:\npath: helm\nrepoURL: https:\/\/github.com\/vfarcic\/devops-toolkit.git\ntargetRevision: HEAD\nhelm:\nvalues: |\nimage:\ntag: latest\ningress:\nenabled: false\nhost: devops-toolkit.3.217.41.40.xip.io\nistio:\nenabled: true\nhpa: true\nrollout:\nenabled: true\nversion: v3\ndestination:\nnamespace: production\nserver: https:\/\/kubernetes.default.svc\nsyncPolicy:\nautomated:\nselfHeal: true\nprune: true\nignoreDifferences:\n- group: networking.istio.io\/v1alpha3\nkind: VirtualService\njsonPointers:\n- \/spec\/http\/*\/route\/*\/weight\n<\/code><\/pre>\n<p>That will be our initial definition of the demo application. It assumes that the base manifests are in the <a href=\"https:\/\/github.com\/vfarcic\/devops-toolkit\">vfarcic\/devops-toolkit<\/a> repo. It also overwrites a few of the default values. It will use the <code>latest<\/code> tag (a horrible practice that we&#8217;ll correct soon), it disables NGINX Ingress, and it enables <code>istio<\/code>, <code>hpa<\/code>, and <code>rollout<\/code>. We&#8217;ll see the meaning of some of those variable overwrites later. For now, what matters is that we have a definition of the demo application stored in <code>helm\/templates<\/code> together with the rest of the apps running in the production environment.<\/p>\n<p><img class=\"aligncenter size-large wp-image-18201\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/progressive-production-1024x705.png\" alt=\"\" width=\"1024\" height=\"705\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/progressive-production-1024x705.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/progressive-production-300x207.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/progressive-production-768x529.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/progressive-production-20x14.png 20w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/progressive-production.png 1484w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" \/>!<\/p>\n<p>There is only one more thing missing. We need to create an app of apps. All those applications we defined so far are references to different sources where base definitions are stored. All three of them (Prometheus, Argo Rollouts, and <code>devops-toolkit<\/code>) are referencing the repositories of those applications. We are now missing an app that will tell Argo CD to look for production manifests in the repository we forked initially.<\/p>\n<p>I already prepared the file. However, it has my GitHub organization hard-coded, so we&#8217;ll have to change it to yours. Just as before, we&#8217;ll use &#8220;<code>sed<\/code> magic&#8221; for that.<\/p>\n<pre><code class=\"bash\">cat orig\/apps.yaml \\\n| sed -e \"s@vfarcic@$GH_ORG@g\" \\\n| tee apps.yaml\n<\/code><\/pre>\n<p>The output is as follows.<\/p>\n<pre><code class=\"yaml\">apiVersion: argoproj.io\/v1alpha1\nkind: Application\nmetadata:\nname: production\nnamespace: argocd\nfinalizers:\n- resources-finalizer.argocd.argoproj.io\nspec:\nproject: production\nsource:\nrepoURL: https:\/\/github.com\/devopsparadox\/argocd-production.git\ntargetRevision: HEAD\npath: helm\ndestination:\nserver: https:\/\/kubernetes.default.svc\nnamespace: production\nsyncPolicy:\nautomated:\nselfHeal: true\nprune: true\nsyncOptions:\n- CreateNamespace=true\n<\/code><\/pre>\n<p>That definition is still following the same pattern. The <code>Application<\/code> is almost the same as the one we used for the other apps. The major difference is that, this time, the <code>repoURL<\/code> is set to the <code>helm<\/code> path of the <code>argocd-production<\/code> repo, which holds all the Applications that should run in production. It is an application that defines all the applications for a specific environment.<\/p>\n<p>Let&#8217;s push the changes to GitHub before we create the app of the apps. Even though we will create it manually, the definitions should, as a minimum, be stored in Git.<\/p>\n<pre><code class=\"bash\">git add .\n\ngit commit -m \"Initial commit\"\n\ngit push\n<\/code><\/pre>\n<p>Now we can apply the definitions of the app of the apps.<\/p>\n<pre><code class=\"bash\">kubectl apply --filename apps.yaml\n<\/code><\/pre>\n<p><img class=\"aligncenter size-large wp-image-18200\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/progressive-production-full-1024x726.png\" alt=\"\" width=\"1024\" height=\"726\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/progressive-production-full-1024x726.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/progressive-production-full-300x213.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/progressive-production-full-768x544.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/progressive-production-full-20x14.png 20w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/progressive-production-full.png 1442w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" \/><\/p>\n<p>That&#8217;s it. We have the whole production environment defined in Git repositories, with those three apps combined representing the desired state. Argo CD, on the other hand, made sure that the actual state (the cluster) is converged into the desired state. We can confirm that through the Argo CD UI.<\/p>\n<p>Let&#8217;s &#8220;discover&#8221; the Argo CD UI address.<\/p>\n<p><em>Please note that, depending on how you installed Argo CD, the command might differ in your case.<\/em><\/p>\n<pre><code class=\"bash\">ARGOCD_ADDR=$(kubectl \\\n--namespace argocd \\\nget ingress argocd-server \\\n--output jsonpath=\"{.spec.rules[0].host}\")\n<\/code><\/pre>\n<p>The output, in my case, is as follows.<\/p>\n<pre><code>argocd.52.73.202.6.xip.io\n<\/code><\/pre>\n<p>If the output is empty or there was an error, you probably did not enable Ingress for Argo CD, or you forgot to specify the address. If that&#8217;s the case, you might need to update your Argo CD installation.<\/p>\n<p>Now that we know the address of Argo CD, we can open it in the default browser.<\/p>\n<p><em>Please note that the command that follows uses HTTP. If you set up TLS for your Argo CD UI, you might need to change <code>http<\/code> to <code>https<\/code> in the command that follows.<\/em><\/p>\n<pre><code class=\"bash\">open http:\/\/$ARGOCD_ADDR\n<\/code><\/pre>\n<p>We should see five applications in Argo CD UIs home screen. There should be <em>production<\/em>, which is app of the apps. It &#8220;discovered&#8221; the rest of the apps defined in the production repo, and it deployed the other four. We have <em>prometheus<\/em>, <em>argo-rollouts<\/em>, <em>devops-toolkit<\/em>, and <em>devops-paradox<\/em>. If you&#8217;re confused about the latter (<em>devops-paradox<\/em>), it was already defined in the <em>production<\/em> repo we forked earlier. Still, even though it&#8217;s there, we will not use it today, so you can ignore it.<\/p>\n<p><img class=\"aligncenter size-large wp-image-18197\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/argocd-home-1024x760.png\" alt=\"\" width=\"1024\" height=\"760\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/argocd-home-1024x760.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/argocd-home-300x223.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/argocd-home-768x570.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/argocd-home-1536x1139.png 1536w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/argocd-home-2048x1519.png 2048w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/argocd-home-20x15.png 20w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" \/>!<\/p>\n<p>We&#8217;re done with the production repo (for now), so we can just as well get out of the local copy.<\/p>\n<pre><code class=\"bash\">cd ..\n<\/code><\/pre>\n<p>Now that production is set up, we can turn our attention to the <em>devops-toolkit<\/em> app. That&#8217;s the one we&#8217;ll use as a guinea pig for progressive delivery.<\/p>\n<h2>Defining The Application<\/h2>\n<p>The <em>devops-toolkit<\/em> demo app is available in the <a href=\"https:\/\/github.com\/vfarcic\/devops-toolkit\">vfarcic\/devops-toolkit<\/a>. However, given that we will start making changes to the app, you will have to fork it. Otherwise, I would need to give you write access to my repo, and that&#8217;s not something I&#8217;m willing to do. I do not trust you enough.<\/p>\n<pre><code class=\"bash\">open https:\/\/github.com\/vfarcic\/devops-toolkit.git\n<\/code><\/pre>\n<p>I&#8217;m sure you know how to fork a GitHub repo. So just do it. Fork it!<\/p>\n<p>Let&#8217;s clone the forked repo.<\/p>\n<pre><code class=\"bash\">git clone https:\/\/github.com\/$GH_ORG\/devops-toolkit.git\n\ncd devops-toolkit\n<\/code><\/pre>\n<p>Just as before, if, by any chance, you already had that repository from one of my previous exercises, you might want to merge it with <code>upstream<\/code> just in case I made some improvements in the meantime.<\/p>\n<p><em>Please execute the commands that follow only if you already forked the repo before.<\/em><\/p>\n<pre><code class=\"bash\">git remote add upstream \\\nhttps:\/\/github.com\/vfarcic\/devops-toolkit.git\n\ngit fetch upstream\n\ngit merge upstream\/master\n<\/code><\/pre>\n<p>There are a couple of ways we can approach updates of the releases in the production repo. For example, we could modify the file in the production repo every time we want to have a new release of that application. We are not going to do that. That would mean that the pipeline needs to know about all the app definitions in the production repo. More importantly, it would mean that the structural changes to the definition would need to be done there. I prefer that everything related to a single application is in the repo of that app. That way, people in charge of the application can have (almost) full control over it from a single repo.<\/p>\n<p>Long story short, we&#8217;ll create a template (of sorts) in the <em>devops-toolkit<\/em> repo. Later on, we&#8217;ll be able to instruct the pipeline to &#8220;transform&#8221; some key values of that file and copy it into the production repo whenever we need a new release.<\/p>\n<p>By now, you probably know that I do not want to make you work too much, so I have already prepared the file we&#8217;ll use. We just need to copy it and, while doing that, replace the hard-coded Istio Gateway address with the one that will work your setup.<\/p>\n<pre><code class=\"bash\">cat orig\/production-rollouts.yaml \\\n| sed -e \\\n\"s@devopstoolkitseries.com@devops-toolkit.$ISTIO_HOST.xip.io@g\" \\\n| tee production.yaml\n<\/code><\/pre>\n<p>The output is as follows.<\/p>\n<pre><code class=\"yaml\">apiVersion: argoproj.io\/v1alpha1\nkind: Application\nmetadata:\nname: devops-toolkit\nnamespace: argocd\nfinalizers:\n- resources-finalizer.argocd.argoproj.io\nspec:\nproject: production\nsource:\npath: helm\nrepoURL: https:\/\/github.com\/vfarcic\/devops-toolkit.git\ntargetRevision: HEAD\nhelm:\nvalues: |\nimage:\nrepository: vfarcic\/devops-toolkit\ntag: {{.IMAGE_TAG}}\ningress:\nenabled: false\nhost: devops-toolkit..xip.io\nistio:\nenabled: true\nhpa: true\nrollout:\nenabled: true\nversion: v3\ndestination:\nnamespace: production\nserver: https:\/\/kubernetes.default.svc\nsyncPolicy:\nautomated:\nselfHeal: true\nprune: true\nignoreDifferences:\n- group: networking.istio.io\nkind: VirtualService\njsonPointers:\n- \/spec\/http\n<\/code><\/pre>\n<p>It&#8217;s yet another Argo CD application with the reference to the <code>repoURL<\/code> and the <code>path<\/code> where the definitions are, a few production-specific values we are overwriting, and the <code>ignoreDifferences<\/code> section. Assuming that you already have a basic understanding of how Argo CD works, you should not have any issue understanding that definition except, maybe, the last part (<code>ignoreDifferences<\/code>). So let&#8217;s talk about it.<\/p>\n<p>Argo CD will ensure that whatever is defined in Git repos it monitors is applied to the cluster. It will do its best to always keep the actual state the same as the desired state of our applications and all the resources they need. However, that is in stark contrast with the dynamic nature of Kubernetes clusters and the processes running inside it.<\/p>\n<p>Argo Rollouts will roll out new releases gradually. It will let a fraction of our users see it, and it will run the analysis to decide whether the reach of the new release should be increased to more users or it should rollback. To do that, it will need to modify the behavior of the application at runtime. In other words, Argo Rollouts will be changing the actual state. To be more specific, Argo Rollouts will be modifying the <code>weight<\/code> of Istio Virtual Services.<\/p>\n<p>Argo CD, on the other hand, does not like when someone modifies the actual state. As a matter of fact, it despises it, and it will do its best to undo any divergence from the desired state. So, if Argo Rollouts modifies Virtual Services (the actual state), Argo CD will soon afterward try to undo those changes by synchronizing the actual (cluster) into the desired state (Git).<\/p>\n<p>As you can see, Argo CD and Argo Rollouts might be at odds. One is trying to make the cluster resources always the same as the definitions in Git, while the other is trying to modify the resources in the cluster as part of progressive delivery processes.<\/p>\n<p>We are fixing those issues through the <code>ignoreDifferences<\/code> section of the <code>Application<\/code> definition. Argo CD will ignore the section of the <code>VirtualService<\/code> manifests defined inside specified <code>jsonPointers<\/code>. Given that <code>weight<\/code> we discussed is inside <code>spec.http<\/code>, it will be ignored, except during the initial deployment.<\/p>\n<p>Now that we have the production environment up-and-running and that we explored the <code>production.yaml<\/code> file that will be used to define new releases of <code>devops-toolkit<\/code>, we can turn our attention to the pipeline that will glue it all together into a continuous delivery process.<\/p>\n<h2>Creating The Pipeline<\/h2>\n<p>Before we create a <a href=\"https:\/\/codefresh.io\/codefresh-signup\/?utm_source=Blog&amp;utm_medium=Post&amp;utm_campaign=vfarcic-progressive\">Codefresh<\/a> pipeline that will do all the work for us, I should probably comment on a few assumptions I made.<\/p>\n<p>I am assuming that you already have <code>codefresh<\/code> CLI installed. Also, I am guessing that you created a GitHub context so that Codefresh knows how to use your repositories. If my assumptions are wrong, please go through the <a href=\"https:\/\/codefresh.io\/devops-tutorial\/samurais-not-use-uis-using-cli-configure-codefresh-create-manage-kubernetes-pipelines\/\">Samurais Do NOT Use UIs: Using CLI To Configure Codefresh And Create And Manage Kubernetes Pipelines<\/a> article. It provides all the instructions you&#8217;ll need, and much more.<\/p>\n<p>With that out of the way, let&#8217;s double-check whether the CLI works and whether you have a <code>github<\/code> context.<\/p>\n<pre><code class=\"bash\">codefresh get contexts\n<\/code><\/pre>\n<p>In my case, the output is as follows.<\/p>\n<pre><code>NAME TYPE\nCF_HELM_DEFAULT helm-repository\ngithub-2 git.github\n<\/code><\/pre>\n<p>To simplify the commands that follow, we&#8217;ll put the <code>NAME<\/code> of the <code>git.github<\/code> context into an environment variable.<\/p>\n<p><em>Please replace <code>[...]<\/code> in the commands that follow with the <code>context<\/code> you&#8217;re planning to use.<\/em><\/p>\n<pre><code class=\"bash\"># Replace `[...]` with the `git.github` context. Create it if there isn't one\nexport CF_GIT_CONTEXT=[...]\n<\/code><\/pre>\n<p>By now, you probably have the expectation that I prepared everything so that you can be as lazy as you can be. Given that I would feel bad not meeting your expectations, I created a definition of the pipeline we will use. We just need to replace a few hard-coded values.<\/p>\n<pre><code class=\"bash\">cat codefresh\/codefresh-master.yml \\\n| sed -e \"s@repo: vfarcic@repo: $GH_ORG@g\" \\\n| sed -e \"s@context: github@context: $CF_GIT_CONTEXT@g\" \\\n| sed -e \"s@git: github@git: $CF_GIT_CONTEXT@g\" \\\n| tee codefresh-master.yml\n<\/code><\/pre>\n<p>The output is as follows.<\/p>\n<pre><code class=\"yaml\">version: \"1.0\"\nkind: pipeline\nmetadata:\nname: devops-toolkit-master\ndescription: Triggered when pushing changes to the master branch\nspec:\ntriggers:\n- type: git\nprovider: github\ncontext: github-2\nname: master\nrepo: devopsparadox\/devops-toolkit\nevents:\n- push.heads\npullRequestAllowForkEvents: true\nbranchRegex: \/^((master)$).*\/gi\nverified: true\ncontexts: []\nstages:\n- release\n- deploy\nsteps:\nmain_clone:\ntitle: Cloning repository\ntype: git-clone\narguments:\nrepo: \"${{CF_REPO_OWNER}}\/${{CF_REPO_NAME}}\"\ngit: github-2\nrevision: \"${{CF_BRANCH}}\"\nstage: release\nbuild_app:\ntitle: Building Hugo\nimage: klakegg\/hugo:0.75.1-ext-alpine\ncommands:\n- .\/build.sh\n- cf_export REPO_PATH=$PWD\nstage: release\nbuild_image:\ntitle: Building container image\ntype: build\narguments:\nimage_name: vfarcic\/devops-toolkit\ntags:\n- ${{CF_SHORT_REVISION}}\nregistry: docker-hub\nstage: release\nclone_env_repo:\ntitle: Cloning production env. repo\ntype: git-clone\narguments:\nrepo: devopsparadox\/argocd-production\ngit: github-2\nstage: deploy\ndefine_production:\nimage: vfarcic\/argocd-pipeline:1.0.ee76b7a\ntitle: Defining production environment app\nworking_directory: \"${{clone_env_repo}}\"\ncommands:\n- export IMAGE_TAG=\"$CF_SHORT_REVISION\"\n- git checkout -b $CF_REPO_NAME-$CF_SHORT_REVISION\n- cat $REPO_PATH\/production.yaml | kyml tmpl -e IMAGE_TAG | tee helm\/templates\/$CF_REPO_NAME.yaml\n- git add .\nstage: deploy\npush_env_repo:\ntitle: Push production env. changes\ntype: git-commit\narguments:\nrepo: devopsparadox\/argocd-production\ngit: github-2\ncommit_message: \"Adding commit ${{CF_SHORT_REVISION}} from ${{CF_REPO_NAME}}\"\ngit_user_name: \"${{CF_COMMIT_AUTHOR}}\"\nworking_directory: \/codefresh\/volume\/argocd-production\nstage: deploy\ngithub_pr:\ntitle: Creating a pull request\ntype: github-pr\nworking_directory: \"${{clone_env_repo}}\"\narguments:\nGITHUB_TOKEN: \"${{GITHUB_TOKEN}}\"\nGITHUB_REPO_OWNER: \"${{CF_REPO_OWNER}}\"\nGITHUB_REPO_NAME: argocd-production\nHEAD: \"${{CF_REPO_NAME}}-${{CF_SHORT_REVISION}}\"\nTITLE: \"${{CF_SHORT_REVISION}} from ${{CF_REPO_NAME}}\"\nBASE: master\nstage: deploy\n<\/code><\/pre>\n<p>I&#8217;ll assume that you already have at least a basic understanding of Codefresh pipeline syntax, so I&#8217;ll provide only a quick overview of what it does.<\/p>\n<p>The <code>triggers<\/code> section will ensure that pipeline builds are triggered whenever we push a change to the <code>master<\/code> branch of the <code>devops-toolkit<\/code> repo.<\/p>\n<p>Inside the <code>release<\/code> stage of the <code>steps<\/code> section, we are cloning the app repo (<code>main_clone<\/code>), and we are building the binary (<code>build_app<\/code>) and the container image (<code>build_image<\/code>). Those are standard steps that you are probably already doing one way or another.<\/p>\n<p>The <code>deploy<\/code> stage is more interesting.<\/p>\n<p>In the <code>deploy<\/code> stage, we are cloning yet another repo (<code>clone_env_repo<\/code>). This time, we are retrieving the production repository. Further on (<code>define_production<\/code>), we are checking out a new branch of the production repo and modifying the <code>production.yaml<\/code> file from the app repo using <code>kyml<\/code>. It replaces the placeholder in the definition with the new image tag (the one we built in one of the previous steps). Finally, we are pushing the changes (<code>push_env_repo<\/code>) and creating a new pull request (<code>github_pr<\/code>).<\/p>\n<p>That&#8217;s it. The pipeline might look big at first, but it is a straightforward one.<\/p>\n<p>The most important observation is that we are NOT interacting with the cluster in any form or way. For all we know, neither Codefresh nor anyone or anything else has access to the cluster. Instead, we interact only with Git repositories hoping that Argo CD running inside our cluster will pull the changes and do the right thing.<\/p>\n<p><img class=\"aligncenter size-large wp-image-18199\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/progressive-pipeline-1024x432.png\" alt=\"\" width=\"1024\" height=\"432\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/progressive-pipeline-1024x432.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/progressive-pipeline-300x127.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/progressive-pipeline-768x324.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/progressive-pipeline-1536x648.png 1536w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/progressive-pipeline-20x8.png 20w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/progressive-pipeline.png 1864w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" \/><\/p>\n<p>Let&#8217;s act as responsible adults and push those changes to Git before creating the pipeline.<\/p>\n<pre><code class=\"bash\">git add .\n\ngit commit -m \"Progressive\"\n\ngit push\n<\/code><\/pre>\n<p>Creating a pipeline is easy, so let&#8217;s just do it.<\/p>\n<pre><code class=\"bash\">codefresh create pipeline \\\n-f codefresh-master.yml\n<\/code><\/pre>\n<p>Next, let&#8217;s take a look at the pipeline from the Codefresh UI.<\/p>\n<pre><code class=\"bash\">open https:\/\/g.codefresh.io\/pipelines\/edit\/workflow?pipeline=devops-toolkit-master\n<\/code><\/pre>\n<p>Please click the <em>VARIABLES<\/em> tab, and you&#8217;ll see that one was detected as non-existent. Expand the <em>DETECTED VARIABLES<\/em> section, and you&#8217;ll see that <em>GITHUB_TOKEN<\/em> is missing. I did not want to hard-code the token inside the pipeline definition (that would be irresponsible), so it&#8217;s defined as a variable.<\/p>\n<p>Please click the <em>GITHUB_TOKEN<\/em> button and type the GitHub token (create it if you do not have it at hand). Since the token is confidential, we should encrypt it by clicking the <em>Encrypt<\/em> icon next to the value.<\/p>\n<p>All that&#8217;s left is to click the <em>SAVE<\/em> button.<\/p>\n<h2>Exploring The Initial Deployment<\/h2>\n<p>We still need to explore the Argo Rollouts definition. We&#8217;ll go through it fast since the focus is not to go deep into any specific tool but to demonstrate how to combine it all into a unified process. If you need an overview, please watch <a href=\"https:\/\/youtu.be\/84Ky0aPbHvY\">Argo Rollouts &#8211; Canary Deployments Made Easy In Kubernetes<\/a>.<\/p>\n<p>Everything related to Argo Rollouts is in the <code>helm\/templates\/rollout.yaml<\/code> and <code>helm\/values.yaml<\/code> files, so let&#8217;s take a quick look at the former one first.<\/p>\n<pre><code class=\"bash\">cat helm\/templates\/rollout.yaml\n<\/code><\/pre>\n<p>I&#8217;ll let you explore the definitions yourself. Once you&#8217;re done, we&#8217;ll take a look at the <code>values.yaml<\/code> file since it contains the critical piece of information.<\/p>\n<pre><code class=\"bash\">cat helm\/values.yaml\n<\/code><\/pre>\n<p>The output, limited to the relevant parts, is as follows.<\/p>\n<pre><code class=\"yaml\">...\nrollout:\nenabled: false\nsteps:\n- setWeight: 10\n- pause: {duration: 2m}\n- setWeight: 30\n- pause: {duration: 30s}\n- setWeight: 50\n- pause: {duration: 30s}\nanalysis:\nenabled: true\n<\/code><\/pre>\n<p>The rollout process will have three steps, with pauses in between. It will set the weight to ten percent, wait for two minutes, change the weight to thirty percent, wait for thirty seconds, change the weight to fifty percent, wait for thirty seconds again, and, after all that, roll out fully.<\/p>\n<p>The reason for having the first pause so long (compared to others) lies in Prometheus pulling frequency. By default, it pulls metrics every two minutes, so we want to ensure that the metrics are available for the analysis. That&#8217;s why the <code>spec.strategy.canary.steps.analysis.startingStep<\/code> entry in <code>helm\/templates\/rollout.yaml<\/code> is set to <code>2<\/code>. Argo Rollouts will start analyzing metrics only after it reaches the second step (<code>setWeight: 30<\/code>), or, to put it in other words, after a bit more than two minutes.<\/p>\n<p>The initial deployment of the app is already done. The moment we told Argo CD of the existence of the production repo, it converged the actual into the desired state. Since <code>devops-toolkit<\/code> is one of the Argo CD applications defined in that repo, it should already be running inside the cluster. We can confirm that by retrieving the <code>devops-toolkit-devops-toolkit<\/code> rollout from the <code>production<\/code> Namespace.<\/p>\n<pre><code class=\"bash\">kubectl argo rollouts \\\n--namespace production \\\nget rollout devops-toolkit-devops-toolkit\n<\/code><\/pre>\n<p><em>If that command did not work, you probably did not install the <code>kubectl<\/code> plugin for Argo Rollouts. If that&#8217;s the case, please visit the <a href=\"https:\/\/argoproj.github.io\/argo-rollouts\/installation\/#kubectl-plugin-installation\">Kubectl Plugin Installation<\/a> for instructions.<\/em><\/p>\n<p>The output is as follows.<\/p>\n<pre><code>Name: devops-toolkit-devops-toolkit\nNamespace: production\nStatus: Healthy\nStrategy: Canary\nStep: 6\/6\nSetWeight: 100\nActualWeight: 100\nImages: vfarcic\/devops-toolkit-series:latest (stable)\nReplicas:\nDesired: 2\nCurrent: 2\nUpdated: 2\nReady: 2\nAvailable: 2\n\nNAME KIND STATUS AGE INFO\ndevops-toolkit-devops-toolkit Rollout Healthy 21h\nrevision:1\ndevops-toolkit-devops-toolkit-647879f7c5 ReplicaSet Healthy 21h stable\ndevops-toolkit-devops-toolkit-647879f7c5-rzqwr Pod Running 21h ready:1\/1\ndevops-toolkit-devops-toolkit-647879f7c5-zpgdq Pod Running 21h ready:1\/1\n<\/code><\/pre>\n<p>We can see that the first deployment (<code>revision:1<\/code>) was successful. The <code>ActualWeight<\/code> is set to <code>100<\/code>, meaning that all the traffic is going to that release. Now, to be fair, that wasn&#8217;t progressive delivery. The first release of something cannot be deployed progressively since there is no previous release to progress from. We&#8217;ll change that soon when we deploy a second release of the demo app.<\/p>\n<h2>Rolling Back Releases<\/h2>\n<p>There are two typical outcomes of any deployment. It&#8217;s successful, or it failed. Actually, there is a third outcome that can be described as &#8220;we don&#8217;t know&#8221;, but I&#8217;ll leave that one aside.<\/p>\n<p>In the case of canary deployments, success means that it is rolled out to all the users, while repeated failure results in a rollback to the previous release. We&#8217;ll explore the latter first.<\/p>\n<p>Let&#8217;s see what happens when things go wrong. For that, we&#8217;ll be sending requests to a non-existing endpoint. As a result, that should generate response codes with errors in 4xx range.<\/p>\n<p>First, we&#8217;ll need the IP of the Istio Gateway.<\/p>\n<pre><code class=\"bash\">echo $ISTIO_HOST\n<\/code><\/pre>\n<p>Copy the output.<\/p>\n<p>Next, <strong>open a second terminal session<\/strong> and (re)declare the <code>ISTIO_HOST<\/code> variable.<\/p>\n<p><em>Please replace <code>[...]<\/code> in the command that follows with the IP copied earlier.<\/em><\/p>\n<pre><code class=\"bash\">#\u00a0Replace `[...]` with the IP of the Istio Gateway Service\nexport ISTIO_HOST=[...]\n<\/code><\/pre>\n<p>Now we can start sending &#8220;false&#8221; requests to the app, hoping they will generate issues that will compel Argo Rollouts to roll back the release we are about to deploy.<\/p>\n<pre><code class=\"bash\">while true; do\ncurl -I http:\/\/devops-toolkit.$ISTIO_HOST.xip.io\/this-does-not-exist\nsleep 1\ndone\n<\/code><\/pre>\n<p>Let&#8217;s leave the loop running and <strong>go back to the first terminal session<\/strong>.<\/p>\n<p>Now we can &#8220;pretend&#8221; to create a new release of the application.<\/p>\n<p><em>Typically, we&#8217;d write some code, create a pull request, deploy it to a temporary preview environment, let our colleagues review it, and do whatever else we usually do before merging PRs. But we&#8217;ll skip all that for brevity reasons. Progressive delivery (e.g., canary deployment) is generally used only in production anyway.<\/em><\/p>\n<p>All in all, we&#8217;ll skip the PR part of the process and make some changes directly to the mainline.<\/p>\n<pre><code class=\"bash\">echo \"Will it roll back?\" \\\n| tee README.md\n\ngit add .\n\ngit commit -m \"A silly change\"\n\ngit push\n<\/code><\/pre>\n<p>We made a silly change to the local copy of the repository, and we pushed it to GitHub. As a result, a new pipeline build should be running (or it might have already finished). Let&#8217;s take a quick look at it.<\/p>\n<pre><code class=\"bash\">open https:\/\/g.codefresh.io\/builds2\n<\/code><\/pre>\n<p>Please select the latest build to see the progress.<\/p>\n<p><img class=\"aligncenter size-large wp-image-18198\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/cf-master-pipeline-1024x759.png\" alt=\"\" width=\"1024\" height=\"759\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/cf-master-pipeline-1024x759.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/cf-master-pipeline-300x222.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/cf-master-pipeline-768x569.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/cf-master-pipeline-1536x1138.png 1536w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/cf-master-pipeline-2048x1518.png 2048w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/cf-master-pipeline-20x15.png 20w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" \/><\/p>\n<p>Once the build is finished, we should have a new pull request with the suggested changes in the <code>argocd-production<\/code> repo. That means that we are practicing continuous delivery instead of continuous deployment. If the latter is your preference, all you would have to do is change the pipeline to push directly to the mainline of the production repo instead of making a pull request.<\/p>\n<p>Let&#8217;s see the newly created PR.<\/p>\n<pre><code class=\"bash\">open https:\/\/github.com\/$GH_ORG\/argocd-production\/pulls\n<\/code><\/pre>\n<p>Go inside the PR and explore the changes. <strong>Merge it<\/strong> once you&#8217;re done.<\/p>\n<p>From here on, Argo CD should detect the modification to the definitions in the production repo and make the necessary changes to the cluster. Since the app definition is based on Argo Rollouts, the modification should start the process of canary deployments. We can watch the progress with the command that follows.<\/p>\n<pre><code class=\"bash\">kubectl argo rollouts \\\n--namespace production \\\nget rollout devops-toolkit-devops-toolkit \\\n--watch\n<\/code><\/pre>\n<p>After a few minutes, when the process is finished, the output should be similar to the one that follows.<\/p>\n<pre><code>Name: devops-toolkit-devops-toolkit\nNamespace: production\nStatus: Degraded\nMessage: RolloutAborted: Rollout is aborted\nStrategy: Canary\nStep: 0\/6\nSetWeight: 0\nActualWeight: 0\nImages: vfarcic\/devops-toolkit-series:latest (stable)\nReplicas:\nDesired: 2\nCurrent: 2\nUpdated: 0\nReady: 2\nAvailable: 2\n\nNAME KIND STATUS AGE INFO\ndevops-toolkit-devops-toolkit Rollout Degraded 4m29s\n# revision:2\ndevops-toolkit-devops-toolkit-787dc7b9b6 ReplicaSet ScaledDown 3m16s canary\ndevops-toolkit-devops-toolkit-787dc7b9b6-2 AnalysisRun Error 70s 5, 5\n# revision:1\ndevops-toolkit-devops-toolkit-647879f7c5 ReplicaSet Healthy 4m16s stable\ndevops-toolkit-devops-toolkit-647879f7c5-sk7fs Pod Running 4m16s ready:1\/1\ndevops-toolkit-devops-toolkit-647879f7c5-zzvbz Pod Running 4m16s ready:1\/1\n<\/code><\/pre>\n<p>The process immediately changed the weight so that ten percent of the requests are going to the new release, while all the rest are redirected to the old. Two minutes later, it increased the weight of the new release to thirty percent and started analyzing metrics stored in Prometheus. After the analysis failed to reach the threshold three times, it started rolling back to the old release. At the end of the process, the situation is the same as if we never even tried to roll out a new release. Only the old release is running, and a hundred percent of the requests are redirected to it.<\/p>\n<p><img class=\"aligncenter size-large wp-image-18202\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/progressive-roll-back-1024x432.png\" alt=\"\" width=\"1024\" height=\"432\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/progressive-roll-back-1024x432.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/progressive-roll-back-300x127.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/progressive-roll-back-768x324.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/progressive-roll-back-1536x648.png 1536w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/progressive-roll-back-20x8.png 20w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/progressive-roll-back.png 1864w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" \/><\/p>\n<p>Pease <em>ctrl+c<\/em> to stop watching the rollout.<\/p>\n<p>We will not need the loop sending requests to the non-existent endpoint, so let&#8217;s stop it as well.<\/p>\n<p><strong>Go to the second terminal session<\/strong> and cancel the loop by pressing <em>ctrl+c<\/em>.<\/p>\n<p>Let&#8217;s see how a successful rollout looks like.<\/p>\n<h2>Rolling Forward Releases<\/h2>\n<p>Assuming that you are still in the second terminal session, please execute the commands that follow to start sending &#8220;good&#8221; requests to the app and, through them, generate &#8220;positive&#8221; metrics.<\/p>\n<pre><code class=\"bash\">while true; do\ncurl -I http:\/\/devops-toolkit.$ISTIO_HOST.xip.io\nsleep 1\ndone\n<\/code><\/pre>\n<p>Next, we&#8217;ll make yet another silly release and see what happens.<\/p>\n<p><strong>Go to the first terminal session<\/strong> and execute the commands that follow to make just enough change to the repo to initiate another pipeline build.<\/p>\n<pre><code class=\"bash\">echo \"Will it roll forward?\" \\\n| tee README.md\n\ngit add .\n\ngit commit -m \"A silly change\"\n\ngit push\n<\/code><\/pre>\n<p>Let&#8217;s wait until the build is finished. If you&#8217;re bored staring at a static screen, feel free to go back to Codefresh builds and watch it progress.<\/p>\n<p>All that&#8217;s left to do, once the pipeline build is finished, is to go to the <em>argocd-production<\/em> repo and merge the newly created pull request.<\/p>\n<pre><code class=\"bash\">open https:\/\/github.com\/$GH_ORG\/argocd-production\/pulls\n<\/code><\/pre>\n<p>Open the newly created PR and merge it.<\/p>\n<p>Let&#8217;s see how this rollout will look like.<\/p>\n<pre><code class=\"bash\">kubectl argo rollouts \\\n--namespace production \\\nget rollout devops-toolkit-devops-toolkit \\\n--watch\n<\/code><\/pre>\n<p>After a couple of existing minutes, the output should be similar to the one that follows.<\/p>\n<pre><code>Name: devops-toolkit-devops-toolkit\nNamespace: production\nStatus: Healthy\nStrategy: Canary\nStep: 6\/6\nSetWeight: 100\nActualWeight: 100\nImages: vfarcic\/devops-toolkit:0b4838a (stable)\nReplicas:\nDesired: 2\nCurrent: 2\nUpdated: 2\nReady: 2\nAvailable: 2\n\nNAME KIND STATUS AGE INFO\ndevops-toolkit-devops-toolkit Rollout Healthy 11m\n# revision:3\ndevops-toolkit-devops-toolkit-65d98bd45b ReplicaSet Healthy 3m27s stable\ndevops-toolkit-devops-toolkit-65d98bd45b-2fczg Pod Running 3m27s ready:1\/1\ndevops-toolkit-devops-toolkit-65d98bd45b-zd4vp Pod Running 19s ready:1\/1\ndevops-toolkit-devops-toolkit-65d98bd45b-3 AnalysisRun Successful 79s 14\n# revision:2\ndevops-toolkit-devops-toolkit-787dc7b9b6 ReplicaSet ScaledDown 10m\ndevops-toolkit-devops-toolkit-787dc7b9b6-2 AnalysisRun Error 8m21s 5, 5\n# revision:1\ndevops-toolkit-devops-toolkit-647879f7c5 ReplicaSet ScaledDown 11m\n<\/code><\/pre>\n<p>All the requests should be going to the new release, and the old one should be scaled down to zero replicas. We were successful!<\/p>\n<p><img class=\"aligncenter size-large wp-image-18196\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/progressive-roll-forward-1024x432.png\" alt=\"\" width=\"1024\" height=\"432\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/progressive-roll-forward-1024x432.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/progressive-roll-forward-300x127.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/progressive-roll-forward-768x324.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/progressive-roll-forward-1536x648.png 1536w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/progressive-roll-forward-20x8.png 20w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/progressive-roll-forward.png 1864w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" \/><\/p>\n<p>That&#8217;s it. You can stop watching the rollout and stop sending requests by pressing <em>ctrl+c<\/em> in both terminal sessions.<\/p>\n<h2>Cleaning Up The Mess<\/h2>\n<p>It&#8217;s always a good idea to clean up the mess after we&#8217;re finished &#8220;playing&#8221;, so let&#8217;s remove any trace of our activities.<\/p>\n<p>Please make sure that you are in the first terminal session and execute the commands that follow.<\/p>\n<p><em>I&#8217;ll use <code>gh<\/code> CLI to open the repos. Please <a href=\"https:\/\/github.com\/cli\/cli#installation\">install it<\/a> if you do not have it already.<\/em><\/p>\n<pre><code class=\"bash\">cd ..\n\ncodefresh delete pipeline \\\ndevops-toolkit-master\n\ncd argocd-production\n\ngh repo view --web\n\n# Delete the repo\n\ncd ..\n\ncd devops-toolkit\n\ngh repo view --web\n\n# Delete the repo\n\ncd ..\n\nrm -rf argocd-production \\\ndevops-toolkit\n<\/code><\/pre>\n<p>Finally, destroy the cluster if you created it only for the exercises.<\/p>\n<input class=\"fooboxshare_post_id\" type=\"hidden\" value=\"18194\"\/>","protected":false},"excerpt":{"rendered":"<p>Progressive delivery is arguably the most reliable and advanced set of deployment practices based on a simple idea. Instead of shutting down the old release and deploying a new one in its place, progressive delivery takes an iterative approach. It gradually increases the reach of a new release. That gives us quite a few benefits &hellip; <a href=\"https:\/\/codefresh.io\/about-gitops\/combining-progressive-delivery-gitops-continuous-delivery-argo-cd-argo-rollouts-codefresh\/\">Read more<\/a><\/p>\n","protected":false},"author":125,"featured_media":18248,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[3120,5467,5703,1538],"tags":[44,59,651,980,2243,4322,5506,5507,5508,5562,5563,5564,5565],"yoast_head":"<!-- This site is optimized with the Yoast SEO Premium plugin v17.9 (Yoast SEO v18.4.1) - https:\/\/yoast.com\/wordpress\/plugins\/seo\/ -->\n<title>Combining Progressive Delivery With GitOps and Continuous Delivery Through Argo CD, Argo Rollouts, and Codefresh | Codefresh<\/title>\n<meta name=\"robots\" content=\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\" \/>\n<link rel=\"canonical\" href=\"https:\/\/codefresh.io\/about-gitops\/combining-progressive-delivery-gitops-continuous-delivery-argo-cd-argo-rollouts-codefresh\/\" \/>\n<meta property=\"og:locale\" content=\"en_US\" \/>\n<meta property=\"og:type\" content=\"article\" \/>\n<meta property=\"og:title\" content=\"Combining Progressive Delivery With GitOps and Continuous Delivery Through Argo CD, Argo Rollouts, and Codefresh\" \/>\n<meta property=\"og:description\" content=\"Progressive delivery is arguably the most reliable and advanced set of deployment practices based on a simple idea. Instead of shutting down the old release and deploying a new one in its place, progressive delivery takes an iterative approach. It gradually increases the reach of a new release. That gives us quite a few benefits &hellip; Read more\" \/>\n<meta property=\"og:url\" content=\"https:\/\/codefresh.io\/about-gitops\/combining-progressive-delivery-gitops-continuous-delivery-argo-cd-argo-rollouts-codefresh\/\" \/>\n<meta property=\"og:site_name\" content=\"Codefresh\" \/>\n<meta property=\"article:publisher\" content=\"https:\/\/www.facebook.com\/codefresh.io\" \/>\n<meta property=\"article:published_time\" content=\"2020-12-07T12:02:51+00:00\" \/>\n<meta property=\"article:modified_time\" content=\"2021-04-19T11:07:20+00:00\" \/>\n<meta property=\"og:image\" content=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/progressive-delivery.jpg\" \/>\n\t<meta property=\"og:image:width\" content=\"1119\" \/>\n\t<meta property=\"og:image:height\" content=\"372\" \/>\n\t<meta property=\"og:image:type\" content=\"image\/jpeg\" \/>\n<meta name=\"twitter:card\" content=\"summary_large_image\" \/>\n<meta name=\"twitter:creator\" content=\"@codefresh\" \/>\n<meta name=\"twitter:site\" content=\"@codefresh\" \/>\n<meta name=\"twitter:label1\" content=\"Written by\" \/>\n\t<meta name=\"twitter:data1\" content=\"Contributor\" \/>\n\t<meta name=\"twitter:label2\" content=\"Est. reading time\" \/>\n\t<meta name=\"twitter:data2\" content=\"30 minutes\" \/>\n<script type=\"application\/ld+json\" class=\"yoast-schema-graph\">{\"@context\":\"https:\/\/schema.org\",\"@graph\":[{\"@type\":\"Organization\",\"@id\":\"https:\/\/codefresh.io\/#organization\",\"name\":\"Codefresh\",\"url\":\"https:\/\/codefresh.io\/\",\"sameAs\":[\"https:\/\/www.facebook.com\/codefresh.io\",\"https:\/\/www.linkedin.com\/company\/codefresh\",\"https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg\",\"https:\/\/twitter.com\/codefresh\"],\"logo\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#logo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"width\":800,\"height\":800,\"caption\":\"Codefresh\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/#logo\"}},{\"@type\":\"WebSite\",\"@id\":\"https:\/\/codefresh.io\/#website\",\"url\":\"https:\/\/codefresh.io\/\",\"name\":\"Codefresh\",\"description\":\"\",\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"potentialAction\":[{\"@type\":\"SearchAction\",\"target\":{\"@type\":\"EntryPoint\",\"urlTemplate\":\"https:\/\/codefresh.io\/?s={search_term_string}\"},\"query-input\":\"required name=search_term_string\"}],\"inLanguage\":\"en-US\"},{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/about-gitops\/combining-progressive-delivery-gitops-continuous-delivery-argo-cd-argo-rollouts-codefresh\/#primaryimage\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/progressive-delivery.jpg\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/progressive-delivery.jpg\",\"width\":1119,\"height\":372},{\"@type\":\"WebPage\",\"@id\":\"https:\/\/codefresh.io\/about-gitops\/combining-progressive-delivery-gitops-continuous-delivery-argo-cd-argo-rollouts-codefresh\/#webpage\",\"url\":\"https:\/\/codefresh.io\/about-gitops\/combining-progressive-delivery-gitops-continuous-delivery-argo-cd-argo-rollouts-codefresh\/\",\"name\":\"Combining Progressive Delivery With GitOps and Continuous Delivery Through Argo CD, Argo Rollouts, and Codefresh | Codefresh\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/#website\"},\"primaryImageOfPage\":{\"@id\":\"https:\/\/codefresh.io\/about-gitops\/combining-progressive-delivery-gitops-continuous-delivery-argo-cd-argo-rollouts-codefresh\/#primaryimage\"},\"datePublished\":\"2020-12-07T12:02:51+00:00\",\"dateModified\":\"2021-04-19T11:07:20+00:00\",\"breadcrumb\":{\"@id\":\"https:\/\/codefresh.io\/about-gitops\/combining-progressive-delivery-gitops-continuous-delivery-argo-cd-argo-rollouts-codefresh\/#breadcrumb\"},\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"ReadAction\",\"target\":[\"https:\/\/codefresh.io\/about-gitops\/combining-progressive-delivery-gitops-continuous-delivery-argo-cd-argo-rollouts-codefresh\/\"]}]},{\"@type\":\"BreadcrumbList\",\"@id\":\"https:\/\/codefresh.io\/about-gitops\/combining-progressive-delivery-gitops-continuous-delivery-argo-cd-argo-rollouts-codefresh\/#breadcrumb\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"name\":\"Home\",\"item\":\"https:\/\/codefresh.io\/\"},{\"@type\":\"ListItem\",\"position\":2,\"name\":\"Combining Progressive Delivery With GitOps and Continuous Delivery Through Argo CD, Argo Rollouts, and Codefresh\"}]},{\"@type\":\"Article\",\"@id\":\"https:\/\/codefresh.io\/about-gitops\/combining-progressive-delivery-gitops-continuous-delivery-argo-cd-argo-rollouts-codefresh\/#article\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/about-gitops\/combining-progressive-delivery-gitops-continuous-delivery-argo-cd-argo-rollouts-codefresh\/#webpage\"},\"author\":{\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/268e5c2e4740502fae6d803783a16c75\"},\"headline\":\"Combining Progressive Delivery With GitOps and Continuous Delivery Through Argo CD, Argo Rollouts, and Codefresh\",\"datePublished\":\"2020-12-07T12:02:51+00:00\",\"dateModified\":\"2021-04-19T11:07:20+00:00\",\"mainEntityOfPage\":{\"@id\":\"https:\/\/codefresh.io\/about-gitops\/combining-progressive-delivery-gitops-continuous-delivery-argo-cd-argo-rollouts-codefresh\/#webpage\"},\"wordCount\":4515,\"commentCount\":0,\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/about-gitops\/combining-progressive-delivery-gitops-continuous-delivery-argo-cd-argo-rollouts-codefresh\/#primaryimage\"},\"thumbnailUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/progressive-delivery.jpg\",\"keywords\":[\"Kubernetes\",\"codefresh\",\"K8s\",\"continuous deployment\",\"cd\",\"GitOps\",\"Argo CD\",\"ArgoCD\",\"Argo\",\"progressive delivery\",\"canary deployments\",\"canaries\",\"Argo Rollouts\"],\"articleSection\":[\"Continuous Deployment\/Delivery\",\"Devops\",\"GitOps\",\"DevOps Tutorials\"],\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"CommentAction\",\"name\":\"Comment\",\"target\":[\"https:\/\/codefresh.io\/about-gitops\/combining-progressive-delivery-gitops-continuous-delivery-argo-cd-argo-rollouts-codefresh\/#respond\"]}]},{\"@type\":\"Person\",\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/268e5c2e4740502fae6d803783a16c75\",\"name\":\"Contributor\",\"image\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#personlogo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/secure.gravatar.com\/avatar\/26bd6dd87bf70f0c1a44721c8b3abbbd?s=96&d=blank&r=g\",\"contentUrl\":\"https:\/\/secure.gravatar.com\/avatar\/26bd6dd87bf70f0c1a44721c8b3abbbd?s=96&d=blank&r=g\",\"caption\":\"Contributor\"},\"url\":\"https:\/\/codefresh.io\/author\/contributor\/\"}]}<\/script>\n<!-- \/ Yoast SEO Premium plugin. -->","yoast_head_json":{"title":"Combining Progressive Delivery With GitOps and Continuous Delivery Through Argo CD, Argo Rollouts, and Codefresh | Codefresh","robots":{"index":"index","follow":"follow","max-snippet":"max-snippet:-1","max-image-preview":"max-image-preview:large","max-video-preview":"max-video-preview:-1"},"canonical":"https:\/\/codefresh.io\/about-gitops\/combining-progressive-delivery-gitops-continuous-delivery-argo-cd-argo-rollouts-codefresh\/","og_locale":"en_US","og_type":"article","og_title":"Combining Progressive Delivery With GitOps and Continuous Delivery Through Argo CD, Argo Rollouts, and Codefresh","og_description":"Progressive delivery is arguably the most reliable and advanced set of deployment practices based on a simple idea. Instead of shutting down the old release and deploying a new one in its place, progressive delivery takes an iterative approach. It gradually increases the reach of a new release. That gives us quite a few benefits &hellip; Read more","og_url":"https:\/\/codefresh.io\/about-gitops\/combining-progressive-delivery-gitops-continuous-delivery-argo-cd-argo-rollouts-codefresh\/","og_site_name":"Codefresh","article_publisher":"https:\/\/www.facebook.com\/codefresh.io","article_published_time":"2020-12-07T12:02:51+00:00","article_modified_time":"2021-04-19T11:07:20+00:00","og_image":[{"width":1119,"height":372,"url":"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/progressive-delivery.jpg","type":"image\/jpeg"}],"twitter_card":"summary_large_image","twitter_creator":"@codefresh","twitter_site":"@codefresh","twitter_misc":{"Written by":"Contributor","Est. reading time":"30 minutes"},"schema":{"@context":"https:\/\/schema.org","@graph":[{"@type":"Organization","@id":"https:\/\/codefresh.io\/#organization","name":"Codefresh","url":"https:\/\/codefresh.io\/","sameAs":["https:\/\/www.facebook.com\/codefresh.io","https:\/\/www.linkedin.com\/company\/codefresh","https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg","https:\/\/twitter.com\/codefresh"],"logo":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#logo","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","width":800,"height":800,"caption":"Codefresh"},"image":{"@id":"https:\/\/codefresh.io\/#logo"}},{"@type":"WebSite","@id":"https:\/\/codefresh.io\/#website","url":"https:\/\/codefresh.io\/","name":"Codefresh","description":"","publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"potentialAction":[{"@type":"SearchAction","target":{"@type":"EntryPoint","urlTemplate":"https:\/\/codefresh.io\/?s={search_term_string}"},"query-input":"required name=search_term_string"}],"inLanguage":"en-US"},{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/about-gitops\/combining-progressive-delivery-gitops-continuous-delivery-argo-cd-argo-rollouts-codefresh\/#primaryimage","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/progressive-delivery.jpg","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/progressive-delivery.jpg","width":1119,"height":372},{"@type":"WebPage","@id":"https:\/\/codefresh.io\/about-gitops\/combining-progressive-delivery-gitops-continuous-delivery-argo-cd-argo-rollouts-codefresh\/#webpage","url":"https:\/\/codefresh.io\/about-gitops\/combining-progressive-delivery-gitops-continuous-delivery-argo-cd-argo-rollouts-codefresh\/","name":"Combining Progressive Delivery With GitOps and Continuous Delivery Through Argo CD, Argo Rollouts, and Codefresh | Codefresh","isPartOf":{"@id":"https:\/\/codefresh.io\/#website"},"primaryImageOfPage":{"@id":"https:\/\/codefresh.io\/about-gitops\/combining-progressive-delivery-gitops-continuous-delivery-argo-cd-argo-rollouts-codefresh\/#primaryimage"},"datePublished":"2020-12-07T12:02:51+00:00","dateModified":"2021-04-19T11:07:20+00:00","breadcrumb":{"@id":"https:\/\/codefresh.io\/about-gitops\/combining-progressive-delivery-gitops-continuous-delivery-argo-cd-argo-rollouts-codefresh\/#breadcrumb"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https:\/\/codefresh.io\/about-gitops\/combining-progressive-delivery-gitops-continuous-delivery-argo-cd-argo-rollouts-codefresh\/"]}]},{"@type":"BreadcrumbList","@id":"https:\/\/codefresh.io\/about-gitops\/combining-progressive-delivery-gitops-continuous-delivery-argo-cd-argo-rollouts-codefresh\/#breadcrumb","itemListElement":[{"@type":"ListItem","position":1,"name":"Home","item":"https:\/\/codefresh.io\/"},{"@type":"ListItem","position":2,"name":"Combining Progressive Delivery With GitOps and Continuous Delivery Through Argo CD, Argo Rollouts, and Codefresh"}]},{"@type":"Article","@id":"https:\/\/codefresh.io\/about-gitops\/combining-progressive-delivery-gitops-continuous-delivery-argo-cd-argo-rollouts-codefresh\/#article","isPartOf":{"@id":"https:\/\/codefresh.io\/about-gitops\/combining-progressive-delivery-gitops-continuous-delivery-argo-cd-argo-rollouts-codefresh\/#webpage"},"author":{"@id":"https:\/\/codefresh.io\/#\/schema\/person\/268e5c2e4740502fae6d803783a16c75"},"headline":"Combining Progressive Delivery With GitOps and Continuous Delivery Through Argo CD, Argo Rollouts, and Codefresh","datePublished":"2020-12-07T12:02:51+00:00","dateModified":"2021-04-19T11:07:20+00:00","mainEntityOfPage":{"@id":"https:\/\/codefresh.io\/about-gitops\/combining-progressive-delivery-gitops-continuous-delivery-argo-cd-argo-rollouts-codefresh\/#webpage"},"wordCount":4515,"commentCount":0,"publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"image":{"@id":"https:\/\/codefresh.io\/about-gitops\/combining-progressive-delivery-gitops-continuous-delivery-argo-cd-argo-rollouts-codefresh\/#primaryimage"},"thumbnailUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/progressive-delivery.jpg","keywords":["Kubernetes","codefresh","K8s","continuous deployment","cd","GitOps","Argo CD","ArgoCD","Argo","progressive delivery","canary deployments","canaries","Argo Rollouts"],"articleSection":["Continuous Deployment\/Delivery","Devops","GitOps","DevOps Tutorials"],"inLanguage":"en-US","potentialAction":[{"@type":"CommentAction","name":"Comment","target":["https:\/\/codefresh.io\/about-gitops\/combining-progressive-delivery-gitops-continuous-delivery-argo-cd-argo-rollouts-codefresh\/#respond"]}]},{"@type":"Person","@id":"https:\/\/codefresh.io\/#\/schema\/person\/268e5c2e4740502fae6d803783a16c75","name":"Contributor","image":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#personlogo","inLanguage":"en-US","url":"https:\/\/secure.gravatar.com\/avatar\/26bd6dd87bf70f0c1a44721c8b3abbbd?s=96&d=blank&r=g","contentUrl":"https:\/\/secure.gravatar.com\/avatar\/26bd6dd87bf70f0c1a44721c8b3abbbd?s=96&d=blank&r=g","caption":"Contributor"},"url":"https:\/\/codefresh.io\/author\/contributor\/"}]}},"acf":[],"_links":{"self":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/18194"}],"collection":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/users\/125"}],"replies":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/comments?post=18194"}],"version-history":[{"count":0,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/18194\/revisions"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media\/18248"}],"wp:attachment":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media?parent=18194"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/categories?post=18194"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/tags?post=18194"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}