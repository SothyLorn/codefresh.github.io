{"id":18210,"date":"2020-12-02T06:33:31","date_gmt":"2020-12-02T14:33:31","guid":{"rendered":"https:\/\/codefresh.io\/?p=18210"},"modified":"2022-03-01T17:10:39","modified_gmt":"2022-03-01T17:10:39","slug":"docker-images-without-docker-practical-guide","status":"publish","type":"post","link":"https:\/\/codefresh.io\/devops\/docker-images-without-docker-practical-guide\/","title":{"rendered":"Docker Images Without Docker &#8212; A Practical Guide"},"content":{"rendered":"<p>The most well-known security flaw in Docker is that it requires root access to build your Docker images with the Docker daemon.<\/p>\n<p>We have all read at least once that you should be careful using root access. This tutorial will take a look at the downsides of using Docker and Docker alternatives to combat those, namely:<\/p>\n<ul>\n<li><a href=\"https:\/\/github.com\/GoogleContainerTools\/kaniko\">Kaniko<\/a><\/li>\n<li><a href=\"https:\/\/buildah.io\/\">Buildah<\/a> &amp; <a href=\"https:\/\/podman.io\/\">Podman<\/a><\/li>\n<\/ul>\n<h2>What\u2019s the Problem?<\/h2>\n<p>To understand why the Docker Daemon is running with root access and how this can become a problem, we first have to understand the Docker architecture (at least on a high level). Container images are specified with the Dockerfile. The Dockerfile details how to <a href=\"https:\/\/docs.docker.com\/engine\/reference\/commandline\/build\/\">build<\/a> an image based on your application and resources. Using Docker, we can use the build command to build our container image. Once you have the image of your Dockerfile, you can <a href=\"https:\/\/docs.docker.com\/engine\/reference\/commandline\/run\/\">run<\/a> it. Upon running the image, a container is created.<\/p>\n<p>Below is a simplified diagram of the Docker architecture, taken directly from the <a href=\"https:\/\/docs.docker.com\/get-started\/overview\/\">official documentation<\/a>.<\/p>\n<figure id=\"attachment_18211\" aria-describedby=\"caption-attachment-18211\" style=\"width: 300px\" class=\"wp-caption aligncenter\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/docker-architecture-overview.png\"><img class=\"wp-image-18211 size-medium\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/docker-architecture-overview-300x235.png\" alt=\"Overview: Docker Architecture\" width=\"300\" height=\"235\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/docker-architecture-overview-300x235.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/docker-architecture-overview-20x16.png 20w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/docker-architecture-overview.png 492w\" sizes=\"(max-width: 300px) 100vw, 300px\" \/><\/a><figcaption id=\"caption-attachment-18211\" class=\"wp-caption-text\">Overview: Docker Architecture<\/figcaption><\/figure>\n<p>The problem with this is that you cannot use Docker directly on your workstation. Docker is composed of a variety of different tools. In most cases, you will only interact with the Docker CLI. However, running an application with Docker means that you have to run the <a href=\"https:\/\/docs.docker.com\/engine\/install\/linux-postinstall\/\">Docker Daemon with root privileges<\/a>. It actually binds to a Unix socket instead of a TCP port. By default, users can only access the Unix socket using <i>sudo<\/i> command, which is owned by the user <i>root<\/i>.<\/p>\n<p>The Docker Daemon is responsible for the state of your containers and images, and facilitates any interaction with \u201cthe outside world.\u201d The Docker CLI is merely used to translate commands into API calls that are sent to the Docker Daemon. This allows you to use a local or remote Docker Daemon.<\/p>\n<p>Running the Docker Daemon locally, you risk that any process that breaks out of the Docker Container will have the same rights as the host operating system. This is why you should only trust your own images that you have written and understand.<\/p>\n<p>The next section will discuss alternatives to Docker. All of the alternatives discussed below can build OCI compatible container images. OCI stands for <a href=\"https:\/\/opencontainers.org\/\">Open Container Initiative<\/a>, which is a project by the Linux Foundation with the goal to define open standards for operating system-level virtualization; more specifically, Linux containers. This includes the runtime specification and the image specification of containers. <a href=\"https:\/\/twitter.com\/fatherlinux\">Scott McCarty<\/a> <a href=\"https:\/\/www.youtube.com\/watch?time_continue=20&amp;v=rlj0UZlvGp0\">discusses in detail <\/a>how different container standards fit together; here are some of the benefits of using container standards:<\/p>\n<ul>\n<li>Higher flexibility between tools. If you can just replace the Docker Daemon in your Kubernetes cluster without noticing a difference, does it matter which tool you are using?<\/li>\n<li>Gain a better understanding of containers &#8212; what actually happens when you run a container?<\/li>\n<li>Higher reliability on your infrastructure. The work that you have put into your existing infrastructure does not become obsolete when you decide to switch to different tools.<\/li>\n<\/ul>\n<h2>Alternative: Buildah &amp; Podman<\/h2>\n<p>Buildah provides a CLI tool that allows users to build OCI or traditional Docker images. Buildah can be used to create and run images from a Dockerfile and without. In our case, we are going to use <a href=\"https:\/\/github.com\/containers\/buildah\">Buildah<\/a> to build the image and <a href=\"https:\/\/github.com\/containers\/podman\">Podman<\/a> to run the image.<\/p>\n<p><b>Relationship between Buildah &amp; Podman<\/b><\/p>\n<p>Buildah and Podman are complementary tools to build and run containers. The main differentiation between the two tools is that Buildah focuses on building OCI container images while Podman specializes in the management of the entire container lifecycle. The commands used in Buildah are quite similar to Docker commands. Buildah replicates the same commands that are found within a Dockerfile to allow users to build images without a Dockerfile.<\/p>\n<p>In comparison, Podman is focused on the entire container lifecycle of OCI images but also supports other container standards. Summarising, it helps you to maintain and modify OCI images, such as pulling and tagging, and allows you to run, and maintain containers created from those images.<\/p>\n<p>The main difference to note between both tools is the concept of a container. Buildah is highly similar to Docker in the way containers are built and managed. Comparing this to Podman, in Podman containers are meant to be long-lived. This difference makes both tools complementary; Buildah can be used to create containers and Podman to manage those.<\/p>\n<p>Furthermore, you cannot commit a Buildah container from within Podman nor vice versa. This is reflected in <a href=\"https:\/\/podman.io\/blogs\/2018\/10\/31\/podman-buildah-relationship.html\">the way that commands of both tools are used<\/a>. For instance, the commit command works differently in Buildah and Podman containers.<\/p>\n<div class=\"table-responsive\"><table style=\"height: 164px;\" width=\"522\">\n<tbody>\n<tr>\n<td><\/td>\n<td><b>Buildah<\/b><\/td>\n<td><b>Podman<\/b><\/td>\n<\/tr>\n<tr>\n<td><b>Focus<\/b><\/td>\n<td>Container Creation<\/td>\n<td>Manage Containers; Entire Container Lifecycle<\/td>\n<\/tr>\n<tr>\n<td><b>Container Management<\/b><\/td>\n<td>Similar to Docker<\/td>\n<td>Containers are meant to be long-lived<\/td>\n<\/tr>\n<tr>\n<td><b>Commands<\/b><\/td>\n<td>Mirroring Docker Commands in functionality<\/td>\n<td>Some commands might be similar but have<br \/>\ndifferent functionality<\/td>\n<\/tr>\n<tr>\n<td><b>Image Standards<\/b><\/td>\n<td>Support OCI images<\/td>\n<td>Support OCI images<\/td>\n<\/tr>\n<\/tbody>\n<\/table><\/div>\n<p><b>Getting started with Buildah and Podman<\/b><\/p>\n<p>Buildah has a variety of different installation options (that you can easily get lost in). We run on Ubuntu 20.04 and followed <a href=\"https:\/\/github.com\/containers\/buildah\/blob\/master\/install.md\">these installation instructions<\/a>:<\/p>\n<pre class=\"\">. \/etc\/os-release\r\n\r\nsudo sh -c \"echo 'deb http:\/\/download.opensuse.org\/repositories\/devel:\/kubic:\/libcontainers:\/stable\/xUbuntu_${VERSION_ID}\/ \/' &gt; \/etc\/apt\/sources.list.d\/devel:kubic:libcontainers:stable.list\"\r\n\r\nwget -nv https:\/\/download.opensuse.org\/repositories\/devel:kubic:libcontainers:stable\/xUbuntu_${VERSION_ID}\/Release.key -O Release.key\r\n\r\nsudo apt-key add - &lt; Release.key\r\n\r\nsudo apt-get update -qq\r\n\r\nsudo apt-get -qq -y install buildah\r\n\r\n<\/pre>\n<p>Make sure that you replace the Version ID with your Ubuntu version (in case you are on Ubuntu) &#8212; in our case, this was 20.04.<\/p>\n<p>To check that the installation was successful, check for Buildah images:<\/p>\n<pre class=\"\">buildah images\r\n<\/pre>\n<p>Next, we will \u00a0<a href=\"https:\/\/podman.io\/getting-started\/installation\">install Podman<\/a>:<\/p>\n<pre class=\"\">. \/etc\/os-release\r\n\r\necho \"deb https:\/\/download.opensuse.org\/repositories\/devel:\/kubic:\/libcontainers:\/testing\/xUbuntu_${VERSION_ID}\/ \/\" | sudo tee \/etc\/apt\/sources.list.d\/devel:kubic:libcontainers:testing.list\r\n\r\ncurl -L https:\/\/download.opensuse.org\/repositories\/devel:\/kubic:\/libcontainers:\/testing\/xUbuntu_${VERSION_ID}\/Release.key | sudo apt-key add -\r\n\r\nsudo apt-get update -qq\r\n\r\nsudo apt-get -qq -y install podman\r\n\r\n<\/pre>\n<p>Once done we can run the following to verify that our installation was successful:<\/p>\n<pre class=\"\">podman --help \r\n<\/pre>\n<p>Let\u2019s go ahead and build an image with Buildah. For this, we are using the <a href=\"https:\/\/github.com\/anais-codefresh\/docker-alternatives\">following repository<\/a>. The repository already has a Dockerfile that we can use. However, you can also create or use your own.<\/p>\n<pre># clone the repository\r\ngit clone git@github.com:anais-codefresh\/docker-alternatives\r\n<\/pre>\n<pre># cd into the cloned repository \r\ncd docker-alternatives\/buildahandpodman\r\n<\/pre>\n<p>Next, we are going to use Buildah to build the image based on our Dockerfile.<\/p>\n<pre>buildah bud -t buildah-example\r\n<\/pre>\n<p>You should now see the different steps of the Dockerfile executed.<\/p>\n<figure id=\"attachment_18212\" aria-describedby=\"caption-attachment-18212\" style=\"width: 300px\" class=\"wp-caption aligncenter\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/dockerfile-buildah-output.png\"><img class=\"size-medium wp-image-18212\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/dockerfile-buildah-output-300x226.png\" alt=\"dockerfile-buildah-output\" width=\"300\" height=\"226\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/dockerfile-buildah-output-300x226.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/dockerfile-buildah-output-20x15.png 20w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/dockerfile-buildah-output.png 757w\" sizes=\"(max-width: 300px) 100vw, 300px\" \/><\/a><figcaption id=\"caption-attachment-18212\" class=\"wp-caption-text\">Output building the image with Buildah<\/figcaption><\/figure>\n<p>We can see the images built with Buildah by running:<\/p>\n<pre>podman images\r\n<\/pre>\n<p>And run the container using Podman:<\/p>\n<pre>podman run -dt -p 8080:8080\/tcp \r\n<\/pre>\n<p>We can now view our application on localhost:8080. All Podman commands are listed in <a href=\"https:\/\/podman.readthedocs.io\/en\/latest\/Commands.html\">their documentation<\/a>.<\/p>\n<figure id=\"attachment_18213\" aria-describedby=\"caption-attachment-18213\" style=\"width: 300px\" class=\"wp-caption aligncenter\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/running-go-application-with-buildah-and-podman.png\"><img class=\"size-medium wp-image-18213\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/running-go-application-with-buildah-and-podman-300x81.png\" alt=\"running-go-application-with-buildah-and-podman\" width=\"300\" height=\"81\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/running-go-application-with-buildah-and-podman-300x81.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/running-go-application-with-buildah-and-podman-20x5.png 20w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/running-go-application-with-buildah-and-podman.png 454w\" sizes=\"(max-width: 300px) 100vw, 300px\" \/><\/a><figcaption id=\"caption-attachment-18213\" class=\"wp-caption-text\">Running Go application with Buildah and Podman<\/figcaption><\/figure>\n<h2>Alternative: Kaniko<\/h2>\n<p><a href=\"https:\/\/github.com\/GoogleContainerTools\/kaniko\">Kaniko<\/a> was started and is maintained by Google. In short, it is an open source tool that allows users to build images even without granting it root access. These images are built inside a container or a Kubernetes cluster. Unlike the Docker daemon, Kaniko executes all commands inside the userspace.<\/p>\n<p>There are several different ways to deploy and run Kaniko:<\/p>\n<ul>\n<li><a href=\"https:\/\/github.com\/GoogleContainerTools\/kaniko#running-kaniko-in-a-kubernetes-cluster\">In a Kubernetes cluster<\/a><\/li>\n<li><a href=\"https:\/\/github.com\/GoogleContainerTools\/kaniko#running-kaniko-in-gvisor\">In gVisor<\/a><\/li>\n<li><a href=\"https:\/\/github.com\/GoogleContainerTools\/kaniko#running-kaniko-in-google-cloud-build\">In Google Cloud Build<\/a><\/li>\n<li><a href=\"https:\/\/github.com\/GoogleContainerTools\/kaniko#running-kaniko-in-docker\">In Docker<\/a><\/li>\n<\/ul>\n<p>To run a container, Kaniko needs three arguments:<\/p>\n<ul>\n<li>A Dockerfile<\/li>\n<li>A Build Context: The directory containing a Dockerfile which Kaniko can use to build your image &#8212; e.g. COPY in the Dockerfile should refer to a file in the build context<\/li>\n<li>The name of the registry to which the final image should be pushed<\/li>\n<\/ul>\n<p><b>Getting started with Kaniko<\/b><\/p>\n<p>We will use Kaniko inside a local Kubernetes Cluster, using MicroK8s. To get started with Kaniko and to follow the next steps, we assume that you have the following set-up:<\/p>\n<p>Either a local Kubernetes Cluster or you are able to access a remote cluster on your machine.<\/p>\n<p>We are going to test Kaniko with an existing Dockerfile. The application we are going to use is a basic <a href=\"https:\/\/github.com\/anais-codefresh\/docker-alternatives\">Go application<\/a>. You can either clone the application or use your own app and Dockerfile.<\/p>\n<pre class=\"\"># Clone the repository\r\ngit clone git@github.com:anais-codefresh\/docker-alternatives\r\n<\/pre>\n<pre># cd into the kaniko repository\r\ncd docker-alternatives\/kaniko\r\n<\/pre>\n<p>Create a file called <a href=\"https:\/\/github.com\/anais-codefresh\/docker-alternatives\/blob\/master\/kaniko\/volume.yaml\">volume.yaml<\/a> that will specify our <a href=\"https:\/\/kubernetes.io\/docs\/concepts\/storage\/persistent-volumes\/\">PersistentVolume<\/a>. This is used to run Kaniko inside of Kubernetes locally.<\/p>\n<pre>touch volume.yaml\r\n<\/pre>\n<p>Go ahead and paste the following into your file:<\/p>\n<pre>apiVersion: v1\r\nkind: PersistentVolume\r\nmetadata:\r\n name: dockerfile\r\n labels:\r\n   type: local\r\nspec:\r\n capacity:\r\n   storage: 10Gi\r\n accessModes:\r\n   - ReadWriteOnce\r\n storageClassName: local-storage\r\n hostPath:\r\n   path:  # replace with local directory, such as \"\/home\/\/kaniko\"\r\n<\/pre>\n<p>You will have to replace the path to your directory (the one where the files are at). The easiest way to do this is to run:<\/p>\n<pre>pwd\r\n<\/pre>\n<p>And copy and paste the file path.<\/p>\n<p>Next, we need a <a href=\"https:\/\/github.com\/anais-codefresh\/docker-alternatives\/blob\/master\/kaniko\/volume-claim.yaml\">second file<\/a> that volume is mounted to:<\/p>\n<pre>touch volume-claim.yaml\r\n<\/pre>\n<p>Paste the following content:<\/p>\n<pre class=\"\">kind: PersistentVolumeClaim\r\napiVersion: v1\r\nmetadata:\r\n name: dockerfile-claim\r\nspec:\r\n accessModes:\r\n   - ReadWriteOnce\r\n resources:\r\n   requests:\r\n     storage: 8Gi\r\n storageClassName: local-storage\r\n<\/pre>\n<p>Lastly, we need to give Kubernetes the specifications on the pod it is supposed to run.<\/p>\n<p>Add the <a href=\"https:\/\/github.com\/anais-codefresh\/docker-alternatives\/blob\/master\/kaniko\/pod.yaml\">pod.yaml<\/a> file:<\/p>\n<pre>touch pod.yaml\r\n<\/pre>\n<p>And paste the following content:<\/p>\n<pre>apiVersion: v1\r\nkind: Pod\r\nmetadata:\r\n name: kaniko\r\nspec:\r\n containers:\r\n - name: kaniko\r\n   image: gcr.io\/kaniko-project\/executor:latest\r\n   args: [\"--dockerfile=Dockerfile\",\r\n           \"--context=dir:\/\/workspace\",\r\n           \"--destination=\/\"] # replace with your dockerhub account\r\n   volumeMounts:\r\n     - name: kaniko-secret\r\n       mountPath: \/kaniko\/.docker\r\n     - name: dockerfile-storage\r\n       mountPath: \/workspace\r\n restartPolicy: Never\r\n volumes:\r\n   - name: kaniko-secret\r\n     secret:\r\n       secretName: regcred\r\n       items:\r\n         - key: .dockerconfigjson\r\n           path: config.json\r\n   - name: dockerfile-storage\r\n     persistentVolumeClaim:\r\n       claimName: dockerfile-claim\r\n<\/pre>\n<p>Modifications that you have to make to the pod.yaml file:<\/p>\n<ul>\n<li>Please provide your Docker Hub account name and the repository to which you want to push.\n<pre class=\"\">\"--destination=user-name\/repo\"<\/pre>\n<\/li>\n<li>Make sure that you include the right location to your Dockerfile. In our case, the Dockerfile is in the same repository as the yaml files.\n<pre>\u201c--dockerfile=Dockerfile\u201d<\/pre>\n<\/li>\n<\/ul>\n<p>Now that we have all of this prepared, we need to create the Kubernetes secret to allow Kaniko to push the Docker image to the Docker Hub; note that you can also use another registry.<\/p>\n<pre class=\"\">kubectl create secret docker-registry regcred --docker-server=\"https:\/\/index.docker.io\/v1\/\" --docker-username=\"your-name\" --docker-password=\"your-pword\" --docker-email=\"your-email\"\r\n<\/pre>\n<ul>\n<li>&lt;your-registry-server&gt;\u00a0 is: (<a href=\"https:\/\/index.docker.io\/v1\/\">https:\/\/index.docker.io\/v1\/<\/a> for DockerHub)<\/li>\n<li>&lt;your-name&gt; is your Docker username.<\/li>\n<li>&lt;your-pword&gt; is your Docker password.<\/li>\n<li>&lt;your-email&gt; is your Docker email.<\/li>\n<\/ul>\n<p>In our case, we had to put the values in quotes e.g. \u201canaisurlichs\u201d for your username.<\/p>\n<p>Next, we are going to create our persistent volume. Note that it is important that you create the secret first before you create the volumes and the pod.<\/p>\n<pre># create persistent volume\r\n$ kubectl create -f volume.yaml\r\npersistentvolume\/dockerfile created\r\n<\/pre>\n<pre># create persistent volume claim\r\n$ kubectl create -f volume-claim.yaml\r\npersistentvolumeclaim\/dockerfile-claim created\r\n<\/pre>\n<pre># check whether the volume mounted correctly\r\n$ kubectl get pv dockerfile\r\nNAME         CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                      STORAGECLASS    REASON   AGE\r\ndockerfile   10Gi       RWO            Retain           Bound    default\/dockerfile-claim   local-storage            1m\r\n<\/pre>\n<p>Lastly, we are creating the pods:<\/p>\n<pre>kubectl create -f pod.yaml\r\n<\/pre>\n<figure id=\"attachment_18214\" aria-describedby=\"caption-attachment-18214\" style=\"width: 300px\" class=\"wp-caption aligncenter\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/using-kaniko-console-output.png\"><img class=\"size-medium wp-image-18214\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/using-kaniko-console-output-300x48.png\" alt=\"using-kaniko-console-output\" width=\"300\" height=\"48\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/using-kaniko-console-output-300x48.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/using-kaniko-console-output-1024x165.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/using-kaniko-console-output-768x124.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/using-kaniko-console-output-20x3.png 20w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/using-kaniko-console-output.png 1220w\" sizes=\"(max-width: 300px) 100vw, 300px\" \/><\/a><figcaption id=\"caption-attachment-18214\" class=\"wp-caption-text\">Using Kaniko console output<\/figcaption><\/figure>\n<p>You can now view the pod:<\/p>\n<pre>kubectl get pods<\/pre>\n<p>It took some time for us to figure out how to get started with Kaniko. In our case, we used Kaniko in Kubernetes. Alternatively, you could also use the Docker Daemon to run your container images. However, in this case, there would not be much of a difference between using Docker directly. If you would still like to do this, you do not require any of the files listed above. Instead, you would just run the following command with similar parameters to what we have specified in pod.yaml.<\/p>\n<p>First, we need a config.json file in our current directory that holds our Docker login:<\/p>\n<pre>{\r\n   \"auths\": {\r\n       \"https:\/\/index.docker.io\/v1\/\": {\r\n           \"auth\": \"xxxxxxxxxxxxxxx\"\r\n       }\r\n   }\r\n}\r\n<\/pre>\n<p>On Ubuntu, you can encode your credentials with:<\/p>\n<pre>echo -n \u201cusername:password\u201d | base64\r\n<\/pre>\n<p>Use the encoded credentials within your config.json file. Next, we can build and push our Docker image using:<\/p>\n<pre>docker run -ti --rm -v `pwd`:\/workspace -v `pwd`\/config.json:\/kaniko\/.docker\/config.json:ro gcr.io\/kaniko-project\/executor:latest --dockerfile=Dockerfile --destination=yourimagename\r\n<\/pre>\n<p>Note that this command might take a while to finish. Below is the expected output:<\/p>\n<figure id=\"attachment_18215\" aria-describedby=\"caption-attachment-18215\" style=\"width: 300px\" class=\"wp-caption aligncenter\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/kaniko-console-output.png\"><img class=\"size-medium wp-image-18215\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/kaniko-console-output-300x168.png\" alt=\"kaniko-console-output\" width=\"300\" height=\"168\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/kaniko-console-output-300x168.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/kaniko-console-output-1024x572.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/kaniko-console-output-768x429.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/kaniko-console-output-20x11.png 20w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/kaniko-console-output.png 1312w\" sizes=\"(max-width: 300px) 100vw, 300px\" \/><\/a><figcaption id=\"caption-attachment-18215\" class=\"wp-caption-text\">Kaniko console output<\/figcaption><\/figure>\n<h2>The Difference between Kaniko and Buildah<\/h2>\n<p>Buildah allows you to build images without a Dockerfile. The flexibility of building images without Dockerfiles allows for the integration of other scripting languages into the build process. Since Buildah does not rely on a Daemon but instead on a comprehensive API written in Golang, commands can be translated into other tools.<\/p>\n<p>In comparison, Kaniko can be run with and without root access to build a container image and push it to a registry. While Kaniko is supported by Google, Podman has been developed by RedHat. Both projects are actively maintained.<\/p>\n<p>Additional differences that we have noticed while using both tools:<\/p>\n<ul>\n<li>Depending on your operating system, it might be quite difficult to install any of the mentioned tools.<\/li>\n<li>In case you are already using Kubernetes, Kaniko allows you to get started right away. However, you may have to invest some time into setting up the yaml files.<\/li>\n<li>Podman and Buildah are quite intuitive to use and use similar commands to those that are defined by Docker.<\/li>\n<li>Additionally, Buildah has better tutorials and further documentation available, which might become handy in the long term.<\/li>\n<li>You can run both Kaniko and Buildah from within a container. However, it is <a href=\"https:\/\/developers.redhat.com\/blog\/2019\/08\/14\/best-practices-for-running-buildah-in-a-container\/\">not as straightforward using Buildah<\/a>.<\/li>\n<li>We built the same image using Kaniko and then using Buildah to compare the image size; the image build by Kaniko using Docker is about half the size of the one built by Buildah.<\/li>\n<\/ul>\n<p>Image built with Buildah and Podman:<\/p>\n<figure id=\"attachment_18216\" aria-describedby=\"caption-attachment-18216\" style=\"width: 300px\" class=\"wp-caption aligncenter\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/podman-image-size.png\"><img class=\"size-medium wp-image-18216\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/podman-image-size-300x23.png\" alt=\"podman-buildah-image-size\" width=\"300\" height=\"23\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/podman-image-size-300x23.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/podman-image-size-768x58.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/podman-image-size-20x2.png 20w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/podman-image-size.png 849w\" sizes=\"(max-width: 300px) 100vw, 300px\" \/><\/a><figcaption id=\"caption-attachment-18216\" class=\"wp-caption-text\">Image size built with Buildah and Podman<\/figcaption><\/figure>\n<p>Image built with Kaniko:<\/p>\n<figure id=\"attachment_18218\" aria-describedby=\"caption-attachment-18218\" style=\"width: 300px\" class=\"wp-caption aligncenter\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/kaniko-image-size.png\"><img class=\"size-medium wp-image-18218\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/kaniko-image-size-300x59.png\" alt=\"kaniko-image-size\" width=\"300\" height=\"59\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/kaniko-image-size-300x59.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/kaniko-image-size-1024x202.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/kaniko-image-size-768x152.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/kaniko-image-size-20x4.png 20w, https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/kaniko-image-size.png 1267w\" sizes=\"(max-width: 300px) 100vw, 300px\" \/><\/a><figcaption id=\"caption-attachment-18218\" class=\"wp-caption-text\">Image size built with Kaniko<\/figcaption><\/figure>\n<p>Overall, it depends on your use case and the tools that you are already using to build and manage your containers. Generally, it would not make much sense to use Kaniko with Docker. However, if you are already heavily using Kubernetes, then it would be an easy integration and a great alternative. In contrast, the combination of Buildah and Podman is a better alternative if you want to directly replace Docker.<\/p>\n<h2>Summary<\/h2>\n<p>In this tutorial, we compared two different alternatives to using Docker directly. Neither has been as easy to get started with as Docker. In summary, if you are already using Kubernetes, Kaniko would be a good alternative; if not, we would prefer Buildah and Podman. As you can tell, which tool would provide the best alternative depends heavily on your use case.<\/p>\n<hr \/>\n<p>Are you using Docker or either of the alternatives detailed in this tutorial? Let us know about your experience in the comments!<\/p>\n<input class=\"fooboxshare_post_id\" type=\"hidden\" value=\"18210\"\/>","protected":false},"excerpt":{"rendered":"<p>The most well-known security flaw in Docker is that it requires root access to build your Docker images with the Docker daemon. We have all read at least once that you should be careful using root access. This tutorial will take a look at the downsides of using Docker and Docker alternatives to combat those, &hellip; <a href=\"https:\/\/codefresh.io\/devops\/docker-images-without-docker-practical-guide\/\">Read more<\/a><\/p>\n","protected":false},"author":82,"featured_media":18220,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[5467,8,6],"tags":[14,24,4246,5515,5560,5566,5567,5568,5569,5570,5571],"yoast_head":"<!-- This site is optimized with the Yoast SEO Premium plugin v17.9 (Yoast SEO v18.4.1) - https:\/\/yoast.com\/wordpress\/plugins\/seo\/ -->\n<title>Docker Images Without Docker - A Practical Guide<\/title>\n<meta name=\"description\" content=\"You should be careful using root access. In this tutorial, we&#039;ll compare two different alternatives to using Docker directly.\" \/>\n<meta name=\"robots\" content=\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\" \/>\n<link rel=\"canonical\" href=\"https:\/\/codefresh.io\/devops\/docker-images-without-docker-practical-guide\/\" \/>\n<meta property=\"og:locale\" content=\"en_US\" \/>\n<meta property=\"og:type\" content=\"article\" \/>\n<meta property=\"og:title\" content=\"Docker Images Without Docker -- A Practical Guide\" \/>\n<meta property=\"og:description\" content=\"You should be careful using root access. In this tutorial, we&#039;ll compare two different alternatives to using Docker directly.\" \/>\n<meta property=\"og:url\" content=\"https:\/\/codefresh.io\/devops\/docker-images-without-docker-practical-guide\/\" \/>\n<meta property=\"og:site_name\" content=\"Codefresh\" \/>\n<meta property=\"article:publisher\" content=\"https:\/\/www.facebook.com\/codefresh.io\" \/>\n<meta property=\"article:published_time\" content=\"2020-12-02T14:33:31+00:00\" \/>\n<meta property=\"article:modified_time\" content=\"2022-03-01T17:10:39+00:00\" \/>\n<meta property=\"og:image\" content=\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/dockerless-header.png\" \/>\n\t<meta property=\"og:image:width\" content=\"1640\" \/>\n\t<meta property=\"og:image:height\" content=\"624\" \/>\n\t<meta property=\"og:image:type\" content=\"image\/png\" \/>\n<meta name=\"twitter:card\" content=\"summary_large_image\" \/>\n<meta name=\"twitter:creator\" content=\"@urlichsanais\" \/>\n<meta name=\"twitter:site\" content=\"@codefresh\" \/>\n<meta name=\"twitter:label1\" content=\"Written by\" \/>\n\t<meta name=\"twitter:data1\" content=\"Anais Urlichs\" \/>\n\t<meta name=\"twitter:label2\" content=\"Est. reading time\" \/>\n\t<meta name=\"twitter:data2\" content=\"12 minutes\" \/>\n<script type=\"application\/ld+json\" class=\"yoast-schema-graph\">{\"@context\":\"https:\/\/schema.org\",\"@graph\":[{\"@type\":\"Organization\",\"@id\":\"https:\/\/codefresh.io\/#organization\",\"name\":\"Codefresh\",\"url\":\"https:\/\/codefresh.io\/\",\"sameAs\":[\"https:\/\/www.facebook.com\/codefresh.io\",\"https:\/\/www.linkedin.com\/company\/codefresh\",\"https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg\",\"https:\/\/twitter.com\/codefresh\"],\"logo\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#logo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"width\":800,\"height\":800,\"caption\":\"Codefresh\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/#logo\"}},{\"@type\":\"WebSite\",\"@id\":\"https:\/\/codefresh.io\/#website\",\"url\":\"https:\/\/codefresh.io\/\",\"name\":\"Codefresh\",\"description\":\"\",\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"potentialAction\":[{\"@type\":\"SearchAction\",\"target\":{\"@type\":\"EntryPoint\",\"urlTemplate\":\"https:\/\/codefresh.io\/?s={search_term_string}\"},\"query-input\":\"required name=search_term_string\"}],\"inLanguage\":\"en-US\"},{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/devops\/docker-images-without-docker-practical-guide\/#primaryimage\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/dockerless-header.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/dockerless-header.png\",\"width\":1640,\"height\":624,\"caption\":\"dockerless-header\"},{\"@type\":\"WebPage\",\"@id\":\"https:\/\/codefresh.io\/devops\/docker-images-without-docker-practical-guide\/#webpage\",\"url\":\"https:\/\/codefresh.io\/devops\/docker-images-without-docker-practical-guide\/\",\"name\":\"Docker Images Without Docker - A Practical Guide\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/#website\"},\"primaryImageOfPage\":{\"@id\":\"https:\/\/codefresh.io\/devops\/docker-images-without-docker-practical-guide\/#primaryimage\"},\"datePublished\":\"2020-12-02T14:33:31+00:00\",\"dateModified\":\"2022-03-01T17:10:39+00:00\",\"description\":\"You should be careful using root access. In this tutorial, we'll compare two different alternatives to using Docker directly.\",\"breadcrumb\":{\"@id\":\"https:\/\/codefresh.io\/devops\/docker-images-without-docker-practical-guide\/#breadcrumb\"},\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"ReadAction\",\"target\":[\"https:\/\/codefresh.io\/devops\/docker-images-without-docker-practical-guide\/\"]}]},{\"@type\":\"BreadcrumbList\",\"@id\":\"https:\/\/codefresh.io\/devops\/docker-images-without-docker-practical-guide\/#breadcrumb\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"name\":\"Home\",\"item\":\"https:\/\/codefresh.io\/\"},{\"@type\":\"ListItem\",\"position\":2,\"name\":\"Docker Images Without Docker &#8212; A Practical Guide\"}]},{\"@type\":\"Article\",\"@id\":\"https:\/\/codefresh.io\/devops\/docker-images-without-docker-practical-guide\/#article\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/devops\/docker-images-without-docker-practical-guide\/#webpage\"},\"author\":{\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/8b7465f259c87e2ad71c81f4cfbf6487\"},\"headline\":\"Docker Images Without Docker &#8212; A Practical Guide\",\"datePublished\":\"2020-12-02T14:33:31+00:00\",\"dateModified\":\"2022-03-01T17:10:39+00:00\",\"mainEntityOfPage\":{\"@id\":\"https:\/\/codefresh.io\/devops\/docker-images-without-docker-practical-guide\/#webpage\"},\"wordCount\":2127,\"commentCount\":9,\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/devops\/docker-images-without-docker-practical-guide\/#primaryimage\"},\"thumbnailUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/dockerless-header.png\",\"keywords\":[\"docker\",\"Containers\",\"comparison\",\"tutorial\",\"docker images\",\"docker alternatives\",\"kaniko\",\"buildah\",\"podman\",\"difference\",\"alternative\"],\"articleSection\":[\"Devops\",\"Docker Tutorials\",\"How Tos\"],\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"CommentAction\",\"name\":\"Comment\",\"target\":[\"https:\/\/codefresh.io\/devops\/docker-images-without-docker-practical-guide\/#respond\"]}]},{\"@type\":\"Person\",\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/8b7465f259c87e2ad71c81f4cfbf6487\",\"name\":\"Anais Urlichs\",\"image\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#personlogo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/secure.gravatar.com\/avatar\/f8e8faa1d1e7bf3f82b40b9d1f1587c4?s=96&d=blank&r=g\",\"contentUrl\":\"https:\/\/secure.gravatar.com\/avatar\/f8e8faa1d1e7bf3f82b40b9d1f1587c4?s=96&d=blank&r=g\",\"caption\":\"Anais Urlichs\"},\"description\":\"Ana\u00efs is a Developer Evangelist at Codefresh, the modern, fast, and powerful CI\/CD &amp; GitOps automation platform that streamlines your pipelines. When she is not advocating DevOps best practices, she runs her own YouTube Channel centered around Kubernetes. Before Codefresh, she worked in the blockchain space, contributing to Community Management and Developer Relations of open source projects. Her passion lies in making tools and projects more accessible to developers and community members.\",\"sameAs\":[\"https:\/\/twitter.com\/urlichsanais\"],\"url\":\"https:\/\/codefresh.io\/author\/anais-codefresh\/\"}]}<\/script>\n<!-- \/ Yoast SEO Premium plugin. -->","yoast_head_json":{"title":"Docker Images Without Docker - A Practical Guide","description":"You should be careful using root access. In this tutorial, we'll compare two different alternatives to using Docker directly.","robots":{"index":"index","follow":"follow","max-snippet":"max-snippet:-1","max-image-preview":"max-image-preview:large","max-video-preview":"max-video-preview:-1"},"canonical":"https:\/\/codefresh.io\/devops\/docker-images-without-docker-practical-guide\/","og_locale":"en_US","og_type":"article","og_title":"Docker Images Without Docker -- A Practical Guide","og_description":"You should be careful using root access. In this tutorial, we'll compare two different alternatives to using Docker directly.","og_url":"https:\/\/codefresh.io\/devops\/docker-images-without-docker-practical-guide\/","og_site_name":"Codefresh","article_publisher":"https:\/\/www.facebook.com\/codefresh.io","article_published_time":"2020-12-02T14:33:31+00:00","article_modified_time":"2022-03-01T17:10:39+00:00","og_image":[{"width":1640,"height":624,"url":"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/dockerless-header.png","type":"image\/png"}],"twitter_card":"summary_large_image","twitter_creator":"@urlichsanais","twitter_site":"@codefresh","twitter_misc":{"Written by":"Anais Urlichs","Est. reading time":"12 minutes"},"schema":{"@context":"https:\/\/schema.org","@graph":[{"@type":"Organization","@id":"https:\/\/codefresh.io\/#organization","name":"Codefresh","url":"https:\/\/codefresh.io\/","sameAs":["https:\/\/www.facebook.com\/codefresh.io","https:\/\/www.linkedin.com\/company\/codefresh","https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg","https:\/\/twitter.com\/codefresh"],"logo":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#logo","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","width":800,"height":800,"caption":"Codefresh"},"image":{"@id":"https:\/\/codefresh.io\/#logo"}},{"@type":"WebSite","@id":"https:\/\/codefresh.io\/#website","url":"https:\/\/codefresh.io\/","name":"Codefresh","description":"","publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"potentialAction":[{"@type":"SearchAction","target":{"@type":"EntryPoint","urlTemplate":"https:\/\/codefresh.io\/?s={search_term_string}"},"query-input":"required name=search_term_string"}],"inLanguage":"en-US"},{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/devops\/docker-images-without-docker-practical-guide\/#primaryimage","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/dockerless-header.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/dockerless-header.png","width":1640,"height":624,"caption":"dockerless-header"},{"@type":"WebPage","@id":"https:\/\/codefresh.io\/devops\/docker-images-without-docker-practical-guide\/#webpage","url":"https:\/\/codefresh.io\/devops\/docker-images-without-docker-practical-guide\/","name":"Docker Images Without Docker - A Practical Guide","isPartOf":{"@id":"https:\/\/codefresh.io\/#website"},"primaryImageOfPage":{"@id":"https:\/\/codefresh.io\/devops\/docker-images-without-docker-practical-guide\/#primaryimage"},"datePublished":"2020-12-02T14:33:31+00:00","dateModified":"2022-03-01T17:10:39+00:00","description":"You should be careful using root access. In this tutorial, we'll compare two different alternatives to using Docker directly.","breadcrumb":{"@id":"https:\/\/codefresh.io\/devops\/docker-images-without-docker-practical-guide\/#breadcrumb"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https:\/\/codefresh.io\/devops\/docker-images-without-docker-practical-guide\/"]}]},{"@type":"BreadcrumbList","@id":"https:\/\/codefresh.io\/devops\/docker-images-without-docker-practical-guide\/#breadcrumb","itemListElement":[{"@type":"ListItem","position":1,"name":"Home","item":"https:\/\/codefresh.io\/"},{"@type":"ListItem","position":2,"name":"Docker Images Without Docker &#8212; A Practical Guide"}]},{"@type":"Article","@id":"https:\/\/codefresh.io\/devops\/docker-images-without-docker-practical-guide\/#article","isPartOf":{"@id":"https:\/\/codefresh.io\/devops\/docker-images-without-docker-practical-guide\/#webpage"},"author":{"@id":"https:\/\/codefresh.io\/#\/schema\/person\/8b7465f259c87e2ad71c81f4cfbf6487"},"headline":"Docker Images Without Docker &#8212; A Practical Guide","datePublished":"2020-12-02T14:33:31+00:00","dateModified":"2022-03-01T17:10:39+00:00","mainEntityOfPage":{"@id":"https:\/\/codefresh.io\/devops\/docker-images-without-docker-practical-guide\/#webpage"},"wordCount":2127,"commentCount":9,"publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"image":{"@id":"https:\/\/codefresh.io\/devops\/docker-images-without-docker-practical-guide\/#primaryimage"},"thumbnailUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2020\/12\/dockerless-header.png","keywords":["docker","Containers","comparison","tutorial","docker images","docker alternatives","kaniko","buildah","podman","difference","alternative"],"articleSection":["Devops","Docker Tutorials","How Tos"],"inLanguage":"en-US","potentialAction":[{"@type":"CommentAction","name":"Comment","target":["https:\/\/codefresh.io\/devops\/docker-images-without-docker-practical-guide\/#respond"]}]},{"@type":"Person","@id":"https:\/\/codefresh.io\/#\/schema\/person\/8b7465f259c87e2ad71c81f4cfbf6487","name":"Anais Urlichs","image":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#personlogo","inLanguage":"en-US","url":"https:\/\/secure.gravatar.com\/avatar\/f8e8faa1d1e7bf3f82b40b9d1f1587c4?s=96&d=blank&r=g","contentUrl":"https:\/\/secure.gravatar.com\/avatar\/f8e8faa1d1e7bf3f82b40b9d1f1587c4?s=96&d=blank&r=g","caption":"Anais Urlichs"},"description":"Ana\u00efs is a Developer Evangelist at Codefresh, the modern, fast, and powerful CI\/CD &amp; GitOps automation platform that streamlines your pipelines. When she is not advocating DevOps best practices, she runs her own YouTube Channel centered around Kubernetes. Before Codefresh, she worked in the blockchain space, contributing to Community Management and Developer Relations of open source projects. Her passion lies in making tools and projects more accessible to developers and community members.","sameAs":["https:\/\/twitter.com\/urlichsanais"],"url":"https:\/\/codefresh.io\/author\/anais-codefresh\/"}]}},"acf":[],"_links":{"self":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/18210"}],"collection":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/users\/82"}],"replies":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/comments?post=18210"}],"version-history":[{"count":3,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/18210\/revisions"}],"predecessor-version":[{"id":21732,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/18210\/revisions\/21732"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media\/18220"}],"wp:attachment":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media?parent=18210"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/categories?post=18210"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/tags?post=18210"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}