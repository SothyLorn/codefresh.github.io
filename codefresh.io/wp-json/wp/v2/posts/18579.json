{"id":18579,"date":"2021-01-20T08:48:42","date_gmt":"2021-01-20T16:48:42","guid":{"rendered":"https:\/\/codefresh.io\/?p=18579"},"modified":"2022-02-15T14:25:06","modified_gmt":"2022-02-15T14:25:06","slug":"kubernetes-antipatterns-3","status":"publish","type":"post","link":"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-3\/","title":{"rendered":"Kubernetes Deployment Antipatterns &#8211; part 3"},"content":{"rendered":"<p>This is the third and last part in our Kubernetes Anti-patterns series. See also <a href=\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-1\/\">part 1 <\/a> and <a href=\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-2\/\">part 2<\/a> for the previous anti-patterns. You can also download <a href=\"https:\/\/codefresh.io\/ebooks\/kubernetes-anti-patterns-ebook\/\">all 3 parts in a PDF ebook<\/a>.<\/p>\n<h2>Anti-pattern 11 &#8211; Misusing Health probes<\/h2>\n<p>Apart from resource limits, if you are moving your application to Kubernetes you should take into account the <a href=\"https:\/\/kubernetes.io\/docs\/tasks\/configure-pod-container\/configure-liveness-readiness-startup-probes\/\">health probe settings<\/a>.<\/p>\n<p>By default, a Kubernetes application has no health probes unless you explicitly set them up. Like resource limits, you should consider health probes an essential part of your Kubernetes deployments. This means that all your applications should have resource limits AND health probes when deployed in any cluster of any type.<\/p>\n<p>Health probes decide when and if your application is ready to accept traffic. As a developer you need to understand how Kubernetes is going to use your readiness and liveness endpoints and the implications of each one (especially what a timeout for each one means).<\/p>\n<p>In summary:<\/p>\n<ol>\n<li>Startup probe =&gt; Checks the initial boot of your applications. It runs only once<\/li>\n<li>Readiness probe =&gt; Checks if your application can respond to traffic. Runs all the time. If it fails Kubernetes will stop routing traffic to your app (and will try later)<\/li>\n<li>Liveness probe =&gt; Checks if your application is in a proper working state. Runs all the time. If it fails Kubernetes will assume that your app is stuck and will restart it.<\/li>\n<\/ol>\n<p>Spend some time to understand the effects of each health probe and evaluate all the <a href=\"https:\/\/docs.spring.io\/spring-boot\/docs\/current\/reference\/html\/production-ready-features.html#production-ready-kubernetes-probes\">best practices for your programming framework<\/a>.<\/p>\n<p>Some of the common pitfalls are:<\/p>\n<ul>\n<li>Not accounting for external services (e.g. DBS) in the readiness probe<\/li>\n<li>Using the same endpoint for both the readiness and the liveness probe<\/li>\n<li>Using an existing \u201chealth\u201d endpoint that was created when the application was running on a Virtual machine (instead of a container)<\/li>\n<li>Not using the health facilities of your programming framework (if applicable).<\/li>\n<li>Creating too complex health checks with unpredictable timings (that cause internal denial of service attacks inside the cluster)<\/li>\n<li>Creating cascading failures when checking external services in the liveness health probe<\/li>\n<\/ul>\n<p>Creating cascading failures by mistake is <a href=\"https:\/\/blog.colinbreck.com\/kubernetes-liveness-and-readiness-probes-how-to-avoid-shooting-yourself-in-the-foot\/\">a very common problem<\/a> that is destructive even with Virtual machines and Load balancers (i.e., it is not specific to Kubernetes).<\/p>\n<figure id=\"attachment_18635\" aria-describedby=\"caption-attachment-18635\" style=\"width: 2896px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-19.png\"><img class=\"size-full wp-image-18635\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-19.png\" alt=\"Cascading failures\" width=\"2896\" height=\"1214\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-19.png 2896w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-19-300x126.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-19-1024x429.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-19-768x322.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-19-1536x644.png 1536w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-19-2048x859.png 2048w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-19-20x8.png 20w\" sizes=\"(max-width: 2896px) 100vw, 2896px\" \/><\/a><figcaption id=\"caption-attachment-18635\" class=\"wp-caption-text\">Cascading failures<\/figcaption><\/figure>\n<p>You have 3 services that all use the Auth service as a dependency. Ideally the liveness probe for each service should only check if the service itself can respond to queries. However, if you setup the liveness probe to check for the dependencies then the following scenario can happen:<\/p>\n<ol>\n<li>Initially, all 4 services work correctly.<\/li>\n<li>The auth service has a hiccup (maybe its DB is overloaded) and is not responding to requests fast enough.<\/li>\n<li>All 3 services correctly detect that the auth service has issues.<\/li>\n<li>Unfortunately, they set their OWN health status to down (or unavailable) even though they all work fine.<\/li>\n<li>Kubernetes runs the liveness probes and decides that all 4 services are down and restarts all of them (while in reality only one of them had issues).<\/li>\n<\/ol>\n<p>For more advanced cases, you should also become familiar with <a href=\"https:\/\/en.wikipedia.org\/wiki\/Circuit_breaker_design_pattern\">circuit breakers<\/a> as they allow you to decouple the \u201cliveness\u201d of an application with its ability to respond.<\/p>\n<h2>Anti-pattern 12 &#8211; Not using the Helm package manager<\/h2>\n<p>There is only one package manager right now for Kubernetes and that is Helm. You can think of Helm as the apt\/rpm utility for your Kubernetes clusters.<\/p>\n<p>Unfortunately, people often misunderstand the capabilities of Helm and choose another \u201calternative\u201d. Helm is a package manager<a href=\"https:\/\/codefresh.io\/docs\/docs\/new-helm\/helm-best-practices\/#helm-vs-k8s-templates\"> that also happens to include templating capabilities<\/a>. It is not a templating solution and comparing it to one of the various templating solutions misses the point.<\/p>\n<p>All templating solutions for Kubernetes suffer from the same issue. They can do their magic during application deployment, but after the deployment has finished Kubernetes only knows a set of manifests and nothing more. Any concept of \u201capplication\u201d is lost and can only be recreated by having the original source files at hand.<\/p>\n<p>Helm, on the other hand, knows about the whole application and stores application-specific information in the cluster itself. Helm tracks the application resources AFTER the deployment. The difference is subtle but important.<\/p>\n<figure id=\"attachment_18636\" aria-describedby=\"caption-attachment-18636\" style=\"width: 1694px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-04.png\"><img class=\"size-full wp-image-18636\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-04.png\" alt=\"A Helm application \" width=\"1694\" height=\"2160\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-04.png 1694w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-04-235x300.png 235w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-04-803x1024.png 803w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-04-768x979.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-04-1205x1536.png 1205w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-04-1606x2048.png 1606w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-04-16x20.png 16w\" sizes=\"(max-width: 1694px) 100vw, 1694px\" \/><\/a><figcaption id=\"caption-attachment-18636\" class=\"wp-caption-text\">A Helm application<\/figcaption><\/figure>\n<p>Let\u2019s say that you get kubectl access on a cluster that has 4 applications (where each one is composed of multiple resources) in the same namespace. Your task is to delete one of these applications.<\/p>\n<p>If you have used a simple templating solution (such as Kustomize), you cannot easily understand the application structure by looking at the running resources. If you don\u2019t have the original templates (i.e. kustomizations and original patches) you need to manually inspect resources with kubectl and make the correlations between the application components.<\/p>\n<p>Helm on the other hand tracks the application inside the cluster. You can simply do:<\/p>\n<ul>\n<li><code>helm ls<\/code> (to look at the list of applications in the namespace)<\/li>\n<li><code>helm uninstall my-release<\/code> (to remove the application)<\/li>\n<\/ul>\n<p>That\u2019s it! No access to the original templates is needed or to a CI pipeline.<\/p>\n<p>Comparing Helm to Kustomize\/k8compt\/kdeploy and other templating tools is unfair to Helm as Helm is much more than a templating solution.<\/p>\n<p>One of the killer features of Helm is also the rollback function. You are paged at 3 am in the morning and want to perform the fastest rollback possible in a Kubernetes cluster that you are not familiar with. There is simply no time to track the original source files and identify what is the \u201cprevious\u201d versions of the templates in Git.<\/p>\n<p>With Helm it is trivial to do:<\/p>\n<ol>\n<li><code>helm ls<\/code> (to see releases)<\/li>\n<li><code>helm history my-release<\/code> (to see previous versions of deployments)<\/li>\n<li><code>helm rollback  my-release my-previous-version<\/code><\/li>\n<\/ol>\n<p>All this, right from the cluster because Helm knows what an application is unlike templating solutions that stop their work after a deployment has finished.<\/p>\n<p>Another misconception is that Helm packages are managed with Git Repos and changing a chart involves cloning\/copying the chart locally. Helm charts should actually be managed <a href=\"https:\/\/helm.sh\/docs\/topics\/chart_repository\/\">with Helm repositories<\/a>. It is ok if you also have a copy in Git (following the GitOps paradigm) but deploying a Helm chart to a cluster should happen from a Helm repository and not a Git repo.<\/p>\n<p>It is also worth noting that since Helm 3, there is no server-side component anymore (the infamous Tiller), so if the last time you evaluated Helm you had concerns regarding the security of the cluster, you need to take a fresh look at Helm a second time now that Tiller is gone.<\/p>\n<p>Unless you have a really strange workflow, not using Helm is like not using apt\/rpm for package management. If you decide that Helm is not for you, it should be a conscious choice (after careful consideration) and not based on misinformation about selecting \u201ca better templating solution than Helm\u201d.<\/p>\n<h2>Anti-pattern 13 &#8211; Not having deployment metrics<\/h2>\n<p>We have mentioned metrics several times in the previous anti-patterns. By \u201cmetrics\u201d we actually mean the whole trilogy of:<\/p>\n<ul>\n<li>logging &#8211; to examine the events and details of requests (usually post-incident)<\/li>\n<li>tracing &#8211; to dive deep in the journey of a single request (usually post-incident)<\/li>\n<li>metrics &#8211; to detect an incident (or even better to predict it)<\/li>\n<\/ul>\n<p>Metrics are more important in Kubernetes than traditional Virtual machines, because of the distributed nature of all services in a cluster (especially if you use micro-services). Kubernetes applications are fully dynamic (they come and go unlike virtual machines) and it is vital that you know how they adapt to your traffic.<\/p>\n<p>The exact solution that you choose for your metrics is not that important, as long as you have sufficient metrics for all your use cases such as:<\/p>\n<ul>\n<li>Getting critical information in a timely manner instead of using kubectl (see <a href=\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-2\/\">antipattern 6<\/a>)<\/li>\n<li>Understanding how traffic enters your cluster and what is the current bottleneck (see<a href=\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-2\/\"> antipattern 7<\/a>)<\/li>\n<li>Verifying\/adapting your resource limits (see <a href=\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-2\/\">antipattern 10<\/a>)<\/li>\n<\/ul>\n<p>The most important use case however is that you need to understand if your deployment has succeeded. Just because a container is up, doesn\u2019t mean that your application is in a running state or can accept requests (see also anti-pattern 11).<\/p>\n<p>Ideally, metrics should not be something that you look at from time to time. Metrics should be an integral part of your deployment process. Several organizations follow a workflow where the metrics are inspected manually after a deployment takes place, but this process is sub-optimal. Metrics should be handled in an automated way:<\/p>\n<figure id=\"attachment_18637\" aria-describedby=\"caption-attachment-18637\" style=\"width: 1840px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-16.png\"><img class=\"size-full wp-image-18637\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-16.png\" alt=\"Automated rollbacks\" width=\"1840\" height=\"552\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-16.png 1840w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-16-300x90.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-16-1024x307.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-16-768x230.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-16-1536x461.png 1536w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-16-20x6.png 20w\" sizes=\"(max-width: 1840px) 100vw, 1840px\" \/><\/a><figcaption id=\"caption-attachment-18637\" class=\"wp-caption-text\">Automated rollbacks<\/figcaption><\/figure>\n<ol>\n<li>A deployment takes place<\/li>\n<li>Metrics are examined (and compared to base case)<\/li>\n<li>Either the deployment is marked as finished or it is rolled back<\/li>\n<\/ol>\n<p>Note that there is no manual step involved in these actions.<\/p>\n<p>Making your metrics affecting your deployments is not an easy task. It shows however what is the end goal and how important are metrics for Kubernetes deployments.<\/p>\n<h2>Anti-pattern 14 &#8211; Not having a strategy for secrets<\/h2>\n<p>In the <a href=\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-1\/\">second anti-pattern<\/a> we explained why baking configuration in containers is a bad practice. This is even more true for secrets. If you use a dynamic service for configuration changes, it makes sense to use the same (or similar) service for handling secrets.<\/p>\n<p>Secrets should be passed during runtime to containers. There are many approaches to secret handling from simple storage to git (in an encrypted form) to a full secret solution like Hashicorp vault.<\/p>\n<p>Some common pitfalls here are:<\/p>\n<ul>\n<li>Using multiple ways for secret handling<\/li>\n<li>Confusing runtime secrets with build secrets<\/li>\n<li>Using complex secret injection mechanisms that make local development and testing difficult or impossible.<\/li>\n<\/ul>\n<p>The important point here is to choose a strategy and stick to it. All teams should use the same method for secret handling. All secrets from all environments should be handled in the same way. This makes secret tracking easy (knowing when and where a secret was used).<\/p>\n<p>You should also pass to each application only the secrets it actually needs.<\/p>\n<p>Runtime secrets are the secrets that an application needs AFTER it is deployed. Examples would be database passwords, SSL certificates, and private keys.<\/p>\n<p>Build secrets are secrets that an application needs ONLY while it is packaged. An example would be the credentials to your artifact repository (e.g. Artifactory or Nexus) or for file storage to an S3 bucket. These secrets are not needed in production and should never be sent to a Kubernetes cluster. Each deployed application should only get exactly the secrets it needs (and this is true even for non-production clusters).<\/p>\n<p>As we also mentioned in anti-pattern 3, secret management should be handled in a flexible way that allows for easy testing and local deployment of your app. This means that the application should not really care about the source of the secrets and should only focus on their usage.<\/p>\n<figure id=\"attachment_18639\" aria-describedby=\"caption-attachment-18639\" style=\"width: 1930px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-01.png\"><img class=\"size-full wp-image-18639\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-01.png\" alt=\"Injecting secrets\" width=\"1930\" height=\"1560\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-01.png 1930w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-01-300x242.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-01-1024x828.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-01-768x621.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-01-1536x1242.png 1536w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-01-20x16.png 20w\" sizes=\"(max-width: 1930px) 100vw, 1930px\" \/><\/a><figcaption id=\"caption-attachment-18639\" class=\"wp-caption-text\">Injecting secrets<\/figcaption><\/figure>\n<p>As an example, even though <a href=\"https:\/\/www.vaultproject.io\/\">Hashicorp Vault<\/a> has a <a href=\"https:\/\/www.vaultproject.io\/api\">flexible API<\/a> for getting secrets and tokens, your Kubernetes application should NOT use that API directly in order to get the required information. If you do this, then testing the application locally becomes a nightmare, as a developer would need to set up a vault instance locally or mock the vault responses just to run the application.<\/p>\n<h2>Anti-pattern 15 &#8211; Attempting to solve all problems with Kubernetes<\/h2>\n<p>As with all technologies before it, Kubernetes is a specific solution that solves a specific set of problems. If you already have those problems then you will find that adopting Kubernetes greatly simplifies your workflow and gives you access to a clustering solution that is well designed and maintained.<\/p>\n<p>It is important however to understand the benefits and drawbacks of adopting Kubernetes. At least in the beginning it is much easier to use Kubernetes for stateless services that will exploit the elasticity and scalability of the cluster.<\/p>\n<p>Even though technically Kubernetes supports stateful services as well, it is best to run such services outside the cluster as you begin your migration journey. It is ok if you keep databases, caching solutions, artifact repositories, and even Docker registries outside the cluster (either in Virtual machines or cloud-based services).<\/p>\n<h2>Moving ahead<\/h2>\n<p>Kubernetes is a complex solution that requires a new way of thinking across all fronts (networking, storage, deployments, etc). Deploying to a Kubernetes cluster is a completely different process than deploying to Virtual machines.<\/p>\n<p>Instead of reusing your existing deployment mechanisms, you should spend some time to examine all the implications of Kubernetes applications and not fall into the traps we have seen in this guide:<\/p>\n<ol>\n<li>Deploying images with the \u201clatest\u201d tag<\/li>\n<li>Hardcoding configuration inside container images<\/li>\n<li>Coupling the application with cluster constructs<\/li>\n<li>Mixing infrastructure deployments with application releases<\/li>\n<li>Doing manual deployments using kubectl<\/li>\n<li>Using kubectl for debugging clusters<\/li>\n<li>Not understanding the Kubernetes network model<\/li>\n<li>Wasting resources on static environments instead of dynamic ones<\/li>\n<li>Mixing production and non-production workloads in the same cluster<\/li>\n<li>Not understanding memory and CPU limits<\/li>\n<li>Misusing health probes<\/li>\n<li>Not understanding the benefits of Helm<\/li>\n<li>Not have effective application metrics<\/li>\n<li>Handling secrets in an ad-hoc manner<\/li>\n<li>Adopting Kubernetes even when it is not the proper solution.<\/li>\n<\/ol>\n<p>Happy deployments!<\/p>\n<p>Download the<a href=\"https:\/\/codefresh.io\/ebooks\/kubernetes-anti-patterns-ebook\/\">\u00a0ebook<\/a>.<\/p>\n<p>Cover photo by <a href=\"https:\/\/unsplash.com\/photos\/YM_bUQ3WnNk\">Unsplash<\/a>.<\/p>\n<input class=\"fooboxshare_post_id\" type=\"hidden\" value=\"18579\"\/>","protected":false},"excerpt":{"rendered":"<p>This is the third and last part in our Kubernetes Anti-patterns series. See also part 1 and part 2 for the previous anti-patterns. You can also download all 3 parts in a PDF ebook. Anti-pattern 11 &#8211; Misusing Health probes Apart from resource limits, if you are moving your application to Kubernetes you should take &hellip; <a href=\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-3\/\">Read more<\/a><\/p>\n","protected":false},"author":62,"featured_media":18593,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[3120,5467,1657,1505,1543,1538],"tags":[14,15,22,24,44,52,53,64,68,5527],"yoast_head":"<!-- This site is optimized with the Yoast SEO Premium plugin v17.9 (Yoast SEO v18.4.1) - https:\/\/yoast.com\/wordpress\/plugins\/seo\/ -->\n<title>Kubernetes Deployment Antipatterns - part 3 | Codefresh<\/title>\n<meta name=\"robots\" content=\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\" \/>\n<link rel=\"canonical\" href=\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-3\/\" \/>\n<meta property=\"og:locale\" content=\"en_US\" \/>\n<meta property=\"og:type\" content=\"article\" \/>\n<meta property=\"og:title\" content=\"Kubernetes Deployment Antipatterns - part 3\" \/>\n<meta property=\"og:description\" content=\"This is the third and last part in our Kubernetes Anti-patterns series. See also part 1 and part 2 for the previous anti-patterns. You can also download all 3 parts in a PDF ebook. Anti-pattern 11 &#8211; Misusing Health probes Apart from resource limits, if you are moving your application to Kubernetes you should take &hellip; Read more\" \/>\n<meta property=\"og:url\" content=\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-3\/\" \/>\n<meta property=\"og:site_name\" content=\"Codefresh\" \/>\n<meta property=\"article:publisher\" content=\"https:\/\/www.facebook.com\/codefresh.io\" \/>\n<meta property=\"article:published_time\" content=\"2021-01-20T16:48:42+00:00\" \/>\n<meta property=\"article:modified_time\" content=\"2022-02-15T14:25:06+00:00\" \/>\n<meta property=\"og:image\" content=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/blog-picture-1.jpg\" \/>\n\t<meta property=\"og:image:width\" content=\"1024\" \/>\n\t<meta property=\"og:image:height\" content=\"340\" \/>\n\t<meta property=\"og:image:type\" content=\"image\/jpeg\" \/>\n<meta name=\"twitter:card\" content=\"summary_large_image\" \/>\n<meta name=\"twitter:creator\" content=\"@codefresh\" \/>\n<meta name=\"twitter:site\" content=\"@codefresh\" \/>\n<meta name=\"twitter:label1\" content=\"Written by\" \/>\n\t<meta name=\"twitter:data1\" content=\"Kostis Kapelonis\" \/>\n\t<meta name=\"twitter:label2\" content=\"Est. reading time\" \/>\n\t<meta name=\"twitter:data2\" content=\"11 minutes\" \/>\n<script type=\"application\/ld+json\" class=\"yoast-schema-graph\">{\"@context\":\"https:\/\/schema.org\",\"@graph\":[{\"@type\":\"Organization\",\"@id\":\"https:\/\/codefresh.io\/#organization\",\"name\":\"Codefresh\",\"url\":\"https:\/\/codefresh.io\/\",\"sameAs\":[\"https:\/\/www.facebook.com\/codefresh.io\",\"https:\/\/www.linkedin.com\/company\/codefresh\",\"https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg\",\"https:\/\/twitter.com\/codefresh\"],\"logo\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#logo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"width\":800,\"height\":800,\"caption\":\"Codefresh\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/#logo\"}},{\"@type\":\"WebSite\",\"@id\":\"https:\/\/codefresh.io\/#website\",\"url\":\"https:\/\/codefresh.io\/\",\"name\":\"Codefresh\",\"description\":\"\",\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"potentialAction\":[{\"@type\":\"SearchAction\",\"target\":{\"@type\":\"EntryPoint\",\"urlTemplate\":\"https:\/\/codefresh.io\/?s={search_term_string}\"},\"query-input\":\"required name=search_term_string\"}],\"inLanguage\":\"en-US\"},{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-3\/#primaryimage\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/blog-picture-1.jpg\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/blog-picture-1.jpg\",\"width\":1024,\"height\":340},{\"@type\":\"WebPage\",\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-3\/#webpage\",\"url\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-3\/\",\"name\":\"Kubernetes Deployment Antipatterns - part 3 | Codefresh\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/#website\"},\"primaryImageOfPage\":{\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-3\/#primaryimage\"},\"datePublished\":\"2021-01-20T16:48:42+00:00\",\"dateModified\":\"2022-02-15T14:25:06+00:00\",\"breadcrumb\":{\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-3\/#breadcrumb\"},\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"ReadAction\",\"target\":[\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-3\/\"]}]},{\"@type\":\"BreadcrumbList\",\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-3\/#breadcrumb\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"name\":\"Home\",\"item\":\"https:\/\/codefresh.io\/\"},{\"@type\":\"ListItem\",\"position\":2,\"name\":\"Kubernetes Deployment Antipatterns &#8211; part 3\"}]},{\"@type\":\"Article\",\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-3\/#article\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-3\/#webpage\"},\"author\":{\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87\"},\"headline\":\"Kubernetes Deployment Antipatterns &#8211; part 3\",\"datePublished\":\"2021-01-20T16:48:42+00:00\",\"dateModified\":\"2022-02-15T14:25:06+00:00\",\"mainEntityOfPage\":{\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-3\/#webpage\"},\"wordCount\":2187,\"commentCount\":3,\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-3\/#primaryimage\"},\"thumbnailUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/blog-picture-1.jpg\",\"keywords\":[\"docker\",\"continuous integration\",\"monitoring\",\"Containers\",\"Kubernetes\",\"devops\",\"CI\/CD\",\"microservices\",\"continuous delivery\",\"patterns\"],\"articleSection\":[\"Continuous Deployment\/Delivery\",\"Devops\",\"Kubernetes Tutorials\",\"Containers\",\"Continuous Integration\",\"DevOps Tutorials\"],\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"CommentAction\",\"name\":\"Comment\",\"target\":[\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-3\/#respond\"]}]},{\"@type\":\"Person\",\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87\",\"name\":\"Kostis Kapelonis\",\"image\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#personlogo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png\",\"caption\":\"Kostis Kapelonis\"},\"description\":\"Kostis is a software engineer\/technical-writer dual class character. He lives and breathes automation, good testing practices and stress-free deployments with GitOps.\",\"url\":\"https:\/\/codefresh.io\/author\/kostiscodefresh-io\/\"}]}<\/script>\n<!-- \/ Yoast SEO Premium plugin. -->","yoast_head_json":{"title":"Kubernetes Deployment Antipatterns - part 3 | Codefresh","robots":{"index":"index","follow":"follow","max-snippet":"max-snippet:-1","max-image-preview":"max-image-preview:large","max-video-preview":"max-video-preview:-1"},"canonical":"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-3\/","og_locale":"en_US","og_type":"article","og_title":"Kubernetes Deployment Antipatterns - part 3","og_description":"This is the third and last part in our Kubernetes Anti-patterns series. See also part 1 and part 2 for the previous anti-patterns. You can also download all 3 parts in a PDF ebook. Anti-pattern 11 &#8211; Misusing Health probes Apart from resource limits, if you are moving your application to Kubernetes you should take &hellip; Read more","og_url":"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-3\/","og_site_name":"Codefresh","article_publisher":"https:\/\/www.facebook.com\/codefresh.io","article_published_time":"2021-01-20T16:48:42+00:00","article_modified_time":"2022-02-15T14:25:06+00:00","og_image":[{"width":1024,"height":340,"url":"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/blog-picture-1.jpg","type":"image\/jpeg"}],"twitter_card":"summary_large_image","twitter_creator":"@codefresh","twitter_site":"@codefresh","twitter_misc":{"Written by":"Kostis Kapelonis","Est. reading time":"11 minutes"},"schema":{"@context":"https:\/\/schema.org","@graph":[{"@type":"Organization","@id":"https:\/\/codefresh.io\/#organization","name":"Codefresh","url":"https:\/\/codefresh.io\/","sameAs":["https:\/\/www.facebook.com\/codefresh.io","https:\/\/www.linkedin.com\/company\/codefresh","https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg","https:\/\/twitter.com\/codefresh"],"logo":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#logo","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","width":800,"height":800,"caption":"Codefresh"},"image":{"@id":"https:\/\/codefresh.io\/#logo"}},{"@type":"WebSite","@id":"https:\/\/codefresh.io\/#website","url":"https:\/\/codefresh.io\/","name":"Codefresh","description":"","publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"potentialAction":[{"@type":"SearchAction","target":{"@type":"EntryPoint","urlTemplate":"https:\/\/codefresh.io\/?s={search_term_string}"},"query-input":"required name=search_term_string"}],"inLanguage":"en-US"},{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-3\/#primaryimage","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/blog-picture-1.jpg","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/blog-picture-1.jpg","width":1024,"height":340},{"@type":"WebPage","@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-3\/#webpage","url":"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-3\/","name":"Kubernetes Deployment Antipatterns - part 3 | Codefresh","isPartOf":{"@id":"https:\/\/codefresh.io\/#website"},"primaryImageOfPage":{"@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-3\/#primaryimage"},"datePublished":"2021-01-20T16:48:42+00:00","dateModified":"2022-02-15T14:25:06+00:00","breadcrumb":{"@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-3\/#breadcrumb"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-3\/"]}]},{"@type":"BreadcrumbList","@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-3\/#breadcrumb","itemListElement":[{"@type":"ListItem","position":1,"name":"Home","item":"https:\/\/codefresh.io\/"},{"@type":"ListItem","position":2,"name":"Kubernetes Deployment Antipatterns &#8211; part 3"}]},{"@type":"Article","@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-3\/#article","isPartOf":{"@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-3\/#webpage"},"author":{"@id":"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87"},"headline":"Kubernetes Deployment Antipatterns &#8211; part 3","datePublished":"2021-01-20T16:48:42+00:00","dateModified":"2022-02-15T14:25:06+00:00","mainEntityOfPage":{"@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-3\/#webpage"},"wordCount":2187,"commentCount":3,"publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"image":{"@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-3\/#primaryimage"},"thumbnailUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/blog-picture-1.jpg","keywords":["docker","continuous integration","monitoring","Containers","Kubernetes","devops","CI\/CD","microservices","continuous delivery","patterns"],"articleSection":["Continuous Deployment\/Delivery","Devops","Kubernetes Tutorials","Containers","Continuous Integration","DevOps Tutorials"],"inLanguage":"en-US","potentialAction":[{"@type":"CommentAction","name":"Comment","target":["https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-3\/#respond"]}]},{"@type":"Person","@id":"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87","name":"Kostis Kapelonis","image":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#personlogo","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png","caption":"Kostis Kapelonis"},"description":"Kostis is a software engineer\/technical-writer dual class character. He lives and breathes automation, good testing practices and stress-free deployments with GitOps.","url":"https:\/\/codefresh.io\/author\/kostiscodefresh-io\/"}]}},"acf":[],"_links":{"self":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/18579"}],"collection":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/users\/62"}],"replies":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/comments?post=18579"}],"version-history":[{"count":1,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/18579\/revisions"}],"predecessor-version":[{"id":21514,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/18579\/revisions\/21514"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media\/18593"}],"wp:attachment":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media?parent=18579"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/categories?post=18579"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/tags?post=18579"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}