{"id":18591,"date":"2021-01-20T08:44:42","date_gmt":"2021-01-20T16:44:42","guid":{"rendered":"https:\/\/codefresh.io\/?p=18591"},"modified":"2022-03-22T16:00:41","modified_gmt":"2022-03-22T16:00:41","slug":"kubernetes-antipatterns-1","status":"publish","type":"post","link":"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-1\/","title":{"rendered":"Kubernetes Deployment Antipatterns &#8211; part 1"},"content":{"rendered":"<p>In our previous guide, we documented <a href=\"https:\/\/codefresh.io\/containers\/docker-anti-patterns\/\">10 Docker anti-patterns<\/a>. This guide has been very popular as it can help you in your first steps with container images. Creating container images for your application, however, is only half the story. You still need a way to deploy these containers in production, and the de facto solution for doing this is by using Kubernetes clusters.<\/p>\n<p>We soon realized that we must also create a similar guide for Kubernetes deployments. This will hopefully give you the whole picture of how to create a container image <strong>and <\/strong>how to properly deploy it (or at least warn you of some common pitfalls).<\/p>\n<p>Notice that in this guide we talk specifically about <strong>application deployments on<\/strong> Kubernetes and not Kubernetes clusters themselves. This means that we assume that the Kubernetes cluster is already there (and it is properly set up) and you simply want to deploy an application on it. In the future, we will complete the trilogy by also documenting anti-patterns for the creation of the clusters (i.e. talk about the infrastructure level instead of the application level).<\/p>\n<p>Unlike other guides that simply complain about how things can go wrong, we always associate each anti-pattern with the respective solution. This way you can actually check your own deployment process and fix any issues without hunting down extra information.<\/p>\n<p>Here is the list of bad practices that we will examine today:<\/p>\n<ol>\n<li>Using containers with the latest tag in Kubernetes deployments<\/li>\n<li>Baking the configuration inside container images<\/li>\n<li>Coupling applications with Kubernetes features\/services for no reason<\/li>\n<li>Mixing application deployment with infrastructure deployment (e.g. having Terraform deploying apps with the Helm provider)<\/li>\n<li>Performing ad-hoc deployments with kubectl edit\/patch by hand<\/li>\n<li>Using Kubectl as a debugging tool<\/li>\n<li>Misunderstanding Kubernetes network concepts<\/li>\n<li>Using permanent staging environments instead of dynamic environments<\/li>\n<li>Mixing production and non-production clusters<\/li>\n<li>Deploying without memory and CPU limits<\/li>\n<li>Misusing health probes<\/li>\n<li>Not using Helm (and not understanding what Helm brings to the table)<\/li>\n<li>Not having deployment metrics to understand what the application is doing<\/li>\n<li>Not having a secret strategy\/treating secrets in an ad-hoc manner<\/li>\n<li>Attempting to go all in Kubernetes (even with databases and stateful loads)<\/li>\n<\/ol>\n<p>By the way, if you still haven\u2019t looked at the <a href=\"https:\/\/codefresh.io\/containers\/docker-anti-patterns\/\">container anti-patterns guide<\/a>, you should do this now, as some of the bad practices mentioned above will reference it.<\/p>\n<h2>Anti-pattern 1 &#8211; Using containers with the latest tag in Kubernetes deployments<\/h2>\n<p>If you have spent any time building containers, this should come as no surprise. Using the \u201clatest\u201d tag for Docker images is a bad practice on its own as \u201clatest\u201d is just a name of the tag and it doesn\u2019t actually mean \u201cmost recent\u201d or \u201clastly built\u201d. Latest is also the default tag if you don\u2019t specify one when talking about a container image.<\/p>\n<p>Using the \u201clatest\u201d tag in a Kubernetes deployment is even worse as by doing this you don\u2019t know what is deployed in your cluster anymore.<\/p>\n<pre>apiVersion: apps\/v1\r\nkind: Deployment\r\nmetadata:\r\n  name: my-bad-deployment\r\nspec:\r\n  template:\r\n    metadata:\r\n      labels:\r\n        app: my-badly-deployed-app\r\n    spec:\r\n      containers:\r\n      - name: dont-do-this\r\n        image: docker.io\/myusername\/my-app:latest\r\n<\/pre>\n<p>If you apply this deployment you have now lost all information on which container tag is actually deployed. Container tags are mutable, so the \u201clatest\u201d tag does not really mean anything to anyone. Maybe this container image was created 3 minutes ago, maybe it was 3 months ago. You will need to hunt down all your logs for your CI system or even download the image locally to inspect it so that you know what version it contains.<\/p>\n<p>The \u201clatest\u201d tag is even more dangerous if you couple it with <a href=\"https:\/\/kubernetes.io\/docs\/concepts\/containers\/images\/#updating-images\">an always pull policy<\/a>. Let\u2019s say that your pod is dead, and Kubernetes decides to restart it in order to make it healthy (remember that is why you are using Kubernetes in the first place).<\/p>\n<figure id=\"attachment_18562\" aria-describedby=\"caption-attachment-18562\" style=\"width: 1960px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-20.png\"><img class=\"size-full wp-image-18562\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-20.png\" alt=\"Misusing latest tags\" width=\"1960\" height=\"1284\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-20.png 1960w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-20-300x197.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-20-1024x671.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-20-768x503.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-20-1536x1006.png 1536w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-20-20x13.png 20w\" sizes=\"(max-width: 1960px) 100vw, 1960px\" \/><\/a><figcaption id=\"caption-attachment-18562\" class=\"wp-caption-text\">Misusing latest tags<\/figcaption><\/figure>\n<p>Kubernetes will reschedule the pod and if your pull policy allows this, it will pull the \u201clatest\u201d image again from your Docker registry! This means that, if in the meantime the \u201clatest\u201d tag has changed, you now have a new version in this particular pod which is different from what the other pods have. In most cases, this is not what you want.<\/p>\n<p>It also goes without saying that performing \u201cdeployments\u201d by killing pods manually and waiting for them to pull again your \u201clatest\u201d image is a recipe for success (if you do happen to use this form of \u201cdeployment\u201d).<\/p>\n<p>The correct deployment format in Kubernetes should follow a proper tagging strategy. The specific strategy is not that important as long as you have one.<\/p>\n<p>Some suggestions are:<\/p>\n<ul>\n<li>Using tags with Git hashes (e.g. <code>docker.io\/myusername\/my-app:acef3e<\/code>). This is straightforward to implement but may be overkill since a Git hash is not easily readable by non-technical people.<\/li>\n<li>Using tags with the application version following semantic versions (e.g. <code>docker.io\/myusername\/my-app:v1.0.1<\/code>). This method has many advantages for both developers and non-developers and is our personal recommendation.<\/li>\n<li>Using tags that signify a consecutive number such as a build number or build date\/time. This format is very hard to work with but can be easy to adopt with legacy applications.<\/li>\n<\/ul>\n<p>The important thing is that you should agree that <a href=\"https:\/\/aws.amazon.com\/about-aws\/whats-new\/2019\/07\/amazon-ecr-now-supports-immutable-image-tags\/\">container tags should be treated as immutable<\/a>. A Docker image that is marked as v2.0.5 should be created only once and should be promoted from one environment to another.<\/p>\n<p>If you see a deployment that uses the image with tag v2.0.5, you should be able to&#8230;<\/p>\n<ul>\n<li>pull this image locally and be certain that it is the exact same one that is running on the cluster;<\/li>\n<li>easily track down the Git hash that it created it.<\/li>\n<\/ul>\n<p>If your deployment workflows depend in any way on using \u201clatest\u201d tags, you are sitting on a time bomb.<\/p>\n<h2>Anti-pattern 2 &#8211; Baking the configuration inside container images<\/h2>\n<p>This is actually another anti-pattern that comes from building container images. Your images should be \u201cgeneric\u201d in the sense that they should be able to run in any environment.<\/p>\n<p>This was a good practice even before containers appeared and is already documented as part of the <a href=\"https:\/\/12factor.net\/config\">12-factor app<\/a>. Your container images should be built once and then promoted from one environment to another. No configuration should be present in the container itself.<\/p>\n<p>If your container image:<\/p>\n<ul>\n<li>has hardcoded IP addresses<\/li>\n<li>contains passwords and secrets<\/li>\n<li>mentions specific URLs to other services<\/li>\n<li>Is tagged with strings such as \u201cdev\u201d, \u201cqa\u201d, \u201cproduction\u201d<\/li>\n<\/ul>\n<p>..then you have fallen into the trap of building environment-dependent container images.<\/p>\n<figure id=\"attachment_18565\" aria-describedby=\"caption-attachment-18565\" style=\"width: 908px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-18.png\"><img class=\"size-full wp-image-18565\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-18.png\" alt=\"Hardcoding configuration in containers\" width=\"908\" height=\"674\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-18.png 908w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-18-300x223.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-18-768x570.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-18-20x15.png 20w\" sizes=\"(max-width: 908px) 100vw, 908px\" \/><\/a><figcaption id=\"caption-attachment-18565\" class=\"wp-caption-text\">Hardcoding configuration in containers<\/figcaption><\/figure>\n<p>This means that for each different environment, you have to rebuild your image so you deploy to production something different than what was tested before.<\/p>\n<p>The solution to this problem is very simple. Create \u201cgeneric\u201d container images that know nothing about the environment they are running on. For configuration, you can use any external method such as Kubernetes configmaps, Hashicorp Consul, Apache Zookeeper, etc.<\/p>\n<figure id=\"attachment_18566\" aria-describedby=\"caption-attachment-18566\" style=\"width: 1482px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-17.png\"><img class=\"size-full wp-image-18566\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-17.png\" alt=\"Getting configuration from the environment\" width=\"1482\" height=\"654\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-17.png 1482w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-17-300x132.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-17-1024x452.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-17-768x339.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-17-20x9.png 20w\" sizes=\"(max-width: 1482px) 100vw, 1482px\" \/><\/a><figcaption id=\"caption-attachment-18566\" class=\"wp-caption-text\">Getting configuration from the environment<\/figcaption><\/figure>\n<p>Now you have a single image that gets deployed in all your clusters. It is much easier to understand what it contains and how it was created.<\/p>\n<p>A secondary advantage is that if you do need to change the configuration on your cluster, you can simply change the external configuration system instead of rebuilding the full container image from scratch. Depending on the programming language and framework that you use, you can even update the live configuration without any restarts or redeployments.<\/p>\n<h2>Anti-pattern 3 &#8211; Coupling applications with Kubernetes features\/services for no reason<\/h2>\n<p>In the previous section, we explained why you should not store configuration inside a container and how a container should not know anything about the cluster it is running on.<\/p>\n<p>We can take this to an extreme <strong>by requiring each container to not even know that it is running inside Kubernetes at all<\/strong>. Unless you are developing an application that is destined to handle a cluster, your application should not tamper with the Kubernetes API or other external services that are assumed to be inside the cluster.<\/p>\n<p>This scenario is very common with overenthusiastic teams that adopt Kubernetes and fail to isolate their application from the cluster. Some classic examples are application that:<\/p>\n<ul>\n<li>expect a certain volume configuration for data sharing with other pods<\/li>\n<li>expect a certain naming of services\/DNS that is set up by Kubernetes networking or assume the presence of specific open ports<\/li>\n<li>get information from Kubernetes labels and annotations<\/li>\n<li>query their own pod for information (e.g to see what IP address they have)<\/li>\n<li>need an init or sidecar container in order to function properly even in local workstations<\/li>\n<li>call other Kubernetes services directly (e.g. using the <a href=\"https:\/\/www.vaultproject.io\/api\">vault API<\/a> to get secrets from a <a href=\"https:\/\/www.vaultproject.io\/\">Vault installation<\/a> that is assumed to also be present on the cluster)<\/li>\n<li>read data from <a href=\"https:\/\/kubernetes.io\/docs\/concepts\/configuration\/organize-cluster-access-kubeconfig\/\">a local kube config<\/a><\/li>\n<li>use directly the Kubernetes API from within the application<\/li>\n<\/ul>\n<figure id=\"attachment_18567\" aria-describedby=\"caption-attachment-18567\" style=\"width: 1739px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-08.png\"><img class=\"size-full wp-image-18567\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-08.png\" alt=\"Getting infor directly from the cluster\" width=\"1739\" height=\"717\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-08.png 1739w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-08-300x124.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-08-1024x422.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-08-768x317.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-08-1536x633.png 1536w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-08-20x8.png 20w\" sizes=\"(max-width: 1739px) 100vw, 1739px\" \/><\/a><figcaption id=\"caption-attachment-18567\" class=\"wp-caption-text\">Getting infor directly from the cluster<\/figcaption><\/figure>\n<p>Now of course, if your application is Kubernetes specific (let\u2019s say that you are creating an autoscaler or operator) then it indeed needs to access Kubernetes services directly. But for the other 99% of standard web applications out there, your application should be completely oblivious to the fact that it is running inside Kubernetes.<\/p>\n<figure id=\"attachment_18568\" aria-describedby=\"caption-attachment-18568\" style=\"width: 1712px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-07.png\"><img class=\"size-full wp-image-18568\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-07.png\" alt=\"Inject configuration externally\" width=\"1712\" height=\"714\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-07.png 1712w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-07-300x125.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-07-1024x427.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-07-768x320.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-07-1536x641.png 1536w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-07-20x8.png 20w\" sizes=\"(max-width: 1712px) 100vw, 1712px\" \/><\/a><figcaption id=\"caption-attachment-18568\" class=\"wp-caption-text\">Inject configuration externally<\/figcaption><\/figure>\n<p>The litmus test that shows if your application is tied to Kubernetes or not is the ability to run your application with Docker compose. If creating a Docker compose file for your app is dead simple, then it means that you are following the 12-factor app principles and your application can be installed on any cluster without the need for special settings.<\/p>\n<p>It is important to also understand the premise of local Kubernetes testing. There are several solutions today for local Kubernetes deployments (minikube, microk8s, <a href=\"https:\/\/kind.sigs.k8s.io\/\">kind <\/a>etc). You might look at these solutions and think that if you are a developer working on an application that is deployed to Kubernetes you also need to run Kubernetes yourself.<\/p>\n<figure id=\"attachment_18569\" aria-describedby=\"caption-attachment-18569\" style=\"width: 1514px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-14.png\"><img class=\"size-full wp-image-18569\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-14.png\" alt=\"Local kubernetes cluster\" width=\"1514\" height=\"818\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-14.png 1514w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-14-300x162.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-14-1024x553.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-14-768x415.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-14-20x11.png 20w\" sizes=\"(max-width: 1514px) 100vw, 1514px\" \/><\/a><figcaption id=\"caption-attachment-18569\" class=\"wp-caption-text\">Local kubernetes cluster<\/figcaption><\/figure>\n<p>This could not be further from the truth. If your application is correctly designed you shouldn\u2019t need Kubernetes for running integration tests locally. Just launch the application on its own (with Docker or Docker-compose) and hit it directly with the tests.<\/p>\n<figure id=\"attachment_18570\" aria-describedby=\"caption-attachment-18570\" style=\"width: 1514px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-15.png\"><img class=\"size-full wp-image-18570\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-15.png\" alt=\"Using Docker compose\" width=\"1514\" height=\"818\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-15.png 1514w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-15-300x162.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-15-1024x553.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-15-768x415.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-15-20x11.png 20w\" sizes=\"(max-width: 1514px) 100vw, 1514px\" \/><\/a><figcaption id=\"caption-attachment-18570\" class=\"wp-caption-text\">Using Docker compose<\/figcaption><\/figure>\n<p>It is ok if some of your dependencies are running on an external Kubernetes cluster. But the application itself should not need to run inside Kubernetes while you are testing its functionality.<\/p>\n<p>Alternatively, you can also use any of the dedicated solutions for local Kubernetes development such as <a href=\"https:\/\/codefresh.io\/kubernetes-tutorial\/okteto\/\">Okteto<\/a>, <a href=\"https:\/\/codefresh.io\/howtos\/local-k8s-draft-skaffold-garden\/\">garden.io<\/a>, and <a href=\"https:\/\/codefresh.io\/kubernetes-tutorial\/local-kubernetes-development-tilt-dev\/\">tilt.dev<\/a>.<\/p>\n<h2>Anti-pattern 4 &#8211; Mixing application deployment with infrastructure deployment<\/h2>\n<p>In recent years, the rise of <a href=\"https:\/\/www.terraform.io\/\">Terraform <\/a>(and similar tools like <a href=\"https:\/\/www.pulumi.com\/\">Pulumi<\/a>) has given rise to the \u201cinfrastructure as code\u201d movement that allows teams to deploy infrastructure in the same way as code.<\/p>\n<p>But just because you can deploy infrastructure in a pipeline, doesn\u2019t mean that infrastructure and application deployment should happen all at once.<\/p>\n<figure id=\"attachment_18572\" aria-describedby=\"caption-attachment-18572\" style=\"width: 2722px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-13.png\"><img class=\"size-full wp-image-18572\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-13.png\" alt=\"Single pipeline for infrastructure and apps\" width=\"2722\" height=\"1292\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-13.png 2722w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-13-300x142.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-13-1024x486.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-13-768x365.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-13-1536x729.png 1536w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-13-2048x972.png 2048w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-13-20x9.png 20w\" sizes=\"(max-width: 2722px) 100vw, 2722px\" \/><\/a><figcaption id=\"caption-attachment-18572\" class=\"wp-caption-text\">Single pipeline for infrastructure and apps<\/figcaption><\/figure>\n<p>We see a lot of teams that create a single pipeline that both creates infrastructure (i.e. creating a Kubernetes cluster, container registry, etc.) and <a href=\"https:\/\/registry.terraform.io\/providers\/hashicorp\/helm\/latest\/docs\">then deploys an application on top<\/a> of it.<\/p>\n<p>While this works great in theory, (as it means you are starting from scratch with each deployment) it is pretty wasteful in terms of resources and time.<\/p>\n<p>In most cases, the application code will change much faster than the infrastructure. It is hard to generalize for all companies, but in most cases the rate the application changes might be 2x-10x more often than the infrastructure.<\/p>\n<p>If you have a single pipeline that does both, then you are destroying\/creating infrastructure that never changed simply because you want to deploy a new application version.<\/p>\n<p>A pipeline that deploys everything (infra\/app) might take 30 minutes, while a pipeline that deploys only the application might take only 5 minutes. You are spending 25 extra minutes on each deployment for no reason at all when the infrastructure has not changed.<\/p>\n<figure id=\"attachment_18573\" aria-describedby=\"caption-attachment-18573\" style=\"width: 2780px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-09.png\"><img class=\"size-full wp-image-18573\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-09.png\" alt=\"broken pipeline\" width=\"2780\" height=\"1466\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-09.png 2780w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-09-300x158.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-09-1024x540.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-09-768x405.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-09-1536x810.png 1536w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-09-2048x1080.png 2048w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-09-20x11.png 20w\" sizes=\"(max-width: 2780px) 100vw, 2780px\" \/><\/a><figcaption id=\"caption-attachment-18573\" class=\"wp-caption-text\">broken pipeline<\/figcaption><\/figure>\n<p>The second disadvantage is that if the single pipeline breaks, it is not clear who must look at it. If I am a developer and want to deploy my application on Kubernetes, I am not interested in Terraform errors, virtual networks, or storage volumes.<\/p>\n<p>The whole point of DevOps is to empower developers with self-service tools. Forcing them to deal with infrastructure when they don\u2019t need to, is a step backward.<\/p>\n<p>The correct solution is of course to split deployment or infrastructure on their own pipelines. The infrastructure pipeline will be triggered less often than the application one, making application deployments faster (and cutting down on lead time).<\/p>\n<figure id=\"attachment_18574\" aria-describedby=\"caption-attachment-18574\" style=\"width: 2762px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-12.png\"><img class=\"size-full wp-image-18574\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-12.png\" alt=\"Separate pipelines\" width=\"2762\" height=\"1617\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-12.png 2762w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-12-300x176.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-12-1024x599.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-12-768x450.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-12-1536x899.png 1536w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-12-2048x1199.png 2048w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-12-20x12.png 20w\" sizes=\"(max-width: 2762px) 100vw, 2762px\" \/><\/a><figcaption id=\"caption-attachment-18574\" class=\"wp-caption-text\">Separate pipelines<\/figcaption><\/figure>\n<p>Developers will also know that when the application pipeline breaks, they don\u2019t need to deal with infrastructure errors or care about how the Kubernetes cluster was created. Operators can fine-tune the infrastructure pipeline without affecting developers at all. Everybody can work independently.<\/p>\n<p>We sometimes see this anti-pattern (mixing infrastructure with application) where companies believe that this is the only way forward as the application needs something provided by the infrastructure pipelines.<\/p>\n<p>The classic example is creating something with Terraform and then passing the output of the deployment (e.g. an IP address) to the rest of the pipeline as input to the application code. If you have this limitation it means that you are suffering from the previous anti-pattern (coupling application to the details of the infrastructure) and you need to remove this coupling (i.e. your application code should not need a specific IP address to be deployed).<\/p>\n<p>Notice that the same approach can be expanded to database upgrades. If you use pipelines for database changesets, then they should be independent of the application source code. You should be able to update only the DB schema or only the application code on their own, without having to do both for every deployment.<\/p>\n<h2>Anti-pattern 5 &#8211; Performing ad-hoc deployments with kubectl edit\/patch by hand<\/h2>\n<p>Configuration drift is a well known problem that existed even before Kubernetes appeared. It happens when two or more environments are supposed to be the same, but after certain ah-hoc deployments or changes they stop having the same configuration.<\/p>\n<p>As time goes on, the problem becomes even more critical and can result in extreme scenarios where the configuration of a machine is not known any more and has to be reverse-engineered from the live instance.<\/p>\n<p>Kubernetes can also suffer from this problem. The <code>`kubectl`<\/code> command is very powerful and comes with <a href=\"https:\/\/kubernetes.io\/docs\/concepts\/cluster-administration\/manage-deployment\/#in-place-updates-of-resources\">built-in apply\/edit\/patch commands<\/a> that can change resources in place on a live cluster.<\/p>\n<p>Unfortunately this method is easily abused by both cowboy developers and ninja operators. When ad-hoc changes happen in the cluster, they are never recorded anywhere else.<\/p>\n<p>One of the most frequent reasons for failed deployments is environment configuration. A production deployment fails (even though it worked in the staging environment) because the configuration of the two environments is not the same anymore.<\/p>\n<figure id=\"attachment_18576\" aria-describedby=\"caption-attachment-18576\" style=\"width: 2390px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-05.png\"><img class=\"size-full wp-image-18576\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-05.png\" alt=\"Adhoc deployments\" width=\"2390\" height=\"1380\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-05.png 2390w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-05-300x173.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-05-1024x591.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-05-768x443.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-05-1536x887.png 1536w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-05-2048x1183.png 2048w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-05-20x12.png 20w\" sizes=\"(max-width: 2390px) 100vw, 2390px\" \/><\/a><figcaption id=\"caption-attachment-18576\" class=\"wp-caption-text\">Adhoc deployments<\/figcaption><\/figure>\n<p>Falling into this trap is very easy. Hotfixes, \u201cquick workarounds\u201d and other questionable hacks are always the main reasons behind ad-hoc changes.<\/p>\n<p>Kubectl should never be used for deployments by hand. All deployments should be taken care of by the deployment platform and ideally should also be recorded in Git following <a href=\"https:\/\/codefresh.io\/gitops\/\">the GitOps paradigm<\/a>.<\/p>\n<p>If all your deployments happen via a Git commit:<\/p>\n<ul>\n<li>You have a complete history of what happened in your cluster in the form of Git commit history<\/li>\n<li>You know exactly what is contained on each cluster at any point in time and how environments differ among themselves<\/li>\n<li>You can easily recreate or clone an environment from scratch by reading the Git configuration.<\/li>\n<li>Rolling back configuration is trivial as you can simply point your cluster to a previous commit.<\/li>\n<\/ul>\n<p>Most importantly, if a deployment fails, you can pinpoint really fast what was the last change that affected it and how it changed its configuration.<\/p>\n<p>The patch\/edit capabilities of <code>`kubectl`<\/code> should only be used for experimentation only. Changing live resources on a production cluster by hand is a recipe for disaster. Apart from having a proper deployment workflow, you should also agree with your time that abusing kubectl in this way should be avoided at all times.<\/p>\n<p>Continued on <a href=\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-2\/\">part 2<\/a>.<\/p>\n<p>Download the<a href=\"https:\/\/codefresh.io\/ebooks\/kubernetes-anti-patterns-ebook\/\">\u00a0ebook. <\/a><\/p>\n<p>Cover photo by <a href=\"https:\/\/unsplash.com\/photos\/YM_bUQ3WnNk\">Unsplash<\/a>.<\/p>\n<input class=\"fooboxshare_post_id\" type=\"hidden\" value=\"18591\"\/>","protected":false},"excerpt":{"rendered":"<p>In our previous guide, we documented 10 Docker anti-patterns. This guide has been very popular as it can help you in your first steps with container images. Creating container images for your application, however, is only half the story. You still need a way to deploy these containers in production, and the de facto solution &hellip; <a href=\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-1\/\">Read more<\/a><\/p>\n","protected":false},"author":62,"featured_media":18604,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[3120,5467,1657,1505,1543,1538],"tags":[14,15,22,24,44,52,53,64,68,5527],"yoast_head":"<!-- This site is optimized with the Yoast SEO Premium plugin v17.9 (Yoast SEO v18.4.1) - https:\/\/yoast.com\/wordpress\/plugins\/seo\/ -->\n<title>Kubernetes Deployment Antipatterns - part 1 | Codefresh<\/title>\n<meta name=\"description\" content=\"In our previous guide, we documented 10 Docker anti-patterns. Kubernetes deployment antipatterns guide can help you in creating container images for your application.\" \/>\n<meta name=\"robots\" content=\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\" \/>\n<link rel=\"canonical\" href=\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-1\/\" \/>\n<meta property=\"og:locale\" content=\"en_US\" \/>\n<meta property=\"og:type\" content=\"article\" \/>\n<meta property=\"og:title\" content=\"Kubernetes Deployment Antipatterns - part 1\" \/>\n<meta property=\"og:description\" content=\"In our previous guide, we documented 10 Docker anti-patterns. Kubernetes deployment antipatterns guide can help you in creating container images for your application.\" \/>\n<meta property=\"og:url\" content=\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-1\/\" \/>\n<meta property=\"og:site_name\" content=\"Codefresh\" \/>\n<meta property=\"article:publisher\" content=\"https:\/\/www.facebook.com\/codefresh.io\" \/>\n<meta property=\"article:published_time\" content=\"2021-01-20T16:44:42+00:00\" \/>\n<meta property=\"article:modified_time\" content=\"2022-03-22T16:00:41+00:00\" \/>\n<meta property=\"og:image\" content=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/blog-picture-2.jpg\" \/>\n\t<meta property=\"og:image:width\" content=\"1024\" \/>\n\t<meta property=\"og:image:height\" content=\"340\" \/>\n\t<meta property=\"og:image:type\" content=\"image\/jpeg\" \/>\n<meta name=\"twitter:card\" content=\"summary_large_image\" \/>\n<meta name=\"twitter:creator\" content=\"@codefresh\" \/>\n<meta name=\"twitter:site\" content=\"@codefresh\" \/>\n<meta name=\"twitter:label1\" content=\"Written by\" \/>\n\t<meta name=\"twitter:data1\" content=\"Kostis Kapelonis\" \/>\n\t<meta name=\"twitter:label2\" content=\"Est. reading time\" \/>\n\t<meta name=\"twitter:data2\" content=\"15 minutes\" \/>\n<script type=\"application\/ld+json\" class=\"yoast-schema-graph\">{\"@context\":\"https:\/\/schema.org\",\"@graph\":[{\"@type\":\"Organization\",\"@id\":\"https:\/\/codefresh.io\/#organization\",\"name\":\"Codefresh\",\"url\":\"https:\/\/codefresh.io\/\",\"sameAs\":[\"https:\/\/www.facebook.com\/codefresh.io\",\"https:\/\/www.linkedin.com\/company\/codefresh\",\"https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg\",\"https:\/\/twitter.com\/codefresh\"],\"logo\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#logo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"width\":800,\"height\":800,\"caption\":\"Codefresh\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/#logo\"}},{\"@type\":\"WebSite\",\"@id\":\"https:\/\/codefresh.io\/#website\",\"url\":\"https:\/\/codefresh.io\/\",\"name\":\"Codefresh\",\"description\":\"\",\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"potentialAction\":[{\"@type\":\"SearchAction\",\"target\":{\"@type\":\"EntryPoint\",\"urlTemplate\":\"https:\/\/codefresh.io\/?s={search_term_string}\"},\"query-input\":\"required name=search_term_string\"}],\"inLanguage\":\"en-US\"},{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-1\/#primaryimage\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/blog-picture-2.jpg\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/blog-picture-2.jpg\",\"width\":1024,\"height\":340},{\"@type\":\"WebPage\",\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-1\/#webpage\",\"url\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-1\/\",\"name\":\"Kubernetes Deployment Antipatterns - part 1 | Codefresh\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/#website\"},\"primaryImageOfPage\":{\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-1\/#primaryimage\"},\"datePublished\":\"2021-01-20T16:44:42+00:00\",\"dateModified\":\"2022-03-22T16:00:41+00:00\",\"description\":\"In our previous guide, we documented 10 Docker anti-patterns. Kubernetes deployment antipatterns guide can help you in creating container images for your application.\",\"breadcrumb\":{\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-1\/#breadcrumb\"},\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"ReadAction\",\"target\":[\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-1\/\"]}]},{\"@type\":\"BreadcrumbList\",\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-1\/#breadcrumb\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"name\":\"Home\",\"item\":\"https:\/\/codefresh.io\/\"},{\"@type\":\"ListItem\",\"position\":2,\"name\":\"Kubernetes Deployment Antipatterns &#8211; part 1\"}]},{\"@type\":\"Article\",\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-1\/#article\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-1\/#webpage\"},\"author\":{\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87\"},\"headline\":\"Kubernetes Deployment Antipatterns &#8211; part 1\",\"datePublished\":\"2021-01-20T16:44:42+00:00\",\"dateModified\":\"2022-03-22T16:00:41+00:00\",\"mainEntityOfPage\":{\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-1\/#webpage\"},\"wordCount\":2770,\"commentCount\":0,\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-1\/#primaryimage\"},\"thumbnailUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/blog-picture-2.jpg\",\"keywords\":[\"docker\",\"continuous integration\",\"monitoring\",\"Containers\",\"Kubernetes\",\"devops\",\"CI\/CD\",\"microservices\",\"continuous delivery\",\"patterns\"],\"articleSection\":[\"Continuous Deployment\/Delivery\",\"Devops\",\"Kubernetes Tutorials\",\"Containers\",\"Continuous Integration\",\"DevOps Tutorials\"],\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"CommentAction\",\"name\":\"Comment\",\"target\":[\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-1\/#respond\"]}]},{\"@type\":\"Person\",\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87\",\"name\":\"Kostis Kapelonis\",\"image\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#personlogo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png\",\"caption\":\"Kostis Kapelonis\"},\"description\":\"Kostis is a software engineer\/technical-writer dual class character. He lives and breathes automation, good testing practices and stress-free deployments with GitOps.\",\"url\":\"https:\/\/codefresh.io\/author\/kostiscodefresh-io\/\"}]}<\/script>\n<!-- \/ Yoast SEO Premium plugin. -->","yoast_head_json":{"title":"Kubernetes Deployment Antipatterns - part 1 | Codefresh","description":"In our previous guide, we documented 10 Docker anti-patterns. Kubernetes deployment antipatterns guide can help you in creating container images for your application.","robots":{"index":"index","follow":"follow","max-snippet":"max-snippet:-1","max-image-preview":"max-image-preview:large","max-video-preview":"max-video-preview:-1"},"canonical":"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-1\/","og_locale":"en_US","og_type":"article","og_title":"Kubernetes Deployment Antipatterns - part 1","og_description":"In our previous guide, we documented 10 Docker anti-patterns. Kubernetes deployment antipatterns guide can help you in creating container images for your application.","og_url":"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-1\/","og_site_name":"Codefresh","article_publisher":"https:\/\/www.facebook.com\/codefresh.io","article_published_time":"2021-01-20T16:44:42+00:00","article_modified_time":"2022-03-22T16:00:41+00:00","og_image":[{"width":1024,"height":340,"url":"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/blog-picture-2.jpg","type":"image\/jpeg"}],"twitter_card":"summary_large_image","twitter_creator":"@codefresh","twitter_site":"@codefresh","twitter_misc":{"Written by":"Kostis Kapelonis","Est. reading time":"15 minutes"},"schema":{"@context":"https:\/\/schema.org","@graph":[{"@type":"Organization","@id":"https:\/\/codefresh.io\/#organization","name":"Codefresh","url":"https:\/\/codefresh.io\/","sameAs":["https:\/\/www.facebook.com\/codefresh.io","https:\/\/www.linkedin.com\/company\/codefresh","https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg","https:\/\/twitter.com\/codefresh"],"logo":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#logo","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","width":800,"height":800,"caption":"Codefresh"},"image":{"@id":"https:\/\/codefresh.io\/#logo"}},{"@type":"WebSite","@id":"https:\/\/codefresh.io\/#website","url":"https:\/\/codefresh.io\/","name":"Codefresh","description":"","publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"potentialAction":[{"@type":"SearchAction","target":{"@type":"EntryPoint","urlTemplate":"https:\/\/codefresh.io\/?s={search_term_string}"},"query-input":"required name=search_term_string"}],"inLanguage":"en-US"},{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-1\/#primaryimage","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/blog-picture-2.jpg","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/blog-picture-2.jpg","width":1024,"height":340},{"@type":"WebPage","@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-1\/#webpage","url":"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-1\/","name":"Kubernetes Deployment Antipatterns - part 1 | Codefresh","isPartOf":{"@id":"https:\/\/codefresh.io\/#website"},"primaryImageOfPage":{"@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-1\/#primaryimage"},"datePublished":"2021-01-20T16:44:42+00:00","dateModified":"2022-03-22T16:00:41+00:00","description":"In our previous guide, we documented 10 Docker anti-patterns. Kubernetes deployment antipatterns guide can help you in creating container images for your application.","breadcrumb":{"@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-1\/#breadcrumb"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-1\/"]}]},{"@type":"BreadcrumbList","@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-1\/#breadcrumb","itemListElement":[{"@type":"ListItem","position":1,"name":"Home","item":"https:\/\/codefresh.io\/"},{"@type":"ListItem","position":2,"name":"Kubernetes Deployment Antipatterns &#8211; part 1"}]},{"@type":"Article","@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-1\/#article","isPartOf":{"@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-1\/#webpage"},"author":{"@id":"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87"},"headline":"Kubernetes Deployment Antipatterns &#8211; part 1","datePublished":"2021-01-20T16:44:42+00:00","dateModified":"2022-03-22T16:00:41+00:00","mainEntityOfPage":{"@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-1\/#webpage"},"wordCount":2770,"commentCount":0,"publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"image":{"@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-1\/#primaryimage"},"thumbnailUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/blog-picture-2.jpg","keywords":["docker","continuous integration","monitoring","Containers","Kubernetes","devops","CI\/CD","microservices","continuous delivery","patterns"],"articleSection":["Continuous Deployment\/Delivery","Devops","Kubernetes Tutorials","Containers","Continuous Integration","DevOps Tutorials"],"inLanguage":"en-US","potentialAction":[{"@type":"CommentAction","name":"Comment","target":["https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-1\/#respond"]}]},{"@type":"Person","@id":"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87","name":"Kostis Kapelonis","image":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#personlogo","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png","caption":"Kostis Kapelonis"},"description":"Kostis is a software engineer\/technical-writer dual class character. He lives and breathes automation, good testing practices and stress-free deployments with GitOps.","url":"https:\/\/codefresh.io\/author\/kostiscodefresh-io\/"}]}},"acf":[],"_links":{"self":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/18591"}],"collection":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/users\/62"}],"replies":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/comments?post=18591"}],"version-history":[{"count":1,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/18591\/revisions"}],"predecessor-version":[{"id":21512,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/18591\/revisions\/21512"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media\/18604"}],"wp:attachment":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media?parent=18591"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/categories?post=18591"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/tags?post=18591"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}