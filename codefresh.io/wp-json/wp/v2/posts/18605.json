{"id":18605,"date":"2021-01-20T08:46:42","date_gmt":"2021-01-20T16:46:42","guid":{"rendered":"https:\/\/codefresh.io\/?p=18605"},"modified":"2022-02-15T14:24:42","modified_gmt":"2022-02-15T14:24:42","slug":"kubernetes-antipatterns-2","status":"publish","type":"post","link":"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-2\/","title":{"rendered":"Kubernetes Deployment Antipatterns &#8211; part 2"},"content":{"rendered":"<p>This is the second part in our Kubernetes Anti-patterns series. See also <a href=\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-1\/\">part 1 <\/a> for for the previous part and <a href=\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-3\/\">part 3<\/a> for the next part. You can also download <a href=\"https:\/\/codefresh.io\/ebooks\/kubernetes-anti-patterns-ebook\/\">all 3 parts in a PDF ebook<\/a>.<\/p>\n<h2>Antipattern 6 &#8211; Using Kubectl as a debugging tool<\/h2>\n<p>While we are still on the topic of <code>kubectl<\/code>, is it important to mention its second-biggest shortcoming. <code>Kubectl <\/code>is not a debugging tool and should not be used as such.<\/p>\n<p>Every company that started adopting Kubernetes has eventually run into a problem that prompted the \u201c10-questions-game\u201d with <code>kubectl<\/code>. If you have a critical problem in your production cluster your first impulse should not be opening a terminal with <code>kubectl<\/code>. If you are doing this you have already lost the battle, especially if it is 3am, production is down and you are on call.<\/p>\n<pre>kubectl get ns\r\nkubectl get pods -n sales\r\nkubectl describe pod prod-app-1233445 -n sales\r\nkubectl get svc - n sales\r\nkubectl describe...\r\n<\/pre>\n<p>All your Kubernetes clusters should have proper monitoring\/tracing\/logging systems in place that can be used for pinpointing issues in a timely manner. If you need to run <code>kubectl <\/code>to inspect something it means that you have a gap in your observability tools and the thing that you need to inspect should be added to your monitoring tools.<\/p>\n<p>Even if you simply want to inspect a cluster that you are not familiar with you should use a dedicated tool for this purpose. There are many tools for inspecting Kubernetes clusters today.<\/p>\n<p><a href=\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubevious-kubernetes-dashboard\/\">Kubevious <\/a>for example is a comprehensive Kubernetes dashboard with a built-in rule engine that allows you to search and mark Kubernetes resources according to custom rules.<\/p>\n<figure id=\"attachment_18621\" aria-describedby=\"caption-attachment-18621\" style=\"width: 1906px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-11.png\"><img class=\"size-full wp-image-18621\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-11.png\" alt=\"Kubevious dashboard\" width=\"1906\" height=\"1454\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-11.png 1906w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-11-300x229.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-11-1024x781.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-11-768x586.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-11-1536x1172.png 1536w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-11-20x15.png 20w\" sizes=\"(max-width: 1906px) 100vw, 1906px\" \/><\/a><figcaption id=\"caption-attachment-18621\" class=\"wp-caption-text\">Kubevious dashboard<\/figcaption><\/figure>\n<p>Metrics and tracing are so important that will be discussed in another anti-pattern later in our list.<\/p>\n<h2>Anti-pattern 7 &#8211; Misunderstanding Kubernetes network concepts<\/h2>\n<p>Gone are the days, where a single load balancer was everything you needed for your application. Kubernetes introduces its own networking model and it is your duty to learn and understand the major concepts. At the very least you should be familiar with load balancers, clusterIPs, nodeports and <a href=\"https:\/\/kubernetes.io\/docs\/concepts\/services-networking\/ingress\/\">ingress <\/a>(and how they differ).<\/p>\n<p>We have seen both ends of the spectrum, where organizations create an overkill setup with a heavy-weight ingress controller (when a simple load balancer would suffice) or creating multiple load balancers (wasting money on the cloud provider) instead of a single ingress setup.<\/p>\n<p>Understanding the different service options is one of the most confusing aspects for people starting with Kubernetes networking. ClusterIP services are internal to the cluster, NodePorts are both internal and external and Load balancers are external to the cluster, so make sure that you understand the implications of each service type.<\/p>\n<figure id=\"attachment_18629\" aria-describedby=\"caption-attachment-18629\" style=\"width: 924px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-02.png\"><img class=\"size-full wp-image-18629\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-02.png\" alt=\"Kubernetes traffic types\" width=\"924\" height=\"710\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-02.png 924w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-02-300x231.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-02-768x590.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-02-20x15.png 20w\" sizes=\"(max-width: 924px) 100vw, 924px\" \/><\/a><figcaption id=\"caption-attachment-18629\" class=\"wp-caption-text\">Kubernetes traffic types<\/figcaption><\/figure>\n<p>And this is only for getting traffic inside your cluster. You should also pay attention to how traffic works within the cluster itself. DNS, security certificates, virtual services are all aspects that should be handled in detail for a production Kubernetes cluster.<\/p>\n<p>You should also spend some time to understand <a href=\"https:\/\/smi-spec.io\/\">what a service mesh is<\/a> and what problems it solves. We do not advocate that every cluster should have a service mesh. But you should understand how it works and why you would need it.<\/p>\n<p>You might argue that a developer should not have to learn about these networking concepts just to deploy an application, and you would be correct. We need an abstraction on top of Kubernetes for developers, but we don\u2019t have it yet.<\/p>\n<p>Even as a developer you should know how traffic reaches your application. If a request needs to perform 5 hops between pods, nodes and services and each hop has a possible latency of 100ms, then your users face a possible delay of 500ms when visiting a web page. You should be aware of this, so that spending effort to optimize response time is focused on the true bottlenecks.<\/p>\n<p>Also as a developer you should know what <a href=\"https:\/\/kubernetes.io\/docs\/tasks\/extend-kubernetes\/http-proxy-access-api\/\">kubectl proxy<\/a> does behind the scenes and when to use it.<\/p>\n<h2>Anti-pattern 8 &#8211; Using permanent staging environments instead of dynamic environments<\/h2>\n<p>With virtual machines (and even more so with bare metal servers) it is customary for a software team to have multiple predefined test environments that are used to verify an application before it reaches production.<\/p>\n<p>One of the most common patterns is having at least 3 environments (QA\/staging\/production) and depending on the size of the company you might have more. The most important of these environments is the \u201cintegration\u201d one (or whatever the company calls it) that gathers all features of developers after they are merged to the mainline branch.<\/p>\n<p>Leaving aside the aspects of cost (if you have predefined test environments you always pay for them in terms of computing capacity even when they are not used) the most pressing issue is feature isolation.<\/p>\n<figure id=\"attachment_18630\" aria-describedby=\"caption-attachment-18630\" style=\"width: 1808px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-03.png\"><img class=\"size-full wp-image-18630\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-03.png\" alt=\"Single staging environment\" width=\"1808\" height=\"1002\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-03.png 1808w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-03-300x166.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-03-1024x568.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-03-768x426.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-03-1536x851.png 1536w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-03-20x11.png 20w\" sizes=\"(max-width: 1808px) 100vw, 1808px\" \/><\/a><figcaption id=\"caption-attachment-18630\" class=\"wp-caption-text\">Single staging environment<\/figcaption><\/figure>\n<p>If you use a single environment for integration then when multiple developers merge features and something breaks, it is not immediately which of the feature(s) caused the problem. If 3 developers merge their features on a staging environment and the deployment fails (either the build fails, or the integration tests fail or the metrics explode) then there are several scenarios:<\/p>\n<ol>\n<li>Feature A is problematic, B and C are fine<\/li>\n<li>Feature B is problematic, A and C are fine<\/li>\n<li>Feature C is problematic, B and C are fine<\/li>\n<li>All features are fine on their own, but the combination of A and B is problematic<\/li>\n<li>All features are fine on their own, but the combination of A and C is problematic<\/li>\n<li>All features are fine on their own, but the combination of B and C is problematic<\/li>\n<li>All features are fine on their own, but the combination of all 3 is problematic<\/li>\n<\/ol>\n<p>Depending on the size of your programming team and the complexity of your software, distinguishing between these scenarios is a lengthy process. If a GUI button changes position it is probably easy to find out which developer is responsible for the commit. But if your recommendation engine suddenly became 5x slower, how quick can you identify the responsible feature if all 3 developers worked on the recommendation engine for this sprint?<\/p>\n<p>To overcome this problem, companies almost always adopt the \u201cbooking paradigm\u201d:<\/p>\n<ol>\n<li>The staging environment is \u201cbooked\u201d by each individual developer so that they can test their feature in isolation.<\/li>\n<li>The company creates multiple \u201cstaging\u201d environments that developers use for testing their features (as a single environment can quickly become a bottleneck).<\/li>\n<\/ol>\n<figure id=\"attachment_18631\" aria-describedby=\"caption-attachment-18631\" style=\"width: 1554px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-10.png\"><img class=\"size-full wp-image-18631\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-10.png\" alt=\"Predefined test environments\" width=\"1554\" height=\"605\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-10.png 1554w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-10-300x117.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-10-1024x399.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-10-768x299.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-10-1536x598.png 1536w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-10-20x8.png 20w\" sizes=\"(max-width: 1554px) 100vw, 1554px\" \/><\/a><figcaption id=\"caption-attachment-18631\" class=\"wp-caption-text\">Predefined test environments<\/figcaption><\/figure>\n<p>This situation is still problematic because developers not only have to coordinate between themselves for choosing environments, but also because you have to keep track of the cleaning actions of each environment. For example, if multiple developers need a database changeset along with their feature, they need to make sure that the database of each staging environment contains only their own changes and not the changes of the previous developer that used that environment.<\/p>\n<p>Additionally, multiple permanent staging environments can quickly suffer from the well known problem of configuration drift where environments are supposed to be the same, but after several ad-hoc changes, they are not.<\/p>\n<p>The solution of course, is to abandon the manual maintenance of static environments and move to dynamic environments that are created and destroyed on demand. With Kubernetes this is very easy to accomplish:<\/p>\n<figure id=\"attachment_18632\" aria-describedby=\"caption-attachment-18632\" style=\"width: 1788px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-06.png\"><img class=\"size-full wp-image-18632\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-06.png\" alt=\"Dynamic preview environments\" width=\"1788\" height=\"958\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-06.png 1788w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-06-300x161.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-06-1024x549.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-06-768x411.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-06-1536x823.png 1536w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/Flows-06-20x11.png 20w\" sizes=\"(max-width: 1788px) 100vw, 1788px\" \/><\/a><figcaption id=\"caption-attachment-18632\" class=\"wp-caption-text\">Dynamic preview environments<\/figcaption><\/figure>\n<p>There are many ways to achieve this scenario, but at the very least every Open Pull Request should create a dynamic environment that contains only that Pull Request and nothing else. The environment is automatically destroyed when the pull request is merged\/closed or after a specified amount of time.<\/p>\n<p>The big strength of automatic environments however is the complete freedom of developers. If I am a developer and just finished with feature A and my colleague finished feature B, I should be able to do:<\/p>\n<pre>git checkout master\r\ngit checkout -b feature-a-b-together\r\ngit merge feature-a\r\ngit merge feature-b\r\ngit push origin feature-a-b-together\r\n<\/pre>\n<p>And then magically a dynamic environment should be present at: feature-a-b-together.staging.company.com or staging.company.com\/feature-a-b-together.<\/p>\n<p>Behind the scenes you can use Kubernetes namespaces and ingress rules for this isolation.<\/p>\n<p>Note that it is ok if your company has permanent staging environments for specialized needs such as load testing, security penetration analysis, A\/B deployments etc. But for the basic scenario of \u201cI am a developer and want to see my feature running and run integration tests against it\u201d, dynamic environments is the way to go.<\/p>\n<p>If you are still using permanent environments for feature testing you are making life hard for your developers and are also wasting system resources when your environments are not actively used.<\/p>\n<h2>Anti-pattern 9 &#8211; Mixing production and non-production clusters<\/h2>\n<p>Even though Kubernetes is specifically designed for cluster orchestration you shouldn\u2019t fall into the trap of creating a single big cluster for all your needs. At the very least you should have two clusters, a production one and a non-production one.<\/p>\n<p>First of all, mixing production and non-production is an obvious bad idea for resource starvation. You don\u2019t want a rogue development version to overstep on the resource of the production version of something.<\/p>\n<p>But as far as developers are concerned the biggest problem has to do with security. Unless you take active steps against it, all communication inside a Kubernetes cluster is allowed by default. And contrary to popular belief a pod from one namespace can freely communicate with a pod on another namespace. There are also some Kubernetes resources that are not namespaced at all.<\/p>\n<p>Kubernetes namespaces are <strong>not <\/strong>a security measure. If your team has advanced Kubernetes knowledge then it is indeed possible to support multi-tenancy inside a cluster and secure all workloads against each other. But this requires significant effort and in most cases, it is much simpler to create a second cluster exclusively for production.<\/p>\n<p>If you combine this anti-pattern with the second one (baking configuration inside containers) it should be obvious that a lot of bad scenarios can happen.<\/p>\n<p>The most classic one:<\/p>\n<ol>\n<li>A developer creates a feature namespace on a cluster that also houses production<\/li>\n<li>They deploy their feature code in the namespace and start running integration tests<\/li>\n<li>The integration tests write dummy data, or clean the DB, or tamper with the backend in a destructive manner<\/li>\n<li>Unfortunately the containers had production URLs and configuration inside them, and thus all integration tests actually affected the production workloads!<\/li>\n<\/ol>\n<p>To avoid falling into this trap, it is much easier to simply designate production and non-production clusters. Unfortunately several tutorials imply that namespaces can be used for environment division and <a href=\"https:\/\/kubernetes.io\/docs\/tasks\/administer-cluster\/namespaces\/#subdividing-your-cluster-using-kubernetes-namespaces\">even the official Kubernetes documentation has examples with prod\/dev namespaces<\/a>.<\/p>\n<p>Note that depending on the size of your company you might have more clusters than two such as:<\/p>\n<ol>\n<li>Production<\/li>\n<li>Shadow\/clone of production but with less resources<\/li>\n<li>Developer clusters for feature testing (see the previous section)<\/li>\n<li>Specialized cluster for load testing\/security (see previous section)<\/li>\n<li>Cluster for internal tools<\/li>\n<\/ol>\n<p>No matter the size of your company you always should have at least 2 (production and everything else that is not production).<\/p>\n<h2>Anti-pattern 10 &#8211; Deploying without memory and cpu limits<\/h2>\n<p>By default an application that is deployed to Kubernetes has no specified resource limits. This means that your application can potentially take over the whole cluster. This would be problematic in a staging cluster and catastrophic in a production cluster as the slightest memory leak or CPU hiccup will wreak havoc in the rest of the applications.<\/p>\n<p>This means that all your applications (regardless of the target cluster) should have associated resource limits.<\/p>\n<p>Maybe as a developer you don\u2019t need to know all the details on how the limits are set, but it is your responsibility to give some hints and advice to the person that is managing your cluster on what are the expectations of the application.<\/p>\n<p>Unfortunately, simply looking at the average memory and CPU usage of an application is not enough. Average resources are just that &#8211; average. You need to examine your application and see with bursts of traffic and load and understand what is the behaviour of the resources under extreme conditions. After all, this is exactly the kind of condition that you don\u2019t want your application to be restarted without reason.<\/p>\n<p>One of the benefits of Kubernetes is the elasticity of resources. If the cluster is killing\/restarting your application just when it is starting to handle significant load (because let\u2019s say your eshop is getting hammered with traffic), you have lost the advantage of using a cluster in the first place.<\/p>\n<p>On the other hand, setting too high limits is a waste of resources and makes your cluster less efficient.<\/p>\n<p>You also need to examine your programming languages for specific usage patterns and how resources are used by the underlying platform. Legacy Java applications for example have notorious problems with memory limits.<\/p>\n<p>Note that once you gain confidence with your application and how it uses Kubernetes resources you can also automate the whole resource game with a <a href=\"https:\/\/github.com\/kubernetes\/autoscaler\/tree\/master\/vertical-pod-autoscaler\">vertical cluster auto-scaler<\/a>.<\/p>\n<p>Continued on <a href=\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-3\/\">part 3<\/a>.<\/p>\n<p>Download the<a href=\"https:\/\/codefresh.io\/ebooks\/kubernetes-anti-patterns-ebook\/\"> ebook.<\/a><\/p>\n<p>Cover photo by <a href=\"https:\/\/unsplash.com\/photos\/YM_bUQ3WnNk\">Unsplash<\/a>.<\/p>\n<input class=\"fooboxshare_post_id\" type=\"hidden\" value=\"18605\"\/>","protected":false},"excerpt":{"rendered":"<p>This is the second part in our Kubernetes Anti-patterns series. See also part 1 for for the previous part and part 3 for the next part. You can also download all 3 parts in a PDF ebook. Antipattern 6 &#8211; Using Kubectl as a debugging tool While we are still on the topic of kubectl, &hellip; <a href=\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-2\/\">Read more<\/a><\/p>\n","protected":false},"author":62,"featured_media":18617,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[3120,5467,1657,1505,1543,1538],"tags":[14,15,22,24,44,52,53,64,68,5527],"yoast_head":"<!-- This site is optimized with the Yoast SEO Premium plugin v17.9 (Yoast SEO v18.4.1) - https:\/\/yoast.com\/wordpress\/plugins\/seo\/ -->\n<title>Kubernetes Deployment Antipatterns - part 2 | Codefresh<\/title>\n<meta name=\"robots\" content=\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\" \/>\n<link rel=\"canonical\" href=\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-2\/\" \/>\n<meta property=\"og:locale\" content=\"en_US\" \/>\n<meta property=\"og:type\" content=\"article\" \/>\n<meta property=\"og:title\" content=\"Kubernetes Deployment Antipatterns - part 2\" \/>\n<meta property=\"og:description\" content=\"This is the second part in our Kubernetes Anti-patterns series. See also part 1 for for the previous part and part 3 for the next part. You can also download all 3 parts in a PDF ebook. Antipattern 6 &#8211; Using Kubectl as a debugging tool While we are still on the topic of kubectl, &hellip; Read more\" \/>\n<meta property=\"og:url\" content=\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-2\/\" \/>\n<meta property=\"og:site_name\" content=\"Codefresh\" \/>\n<meta property=\"article:publisher\" content=\"https:\/\/www.facebook.com\/codefresh.io\" \/>\n<meta property=\"article:published_time\" content=\"2021-01-20T16:46:42+00:00\" \/>\n<meta property=\"article:modified_time\" content=\"2022-02-15T14:24:42+00:00\" \/>\n<meta property=\"og:image\" content=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/blog-picture-3.jpg\" \/>\n\t<meta property=\"og:image:width\" content=\"1024\" \/>\n\t<meta property=\"og:image:height\" content=\"340\" \/>\n\t<meta property=\"og:image:type\" content=\"image\/jpeg\" \/>\n<meta name=\"twitter:card\" content=\"summary_large_image\" \/>\n<meta name=\"twitter:creator\" content=\"@codefresh\" \/>\n<meta name=\"twitter:site\" content=\"@codefresh\" \/>\n<meta name=\"twitter:label1\" content=\"Written by\" \/>\n\t<meta name=\"twitter:data1\" content=\"Kostis Kapelonis\" \/>\n\t<meta name=\"twitter:label2\" content=\"Est. reading time\" \/>\n\t<meta name=\"twitter:data2\" content=\"11 minutes\" \/>\n<script type=\"application\/ld+json\" class=\"yoast-schema-graph\">{\"@context\":\"https:\/\/schema.org\",\"@graph\":[{\"@type\":\"Organization\",\"@id\":\"https:\/\/codefresh.io\/#organization\",\"name\":\"Codefresh\",\"url\":\"https:\/\/codefresh.io\/\",\"sameAs\":[\"https:\/\/www.facebook.com\/codefresh.io\",\"https:\/\/www.linkedin.com\/company\/codefresh\",\"https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg\",\"https:\/\/twitter.com\/codefresh\"],\"logo\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#logo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"width\":800,\"height\":800,\"caption\":\"Codefresh\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/#logo\"}},{\"@type\":\"WebSite\",\"@id\":\"https:\/\/codefresh.io\/#website\",\"url\":\"https:\/\/codefresh.io\/\",\"name\":\"Codefresh\",\"description\":\"\",\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"potentialAction\":[{\"@type\":\"SearchAction\",\"target\":{\"@type\":\"EntryPoint\",\"urlTemplate\":\"https:\/\/codefresh.io\/?s={search_term_string}\"},\"query-input\":\"required name=search_term_string\"}],\"inLanguage\":\"en-US\"},{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-2\/#primaryimage\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/blog-picture-3.jpg\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/blog-picture-3.jpg\",\"width\":1024,\"height\":340},{\"@type\":\"WebPage\",\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-2\/#webpage\",\"url\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-2\/\",\"name\":\"Kubernetes Deployment Antipatterns - part 2 | Codefresh\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/#website\"},\"primaryImageOfPage\":{\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-2\/#primaryimage\"},\"datePublished\":\"2021-01-20T16:46:42+00:00\",\"dateModified\":\"2022-02-15T14:24:42+00:00\",\"breadcrumb\":{\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-2\/#breadcrumb\"},\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"ReadAction\",\"target\":[\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-2\/\"]}]},{\"@type\":\"BreadcrumbList\",\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-2\/#breadcrumb\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"name\":\"Home\",\"item\":\"https:\/\/codefresh.io\/\"},{\"@type\":\"ListItem\",\"position\":2,\"name\":\"Kubernetes Deployment Antipatterns &#8211; part 2\"}]},{\"@type\":\"Article\",\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-2\/#article\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-2\/#webpage\"},\"author\":{\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87\"},\"headline\":\"Kubernetes Deployment Antipatterns &#8211; part 2\",\"datePublished\":\"2021-01-20T16:46:42+00:00\",\"dateModified\":\"2022-02-15T14:24:42+00:00\",\"mainEntityOfPage\":{\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-2\/#webpage\"},\"wordCount\":2178,\"commentCount\":2,\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-2\/#primaryimage\"},\"thumbnailUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/blog-picture-3.jpg\",\"keywords\":[\"docker\",\"continuous integration\",\"monitoring\",\"Containers\",\"Kubernetes\",\"devops\",\"CI\/CD\",\"microservices\",\"continuous delivery\",\"patterns\"],\"articleSection\":[\"Continuous Deployment\/Delivery\",\"Devops\",\"Kubernetes Tutorials\",\"Containers\",\"Continuous Integration\",\"DevOps Tutorials\"],\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"CommentAction\",\"name\":\"Comment\",\"target\":[\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-2\/#respond\"]}]},{\"@type\":\"Person\",\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87\",\"name\":\"Kostis Kapelonis\",\"image\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#personlogo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png\",\"caption\":\"Kostis Kapelonis\"},\"description\":\"Kostis is a software engineer\/technical-writer dual class character. He lives and breathes automation, good testing practices and stress-free deployments with GitOps.\",\"url\":\"https:\/\/codefresh.io\/author\/kostiscodefresh-io\/\"}]}<\/script>\n<!-- \/ Yoast SEO Premium plugin. -->","yoast_head_json":{"title":"Kubernetes Deployment Antipatterns - part 2 | Codefresh","robots":{"index":"index","follow":"follow","max-snippet":"max-snippet:-1","max-image-preview":"max-image-preview:large","max-video-preview":"max-video-preview:-1"},"canonical":"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-2\/","og_locale":"en_US","og_type":"article","og_title":"Kubernetes Deployment Antipatterns - part 2","og_description":"This is the second part in our Kubernetes Anti-patterns series. See also part 1 for for the previous part and part 3 for the next part. You can also download all 3 parts in a PDF ebook. Antipattern 6 &#8211; Using Kubectl as a debugging tool While we are still on the topic of kubectl, &hellip; Read more","og_url":"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-2\/","og_site_name":"Codefresh","article_publisher":"https:\/\/www.facebook.com\/codefresh.io","article_published_time":"2021-01-20T16:46:42+00:00","article_modified_time":"2022-02-15T14:24:42+00:00","og_image":[{"width":1024,"height":340,"url":"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/blog-picture-3.jpg","type":"image\/jpeg"}],"twitter_card":"summary_large_image","twitter_creator":"@codefresh","twitter_site":"@codefresh","twitter_misc":{"Written by":"Kostis Kapelonis","Est. reading time":"11 minutes"},"schema":{"@context":"https:\/\/schema.org","@graph":[{"@type":"Organization","@id":"https:\/\/codefresh.io\/#organization","name":"Codefresh","url":"https:\/\/codefresh.io\/","sameAs":["https:\/\/www.facebook.com\/codefresh.io","https:\/\/www.linkedin.com\/company\/codefresh","https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg","https:\/\/twitter.com\/codefresh"],"logo":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#logo","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","width":800,"height":800,"caption":"Codefresh"},"image":{"@id":"https:\/\/codefresh.io\/#logo"}},{"@type":"WebSite","@id":"https:\/\/codefresh.io\/#website","url":"https:\/\/codefresh.io\/","name":"Codefresh","description":"","publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"potentialAction":[{"@type":"SearchAction","target":{"@type":"EntryPoint","urlTemplate":"https:\/\/codefresh.io\/?s={search_term_string}"},"query-input":"required name=search_term_string"}],"inLanguage":"en-US"},{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-2\/#primaryimage","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/blog-picture-3.jpg","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/blog-picture-3.jpg","width":1024,"height":340},{"@type":"WebPage","@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-2\/#webpage","url":"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-2\/","name":"Kubernetes Deployment Antipatterns - part 2 | Codefresh","isPartOf":{"@id":"https:\/\/codefresh.io\/#website"},"primaryImageOfPage":{"@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-2\/#primaryimage"},"datePublished":"2021-01-20T16:46:42+00:00","dateModified":"2022-02-15T14:24:42+00:00","breadcrumb":{"@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-2\/#breadcrumb"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-2\/"]}]},{"@type":"BreadcrumbList","@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-2\/#breadcrumb","itemListElement":[{"@type":"ListItem","position":1,"name":"Home","item":"https:\/\/codefresh.io\/"},{"@type":"ListItem","position":2,"name":"Kubernetes Deployment Antipatterns &#8211; part 2"}]},{"@type":"Article","@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-2\/#article","isPartOf":{"@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-2\/#webpage"},"author":{"@id":"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87"},"headline":"Kubernetes Deployment Antipatterns &#8211; part 2","datePublished":"2021-01-20T16:46:42+00:00","dateModified":"2022-02-15T14:24:42+00:00","mainEntityOfPage":{"@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-2\/#webpage"},"wordCount":2178,"commentCount":2,"publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"image":{"@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-2\/#primaryimage"},"thumbnailUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/01\/blog-picture-3.jpg","keywords":["docker","continuous integration","monitoring","Containers","Kubernetes","devops","CI\/CD","microservices","continuous delivery","patterns"],"articleSection":["Continuous Deployment\/Delivery","Devops","Kubernetes Tutorials","Containers","Continuous Integration","DevOps Tutorials"],"inLanguage":"en-US","potentialAction":[{"@type":"CommentAction","name":"Comment","target":["https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-2\/#respond"]}]},{"@type":"Person","@id":"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87","name":"Kostis Kapelonis","image":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#personlogo","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png","caption":"Kostis Kapelonis"},"description":"Kostis is a software engineer\/technical-writer dual class character. He lives and breathes automation, good testing practices and stress-free deployments with GitOps.","url":"https:\/\/codefresh.io\/author\/kostiscodefresh-io\/"}]}},"acf":[],"_links":{"self":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/18605"}],"collection":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/users\/62"}],"replies":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/comments?post=18605"}],"version-history":[{"count":1,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/18605\/revisions"}],"predecessor-version":[{"id":21513,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/18605\/revisions\/21513"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media\/18617"}],"wp:attachment":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media?parent=18605"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/categories?post=18605"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/tags?post=18605"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}