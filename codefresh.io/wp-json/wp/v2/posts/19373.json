{"id":19373,"date":"2021-06-11T05:05:26","date_gmt":"2021-06-11T13:05:26","guid":{"rendered":"https:\/\/codefresh.io\/?p=19373"},"modified":"2021-12-14T11:47:55","modified_gmt":"2021-12-14T11:47:55","slug":"enterprise-ci-cd-best-practices-part-3","status":"publish","type":"post","link":"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-3\/","title":{"rendered":"Enterprise CI\/CD Best Practices &#8211; Part 3"},"content":{"rendered":"<p>This is the third and last part in our &#8220;Enterprise CI\/CD best practices&#8221; series. See also <a href=\"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-1\/\">part 1<\/a> and <a href=\"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-2\/\">part 2<\/a> for the previous best practices. You can also download all <a href=\"https:\/\/codefresh.io\/ebooks\/enterprise-ci-cd-best-practices\/\">3 parts in a PDF ebook<\/a>.<\/p>\n<h2>Best Practice 16 &#8211; Database Updates have their own Lifecycle<\/h2>\n<p>As more and more companies adopt continuous delivery we see an alarming trend of treating databases as an external entity that exists outside of the delivery process. This could not be further from the truth.<\/p>\n<p>Databases (and other supporting systems such as message queues, caches, service discovery solutions, etc.) should be handled like any other software project. This means:<\/p>\n<ol>\n<li>Their configuration and contents should be stored in version control<\/li>\n<li>All associated scripts, maintenance actions, and upgrade\/downgrade instructions should also be in version control<\/li>\n<li>Configuration changes should be approved like any other software change (passing from automated analysis, pull request review, security scanning, unit testing, etc.)<\/li>\n<li>Dedicated pipelines should be responsible for installing\/upgrading\/rolling back each new version of the database<\/li>\n<\/ol>\n<p>The last point is especially important. There are a lot of programming frameworks (e.g., rails migrations, Java Liquibase, ORM migrations) that allow the application itself to handle DB migrations. Usually the first time the application startup it can also upgrade the associate database to the correct schema. While convenient, this practice makes rollbacks very difficult and is best avoided.<\/p>\n<p>Database migration should be handled like an isolated software upgrade. You should have automated pipelines that deal only with the database, and the application pipelines should not touch the database in any way. This will give you the maximum flexibility to handle database upgrades and rollbacks by controlling exactly when and how a database upgrade takes place.<\/p>\n<h2>Best Practice 17 &#8211; Database Updates are Automated<\/h2>\n<p>Several organizations have stellar pipelines for the application code, but pay very little attention to automation for database updates. Handling databases should be given the same importance (if not more) as with the application itself.<\/p>\n<p>This means that you should similarly automate databases to application code:<\/p>\n<ul>\n<li>Store database changesets in source control<\/li>\n<li>Create pipelines that automatically update your database when a new changeset is created<\/li>\n<li>Have dynamic temporary environments for databases where changesets are reviewed before being merged to mainly<\/li>\n<li>Have code reviews and other quality checks on database changesets <\/li>\n<li>\nHave a strategy for doing rollbacks after a failed database upgrade<\/li>\n<\/ul>\n<p>It also helps if you automate the transformation of production data to test data that can be used in your test environments for your application code. In most cases, it is inefficient (or even impossible due to security constraints) to keep a copy of all production data in test environments. It is better to have a small subset of data that is anonymized\/simplified so that it can be handled more efficiently.<\/p>\n<h2>Best Practice 18 &#8211; Perform Gradual Database Upgrades<\/h2>\n<p>Application rollbacks are well understood and we are now at the point where we have dedicated tools that perform rollbacks after a failed application deployment. And with progressively delivery techniques such as canaries and blue\/green deployments, we can minimize the downtime even further.<\/p>\n<p>Progressive delivery techniques do not work on databases (because of the inherent state), but we can plan the database upgrades and adopt <a href=\"https:\/\/martinfowler.com\/articles\/evodb.html\">evolutionary database design principles<\/a>.<\/p>\n<p>By following an evolutionary design you can make all your database changesets backward and forwards compatible allowing you to rollback application and database changes at any time without any ill effects<\/p>\n<p>As an example, if you want to rename a column, instead of simply creating a changeset the renames the column and performing a single database upgrade, you instead follow a schedule of gradual updates as below:<\/p>\n<ol>\n<li>Database changeset that only adds a new column with the new name (and copies existing data from the old column). The application code is still writing\/reading from the old column<\/li>\n<li>Application upgrade where the application code now writes to both columns but reads from the new column<\/li>\n<li>Application upgrade where the application code writes\/reads only to the new column<\/li>\n<li>Database upgrade that removes the old column<\/li>\n<\/ol>\n<p>The process needs a well-disciplined team as it makes each database change span over several deployments. But the advantages of this process cannot be overstated. At any stage in this process, you can go back to the previous version without losing data and without the need for downtime.<\/p>\n<p>For the full list of techniques see the <a href=\"https:\/\/databaserefactoring.com\/\">database refactoring website<\/a>.\\<\/p>\n<h2>Best Practice 19 &#8211; All deployments must happen via the CD platform only (and never from workstations)<\/h2>\n<p>Continuing the theme of immutable artifacts and deployments that send to production what was deployed, we must also make sure the pipelines themselves are the only single path to production.<\/p>\n<figure id=\"attachment_19559\" aria-describedby=\"caption-attachment-19559\" style=\"width: 2114px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/only-from-ci.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/only-from-ci.png\" alt=\"Deploy from a single place\" width=\"2114\" height=\"756\" class=\"size-full wp-image-19559\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/only-from-ci.png 2114w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/only-from-ci-300x107.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/only-from-ci-1024x366.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/only-from-ci-768x275.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/only-from-ci-1536x549.png 1536w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/only-from-ci-2048x732.png 2048w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/only-from-ci-20x7.png 20w\" sizes=\"(max-width: 2114px) 100vw, 2114px\" \/><\/a><figcaption id=\"caption-attachment-19559\" class=\"wp-caption-text\">Deploy from a single place<\/figcaption><\/figure>\n<p>The main way to use CI\/CD pipelines as intended is to make sure that the CI\/CD platform is the <strong>only <\/strong>application that can deploy to production. This practice guarantees that production environments are running what they are expected to be running (i.e., the last artifact that was deployed).<\/p>\n<p>Unfortunately, several organizations either allow developers to deploy directly from their workstations, or even to \u201cinject\u201d their artifacts in a pipeline at various stages.<\/p>\n<p>This is a very dangerous practice as it breaks the traceability and monitoring offered by a proper CI\/CD platform. It allows developers to deploy to production features that might not be committed in source control in the first place. A lot of failed deployments stem from a missing file that was present on a developer workstation and not in source control.<\/p>\n<figure id=\"attachment_19560\" aria-describedby=\"caption-attachment-19560\" style=\"width: 2238px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/multiple-ways-to-deploy.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/multiple-ways-to-deploy.png\" alt=\"Multiple ways to deploy\" width=\"2238\" height=\"756\" class=\"size-full wp-image-19560\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/multiple-ways-to-deploy.png 2238w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/multiple-ways-to-deploy-300x101.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/multiple-ways-to-deploy-1024x346.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/multiple-ways-to-deploy-768x259.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/multiple-ways-to-deploy-1536x519.png 1536w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/multiple-ways-to-deploy-2048x692.png 2048w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/multiple-ways-to-deploy-20x7.png 20w\" sizes=\"(max-width: 2238px) 100vw, 2238px\" \/><\/a><figcaption id=\"caption-attachment-19560\" class=\"wp-caption-text\">Multiple ways to deploy<\/figcaption><\/figure>\n<p>In summary, there is only a single critical path for deployments, and this path is strictly handed by the CI\/CD platform. Deploying production code from developer workstations should be prohibited at the network\/access\/hardware level.<\/p>\n<h2>Best Practice 20 &#8211; Use Progressive Deployment Patterns<\/h2>\n<p>We already talked about database deployments in best practice 18 and how each database upgrade should be forwards and backward compatible. This pattern goes hand-in-hand with progressive delivery patterns on the application side.<\/p>\n<p>Traditional deployments follow an all-or-nothing approach where all application instances move forward to the next version of the software. This is a very simple deployment approach but makes rollbacks a challenging process.<\/p>\n<p>You should instead look at:<\/p>\n<ol>\n<li><a href=\"https:\/\/martinfowler.com\/bliki\/BlueGreenDeployment.html\">Blue\/Green deployments<\/a> that deploy a whole new set of instances of the new version, but still keep the old one for easy rollbacks<\/li>\n<li><a href=\"https:\/\/martinfowler.com\/bliki\/CanaryRelease.html\">Canary releases<\/a> where only a subset of the application instances move to the new version. Most users are still routed to the previous version <\/li>\n<\/ol>\n<p>If you couple these techniques with gradual database deployments, you can minimize the amount of downtime involved when a new deployment happens. Rollbacks also become a trivial process as in both cases you simply change your load balancer\/service mesh to the previous configuration and all users are routed back to the original version of the application.<\/p>\n<p>Make sure to also look at involving your metrics (see best practices 21 and 22) in the deployment process for fully automated rollbacks.<\/p>\n<h2>Best Practice 21 &#8211; Metrics and logs can detect a bad deployment <\/h2>\n<p>Having a pipeline that deploys your application (even when you use progressive delivery) is not enough if you want to know what is the real result of the deployment. Deployments that look \u201csuccessful\u201d at first glance, but soon prove to introduce regressions is a very common occurrence in large software projects.<\/p>\n<p>A lot of development teams simply perform a visual check\/smoke test after a deployment has finished and call it a day if everything \u201clooks\u201d good. But this practice is not enough and can quickly lead to the introduction of subtle bugs or performance issues.<\/p>\n<figure id=\"attachment_19561\" aria-describedby=\"caption-attachment-19561\" style=\"width: 1478px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/without-metrics.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/without-metrics.png\" alt=\"Without metrics\" width=\"1478\" height=\"1050\" class=\"size-full wp-image-19561\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/without-metrics.png 1478w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/without-metrics-300x213.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/without-metrics-1024x727.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/without-metrics-768x546.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/without-metrics-20x14.png 20w\" sizes=\"(max-width: 1478px) 100vw, 1478px\" \/><\/a><figcaption id=\"caption-attachment-19561\" class=\"wp-caption-text\">Without metrics<\/figcaption><\/figure>\n<p>The correct approach is the adoption of application (and infrastructure) metrics. This includes:<\/p>\n<ul>\n<li>Detailed logs for application events<\/li>\n<li>Metrics that count and monitor key features of the application<\/li>\n<li>Tracing information that can provide an in-depth understanding of what a single request is doing<\/li>\n<\/ul>\n<p>Once these metrics are in place, the effects of deployment should be judged according to a before\/after comparison of these metrics. This means that metrics should not be simply a debugging mechanism (post-incident), but should act instead as an early warning measure against failed deployments.<\/p>\n<figure id=\"attachment_19562\" aria-describedby=\"caption-attachment-19562\" style=\"width: 1412px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/with-metrics.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/with-metrics.png\" alt=\"With metrics\" width=\"1412\" height=\"736\" class=\"size-full wp-image-19562\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/with-metrics.png 1412w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/with-metrics-300x156.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/with-metrics-1024x534.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/with-metrics-768x400.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/with-metrics-20x10.png 20w\" sizes=\"(max-width: 1412px) 100vw, 1412px\" \/><\/a><figcaption id=\"caption-attachment-19562\" class=\"wp-caption-text\">With metrics<\/figcaption><\/figure>\n<p>Choosing what events to monitor and where to place logs is a complex process. For large applications, it is best to follow a gradual redefinition of key metrics according to past deployments. The suggested workflow is the following:<\/p>\n<ol>\n<li>Place logs and metrics on events that you guess will show a failed deployment<\/li>\n<li>Perform several deployments and see if your metrics can detect the failed ones<\/li>\n<li>If you see a failed deployment that wasn\u2019t detected in your metrics, it means that they are not enough. Fine-tune your metrics accordingly so that the next time a deployment fails in the same manner you actually know it in advance<\/li>\n<\/ol>\n<p>Too many times, development teams focus on \u201cvanity\u201d metrics, i.e., metrics that look good on paper but say nothing about a failed deployment.<\/p>\n<h2>Best Practice 22 &#8211; Automatic Rollbacks are in place<\/h2>\n<p>This is a continuation of the previous best practice. If you already have good metrics in place (that can verify the success of a deployment) you can take them to the next level by having automated rollbacks that depend on them.<\/p>\n<p>A lot of organizations have great metrics in place, but only manually use them:<\/p>\n<ol>\n<li>A developer looks at some key metrics before deployment <\/li>\n<li>Deployment is triggered<\/li>\n<li>The developer looks at the metrics in an ad-hoc manner to see what happened with the deployment<\/li>\n<\/ol>\n<p>While this technique is very popular, it is far from effective. Depending on the complexity of the application, the time spent watching metrics can be 1-2 hours so that the effects of the deployment have time to become visible.<\/p>\n<p>It is not uncommon for deployments to be marked as \u201cfailed\u201d after 6-24 hours either because nobody paid attention to the correct metrics or because people simply disregarded warnings and errors thinking that was not a result of the deployment.<\/p>\n<p>Several organizations are also forced to only deploy during working hours because only at that time there are enough human eyes to look at metrics.<\/p>\n<p>Metrics should become part of the deployment process. The deployment pipeline should automatically consult metrics after a deployment happens and compare them against a known threshold or their previous state. And then in a fully automated manner, the deployment should either be marked as finished or even rolled back.<\/p>\n<figure id=\"attachment_19563\" aria-describedby=\"caption-attachment-19563\" style=\"width: 1840px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/Flows-16.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/Flows-16.png\" alt=\"automated rollbacks\" width=\"1840\" height=\"552\" class=\"size-full wp-image-19563\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/Flows-16.png 1840w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/Flows-16-300x90.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/Flows-16-1024x307.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/Flows-16-768x230.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/Flows-16-1536x461.png 1536w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/Flows-16-20x6.png 20w\" sizes=\"(max-width: 1840px) 100vw, 1840px\" \/><\/a><figcaption id=\"caption-attachment-19563\" class=\"wp-caption-text\">automated rollbacks<\/figcaption><\/figure>\n<p>This is the holy grail of deployments as it completely removes the human factor out of the equation and is a step towards Continuous Deployment (instead of Continuous Delivery). With this approach:<\/p>\n<ol>\n<li>You can perform deployments at any point in time knowing that metrics will be examined with the same attention even if the time is 3 am<\/li>\n<li>You can catch early regressions with pinpoint accuracy<\/li>\n<li>Rollbacks (usually a stressful action) are now handled by the deployment platform giving easier access to the deployment process by non-technical people<\/li>\n<\/ol>\n<p>The result is that a developer can deploy at 5 pm on Friday and immediately go home. Either the change will be approved (and it will be still there on Monday) or it will be rolled back automatically without any ill effects (and without any downtime if you also follow best practice 20 for progressive delivery)<\/p>\n<h2>Best Practice 23 &#8211; Staging Matches Production<\/h2>\n<p>We explained in best practice 12 that you should employ dynamic environments for testing individual features for developers. This gives you the confidence that each feature is correct on its own before you deploy it in production.<br \/>\nIt is also customary to have a single staging environment (a.k.a. pre-production) that acts as the last gateway before production. This particular environment should be as close to production as possible so that any configuration errors can and mismatches can be quickly discovered before pushing the application deployment to the real production environment.<\/p>\n<p>Unfortunately, most organizations treat the staging environment in a different way than the production one. Having a staging environment that is separate from production is a cumbersome practice as it means that you have to manually maintain it and make sure that it also gets any updates that reach production (not only in application terms but also any configuration changes).<\/p>\n<p>Two more effective ways of using a staging environment are the following:<\/p>\n<ol>\n<li>Create a staging environment on-demand each time you deploy by cloning the production environment<\/li>\n<li>Use as staging a special part of production (sometimes called shadow production)<\/li>\n<\/ol>\n<p>The first approach is great for small\/medium applications and involves cloning the production environment right before a deployment happens in a similar (but possibly smaller) configuration. This means that you can also get a subset of the database and a lower number of replicas\/instances that serve traffic. The important point here is that this staging environment only exists during a release. You create it just before a release and destroy it once a release has been marked as \u201csuccessful\u201d.<\/p>\n<p>The main benefit of course is that cloning your production right before deployment guarantees that you have the same configuration between staging and production. Also, there is nothing to maintain or keep up-to-date because you always discard the staging environment once the deployment has finished.<\/p>\n<p>This approach however is not realistic for large applications with many microservices or large external resources (e.g., databases and message queues). In those cases, it is much easier to use staging as a part of the production. The important point here is that the segment of production that you use does NOT get any user traffic, so in case of a failed deployment, your users will not be affected. The advantage again is that since this is part of the production you have the same guarantee that the configuration is the most recent one and what you are testing will behave in the same way as \u201creal\u201d production.<\/p>\n<h2>Applying these Best Practices to Your Organization<\/h2>\n<p>We hope that now you have some ideas on how to improve your CI\/CD process. Remember however that it is better to take gradual steps and not try to change everything at once.<\/p>\n<p>Consult the first section of this guide where we talked about priorities. Focus first on the best practices that are marked as \u201ccritical\u201d and as soon as you have conquered them move to those with \u201chigh\u201d importance.<\/p>\n<p>We believe that if you adopt the majority of practices that we have described in this guide, your development teams will be able to focus on shipping features instead of dealing with failed deployments and missing configuration issues.<\/p>\n<p>Cover photo by <a href=\"https:\/\/unsplash.com\/photos\/jHZ70nRk7Ns\">Unsplash<\/a>.<\/p>\n<input class=\"fooboxshare_post_id\" type=\"hidden\" value=\"19373\"\/>","protected":false},"excerpt":{"rendered":"<p>This is the third and last part in our &#8220;Enterprise CI\/CD best practices&#8221; series. See also part 1 and part 2 for the previous best practices. You can also download all 3 parts in a PDF ebook. Best Practice 16 &#8211; Database Updates have their own Lifecycle As more and more companies adopt continuous delivery &hellip; <a href=\"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-3\/\">Read more<\/a><\/p>\n","protected":false},"author":62,"featured_media":19374,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[3120,5467,1543],"tags":[15,52,53,68,3174],"yoast_head":"<!-- This site is optimized with the Yoast SEO Premium plugin v17.9 (Yoast SEO v18.4.1) - https:\/\/yoast.com\/wordpress\/plugins\/seo\/ -->\n<title>Enterprise CI\/CD Best Practices - Part 3 | Codefresh<\/title>\n<meta name=\"robots\" content=\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\" \/>\n<link rel=\"canonical\" href=\"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-3\/\" \/>\n<meta property=\"og:locale\" content=\"en_US\" \/>\n<meta property=\"og:type\" content=\"article\" \/>\n<meta property=\"og:title\" content=\"Enterprise CI\/CD Best Practices - Part 3\" \/>\n<meta property=\"og:description\" content=\"This is the third and last part in our &#8220;Enterprise CI\/CD best practices&#8221; series. See also part 1 and part 2 for the previous best practices. You can also download all 3 parts in a PDF ebook. Best Practice 16 &#8211; Database Updates have their own Lifecycle As more and more companies adopt continuous delivery &hellip; Read more\" \/>\n<meta property=\"og:url\" content=\"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-3\/\" \/>\n<meta property=\"og:site_name\" content=\"Codefresh\" \/>\n<meta property=\"article:publisher\" content=\"https:\/\/www.facebook.com\/codefresh.io\" \/>\n<meta property=\"article:published_time\" content=\"2021-06-11T13:05:26+00:00\" \/>\n<meta property=\"article:modified_time\" content=\"2021-12-14T11:47:55+00:00\" \/>\n<meta property=\"og:image\" content=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/blog-picture.jpg\" \/>\n\t<meta property=\"og:image:width\" content=\"1024\" \/>\n\t<meta property=\"og:image:height\" content=\"340\" \/>\n\t<meta property=\"og:image:type\" content=\"image\/jpeg\" \/>\n<meta name=\"twitter:card\" content=\"summary_large_image\" \/>\n<meta name=\"twitter:creator\" content=\"@codefresh\" \/>\n<meta name=\"twitter:site\" content=\"@codefresh\" \/>\n<meta name=\"twitter:label1\" content=\"Written by\" \/>\n\t<meta name=\"twitter:data1\" content=\"Kostis Kapelonis\" \/>\n\t<meta name=\"twitter:label2\" content=\"Est. reading time\" \/>\n\t<meta name=\"twitter:data2\" content=\"12 minutes\" \/>\n<script type=\"application\/ld+json\" class=\"yoast-schema-graph\">{\"@context\":\"https:\/\/schema.org\",\"@graph\":[{\"@type\":\"Organization\",\"@id\":\"https:\/\/codefresh.io\/#organization\",\"name\":\"Codefresh\",\"url\":\"https:\/\/codefresh.io\/\",\"sameAs\":[\"https:\/\/www.facebook.com\/codefresh.io\",\"https:\/\/www.linkedin.com\/company\/codefresh\",\"https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg\",\"https:\/\/twitter.com\/codefresh\"],\"logo\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#logo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"width\":800,\"height\":800,\"caption\":\"Codefresh\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/#logo\"}},{\"@type\":\"WebSite\",\"@id\":\"https:\/\/codefresh.io\/#website\",\"url\":\"https:\/\/codefresh.io\/\",\"name\":\"Codefresh\",\"description\":\"\",\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"potentialAction\":[{\"@type\":\"SearchAction\",\"target\":{\"@type\":\"EntryPoint\",\"urlTemplate\":\"https:\/\/codefresh.io\/?s={search_term_string}\"},\"query-input\":\"required name=search_term_string\"}],\"inLanguage\":\"en-US\"},{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-3\/#primaryimage\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/blog-picture.jpg\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/blog-picture.jpg\",\"width\":1024,\"height\":340},{\"@type\":\"WebPage\",\"@id\":\"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-3\/#webpage\",\"url\":\"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-3\/\",\"name\":\"Enterprise CI\/CD Best Practices - Part 3 | Codefresh\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/#website\"},\"primaryImageOfPage\":{\"@id\":\"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-3\/#primaryimage\"},\"datePublished\":\"2021-06-11T13:05:26+00:00\",\"dateModified\":\"2021-12-14T11:47:55+00:00\",\"breadcrumb\":{\"@id\":\"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-3\/#breadcrumb\"},\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"ReadAction\",\"target\":[\"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-3\/\"]}]},{\"@type\":\"BreadcrumbList\",\"@id\":\"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-3\/#breadcrumb\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"name\":\"Home\",\"item\":\"https:\/\/codefresh.io\/\"},{\"@type\":\"ListItem\",\"position\":2,\"name\":\"Enterprise CI\/CD Best Practices &#8211; Part 3\"}]},{\"@type\":\"Article\",\"@id\":\"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-3\/#article\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-3\/#webpage\"},\"author\":{\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87\"},\"headline\":\"Enterprise CI\/CD Best Practices &#8211; Part 3\",\"datePublished\":\"2021-06-11T13:05:26+00:00\",\"dateModified\":\"2021-12-14T11:47:55+00:00\",\"mainEntityOfPage\":{\"@id\":\"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-3\/#webpage\"},\"wordCount\":2476,\"commentCount\":0,\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-3\/#primaryimage\"},\"thumbnailUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/blog-picture.jpg\",\"keywords\":[\"continuous integration\",\"devops\",\"CI\/CD\",\"continuous delivery\",\"enterprise\"],\"articleSection\":[\"Continuous Deployment\/Delivery\",\"Devops\",\"Continuous Integration\"],\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"CommentAction\",\"name\":\"Comment\",\"target\":[\"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-3\/#respond\"]}]},{\"@type\":\"Person\",\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87\",\"name\":\"Kostis Kapelonis\",\"image\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#personlogo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png\",\"caption\":\"Kostis Kapelonis\"},\"description\":\"Kostis is a software engineer\/technical-writer dual class character. He lives and breathes automation, good testing practices and stress-free deployments with GitOps.\",\"url\":\"https:\/\/codefresh.io\/author\/kostiscodefresh-io\/\"}]}<\/script>\n<!-- \/ Yoast SEO Premium plugin. -->","yoast_head_json":{"title":"Enterprise CI\/CD Best Practices - Part 3 | Codefresh","robots":{"index":"index","follow":"follow","max-snippet":"max-snippet:-1","max-image-preview":"max-image-preview:large","max-video-preview":"max-video-preview:-1"},"canonical":"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-3\/","og_locale":"en_US","og_type":"article","og_title":"Enterprise CI\/CD Best Practices - Part 3","og_description":"This is the third and last part in our &#8220;Enterprise CI\/CD best practices&#8221; series. See also part 1 and part 2 for the previous best practices. You can also download all 3 parts in a PDF ebook. Best Practice 16 &#8211; Database Updates have their own Lifecycle As more and more companies adopt continuous delivery &hellip; Read more","og_url":"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-3\/","og_site_name":"Codefresh","article_publisher":"https:\/\/www.facebook.com\/codefresh.io","article_published_time":"2021-06-11T13:05:26+00:00","article_modified_time":"2021-12-14T11:47:55+00:00","og_image":[{"width":1024,"height":340,"url":"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/blog-picture.jpg","type":"image\/jpeg"}],"twitter_card":"summary_large_image","twitter_creator":"@codefresh","twitter_site":"@codefresh","twitter_misc":{"Written by":"Kostis Kapelonis","Est. reading time":"12 minutes"},"schema":{"@context":"https:\/\/schema.org","@graph":[{"@type":"Organization","@id":"https:\/\/codefresh.io\/#organization","name":"Codefresh","url":"https:\/\/codefresh.io\/","sameAs":["https:\/\/www.facebook.com\/codefresh.io","https:\/\/www.linkedin.com\/company\/codefresh","https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg","https:\/\/twitter.com\/codefresh"],"logo":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#logo","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","width":800,"height":800,"caption":"Codefresh"},"image":{"@id":"https:\/\/codefresh.io\/#logo"}},{"@type":"WebSite","@id":"https:\/\/codefresh.io\/#website","url":"https:\/\/codefresh.io\/","name":"Codefresh","description":"","publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"potentialAction":[{"@type":"SearchAction","target":{"@type":"EntryPoint","urlTemplate":"https:\/\/codefresh.io\/?s={search_term_string}"},"query-input":"required name=search_term_string"}],"inLanguage":"en-US"},{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-3\/#primaryimage","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/blog-picture.jpg","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/blog-picture.jpg","width":1024,"height":340},{"@type":"WebPage","@id":"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-3\/#webpage","url":"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-3\/","name":"Enterprise CI\/CD Best Practices - Part 3 | Codefresh","isPartOf":{"@id":"https:\/\/codefresh.io\/#website"},"primaryImageOfPage":{"@id":"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-3\/#primaryimage"},"datePublished":"2021-06-11T13:05:26+00:00","dateModified":"2021-12-14T11:47:55+00:00","breadcrumb":{"@id":"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-3\/#breadcrumb"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-3\/"]}]},{"@type":"BreadcrumbList","@id":"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-3\/#breadcrumb","itemListElement":[{"@type":"ListItem","position":1,"name":"Home","item":"https:\/\/codefresh.io\/"},{"@type":"ListItem","position":2,"name":"Enterprise CI\/CD Best Practices &#8211; Part 3"}]},{"@type":"Article","@id":"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-3\/#article","isPartOf":{"@id":"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-3\/#webpage"},"author":{"@id":"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87"},"headline":"Enterprise CI\/CD Best Practices &#8211; Part 3","datePublished":"2021-06-11T13:05:26+00:00","dateModified":"2021-12-14T11:47:55+00:00","mainEntityOfPage":{"@id":"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-3\/#webpage"},"wordCount":2476,"commentCount":0,"publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"image":{"@id":"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-3\/#primaryimage"},"thumbnailUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/blog-picture.jpg","keywords":["continuous integration","devops","CI\/CD","continuous delivery","enterprise"],"articleSection":["Continuous Deployment\/Delivery","Devops","Continuous Integration"],"inLanguage":"en-US","potentialAction":[{"@type":"CommentAction","name":"Comment","target":["https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-3\/#respond"]}]},{"@type":"Person","@id":"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87","name":"Kostis Kapelonis","image":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#personlogo","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png","caption":"Kostis Kapelonis"},"description":"Kostis is a software engineer\/technical-writer dual class character. He lives and breathes automation, good testing practices and stress-free deployments with GitOps.","url":"https:\/\/codefresh.io\/author\/kostiscodefresh-io\/"}]}},"acf":[],"_links":{"self":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/19373"}],"collection":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/users\/62"}],"replies":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/comments?post=19373"}],"version-history":[{"count":2,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/19373\/revisions"}],"predecessor-version":[{"id":20768,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/19373\/revisions\/20768"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media\/19374"}],"wp:attachment":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media?parent=19373"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/categories?post=19373"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/tags?post=19373"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}