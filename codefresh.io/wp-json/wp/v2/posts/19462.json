{"id":19462,"date":"2021-06-11T04:43:01","date_gmt":"2021-06-11T12:43:01","guid":{"rendered":"https:\/\/codefresh.io\/?p=19462"},"modified":"2021-06-11T05:07:04","modified_gmt":"2021-06-11T13:07:04","slug":"enterprise-ci-cd-best-practices-part-2","status":"publish","type":"post","link":"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-2\/","title":{"rendered":"Enterprise CI\/CD Best Practices &#8211; Part 2"},"content":{"rendered":"<p>This is the second part in our &#8220;Enterprise CI\/CD best practices&#8221; series. See also <a href=\"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-1\/\">part 1<\/a> for for the previous part and <a href=\"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-3\/\">part 3<\/a> for the next part. You can also download <a href=\"https:\/\/codefresh.io\/ebooks\/enterprise-ci-cd-best-practices\/\">all 3 parts in a PDF ebook<\/a>.<\/p>\n<h2>Best Practice 8 &#8211; Automate All your Tests<\/h2>\n<p>The main goal of unit\/integration\/functional tests is to increase the confidence in each new release that gets deployed. In theory, a comprehensive amount of tests will guarantee that there are no regressions on each new feature that gets published.<\/p>\n<p>To achieve this goal, tests should be fully automated and managed by the CI\/CD platform. Tests should be run not only before each deployment but also after a pull request is created. The only way to achieve the level of automation is for the test suite to be runnable in a single step.<\/p>\n<figure id=\"attachment_19407\" aria-describedby=\"caption-attachment-19407\" style=\"width: 1738px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/automated-tests.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/automated-tests.png\" alt=\"Automated tests\" width=\"1738\" height=\"1362\" class=\"size-full wp-image-19407\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/automated-tests.png 1738w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/automated-tests-300x235.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/automated-tests-1024x802.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/automated-tests-768x602.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/automated-tests-1536x1204.png 1536w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/automated-tests-20x16.png 20w\" sizes=\"(max-width: 1738px) 100vw, 1738px\" \/><\/a><figcaption id=\"caption-attachment-19407\" class=\"wp-caption-text\">Automated tests<\/figcaption><\/figure>\n<p>Unfortunately, several companies are still creating tests the old-fashioned way, where an army of test engineers is tasked with the manual execution of various test suites. This blocks all new releases as the testing velocity essentially becomes the deployment velocity.<\/p>\n<p>Test engineers should only write new tests. They should never execute tests themselves as this makes the feedback loop of new features vastly longer. Tests are always executed automatically by the CI\/CD platform in various workflows and pipelines.<\/p>\n<p>It is ok if a small number of tests are manually run by people as a way to smoke test a release. But this should only happen for a handful of tests. All other main test suites should be fully automated.<\/p>\n<h2>Best Practice 9 &#8211; Make Your Tests Fast<\/h2>\n<p>A corollary of the previous section is also the quick execution of tests. If test suites are to be integrated into delivery pipelines, they should be really fast. Ideally, the test time should not be bigger than the packaging\/compilation time, which means that tests should finish after five minutes, and no more than 15.<\/p>\n<p>The quick test execution gives confidence to developers that the feature they just committed has no regressions and can be safely promoted to the next workflow stage. A running time of two hours is disastrous for developers as they cannot possibly wait for that amount of time after committing a feature.<\/p>\n<figure id=\"attachment_19408\" aria-describedby=\"caption-attachment-19408\" style=\"width: 1660px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/fast-tests.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/fast-tests.png\" alt=\"Fast tests\" width=\"1660\" height=\"672\" class=\"size-full wp-image-19408\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/fast-tests.png 1660w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/fast-tests-300x121.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/fast-tests-1024x415.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/fast-tests-768x311.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/fast-tests-1536x622.png 1536w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/fast-tests-20x8.png 20w\" sizes=\"(max-width: 1660px) 100vw, 1660px\" \/><\/a><figcaption id=\"caption-attachment-19408\" class=\"wp-caption-text\">Fast tests<\/figcaption><\/figure>\n<p>If the testing period is that large, developers just move to their next task and change their mind context. Once the test results do arrive, it is much more difficult to fix issues on a feature that you are not actively working on.<\/p>\n<figure id=\"attachment_19409\" aria-describedby=\"caption-attachment-19409\" style=\"width: 1660px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/slow-tests.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/slow-tests.png\" alt=\"Slow tests\" width=\"1660\" height=\"672\" class=\"size-full wp-image-19409\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/slow-tests.png 1660w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/slow-tests-300x121.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/slow-tests-1024x415.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/slow-tests-768x311.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/slow-tests-1536x622.png 1536w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/slow-tests-20x8.png 20w\" sizes=\"(max-width: 1660px) 100vw, 1660px\" \/><\/a><figcaption id=\"caption-attachment-19409\" class=\"wp-caption-text\">Slow tests<\/figcaption><\/figure>\n<p>Unfortunately, the majority of time waiting for tests steps from ineffective test practices and lack of optimizations. The usual factor of a slow test is code that \u201csleeps\u201d or \u201cwaits\u201d for an event to happen, making the test run longer than it should run. All these sleep statements should be removed and the test should follow an event-driven architecture (i.e., responding to events instead of waiting for things to happen)<\/p>\n<p>Test data creation is also another area where tests are spending most of their data. Test data creation code should be centralized and re-used. If a test has a long setup phase, maybe it is testing too many things or needs some mocking in unrelated services.<\/p>\n<p>In summary, test suites should be fast (5-10 minutes) and huge tests that need hours should be refactored and redesigned.<\/p>\n<h2>Best Practice 10 &#8211; Each test auto-cleans its side effects<\/h2>\n<p>Generally speaking, you can split your unit tests is two more categories (apart from unit\/integration or slow and fast) and this has to do with their side effects:<\/p>\n<ol>\n<li>Tests that have no side effects. They read only information from external sources, never modify anything and can be run as many times as you want (or even in parallel) without any complications.<\/li>\n<li>Tests that have side effects. These are the tests that write stuff to your database, commit data to external systems, perform output operations on your dependencies, and so on.<\/li>\n<\/ol>\n<p>The first category (read-only tests) is easy to handle since they need no special maintenance. But the second category (read\/write tests) is more complex to maintain as you need to make sure that you clean up their actions as soon as the tests finish. There are two approaches to this:<\/p>\n<ol>\n<li>Let all the tests run and then clean up the actions of all of them at the end of the test suit<\/li>\n<li>Have each test clean-up by itself after it runs (the recommended approach)<\/li>\n<\/ol>\n<figure id=\"attachment_19411\" aria-describedby=\"caption-attachment-19411\" style=\"width: 1708px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/cleanup-all-tests.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/cleanup-all-tests.png\" alt=\"Cleanup all tests\" width=\"1708\" height=\"616\" class=\"size-full wp-image-19411\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/cleanup-all-tests.png 1708w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/cleanup-all-tests-300x108.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/cleanup-all-tests-1024x369.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/cleanup-all-tests-768x277.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/cleanup-all-tests-1536x554.png 1536w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/cleanup-all-tests-20x7.png 20w\" sizes=\"(max-width: 1708px) 100vw, 1708px\" \/><\/a><figcaption id=\"caption-attachment-19411\" class=\"wp-caption-text\">Cleanup all tests<\/figcaption><\/figure>\n<p>Having each test clean up its side-effects is a better approach because it means that you can run all your tests in parallel or any times that you wish individually (i.e., run a single test from your suite and then run it again a second or third time).<\/p>\n<figure id=\"attachment_19412\" aria-describedby=\"caption-attachment-19412\" style=\"width: 1764px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/cleanup-every-tests.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/cleanup-every-tests.png\" alt=\"Cleanup every test\" width=\"1764\" height=\"864\" class=\"size-full wp-image-19412\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/cleanup-every-tests.png 1764w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/cleanup-every-tests-300x147.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/cleanup-every-tests-1024x502.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/cleanup-every-tests-768x376.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/cleanup-every-tests-1536x752.png 1536w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/cleanup-every-tests-20x10.png 20w\" sizes=\"(max-width: 1764px) 100vw, 1764px\" \/><\/a><figcaption id=\"caption-attachment-19412\" class=\"wp-caption-text\">Cleanup every test<\/figcaption><\/figure>\n<p>Being able to execute tests in parallel is a prerequisite for using dynamic test environments as we will see later in this guide.<\/p>\n<h2>Best Practice 11 &#8211; Use Multiple Test Suites<\/h2>\n<p>Testing is not something that happens only in a single step inside a CI\/CD pipeline. Testing is a continuous process that touches all phases of a pipeline.<\/p>\n<p>This means that multiple test types should exist in any well-designed application. Some of the most common examples are:<\/p>\n<ul>\n<li>Really quick unit tests that look at major regressions and finish very fast<\/li>\n<li>Longer integrations tests that look for more complex scenarios (such as transactions or security)<\/li>\n<li>Stress and load testing<\/li>\n<li>Contract testing for API changes of external services used<\/li>\n<li>Smoke tests that can be run on production to verify a release<\/li>\n<li>UI tests that test the user experience<\/li>\n<\/ul>\n<p>This is just a sample of different test types. Each company might have several more categories. The idea behind these categories is that developers and operators can pick and choose different testing types for the specific pipeline they create.<\/p>\n<figure id=\"attachment_19413\" aria-describedby=\"caption-attachment-19413\" style=\"width: 1745px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/many-test-suites.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/many-test-suites.png\" alt=\"Many test suites\" width=\"1745\" height=\"569\" class=\"size-full wp-image-19413\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/many-test-suites.png 1745w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/many-test-suites-300x98.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/many-test-suites-1024x334.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/many-test-suites-768x250.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/many-test-suites-1536x501.png 1536w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/many-test-suites-20x7.png 20w\" sizes=\"(max-width: 1745px) 100vw, 1745px\" \/><\/a><figcaption id=\"caption-attachment-19413\" class=\"wp-caption-text\">Many test suites<\/figcaption><\/figure>\n<p>As an example, a pipeline for pull requests might not include stress and load testing phases because they are only needed before a production release. Creating a pull request will only run the fast unit tests and maybe the contact testing suite.<\/p>\n<p>Then after the Pull Request is approved, the rest of the tests (such as smoke tests in production) will run to verify the expected behavior.<\/p>\n<p>Some test suits might be very slow, that running them on demand for every Pull Request is too difficult. Running stress and load testing is usually something that happens right before a release (perhaps grouping multiple pull requests) or in a scheduled manner (a.k.a. Nightly builds)<br \/>\nThe exact workflow is not important as each organization has different processes. What is important is the capability to isolate each testing suite and be able to select one or more for each phase in the software lifecycle.<\/p>\n<figure id=\"attachment_19414\" aria-describedby=\"caption-attachment-19414\" style=\"width: 1730px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/single-test-suit.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/single-test-suit.png\" alt=\"Single Test suite\" width=\"1730\" height=\"535\" class=\"size-full wp-image-19414\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/single-test-suit.png 1730w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/single-test-suit-300x93.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/single-test-suit-1024x317.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/single-test-suit-768x238.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/single-test-suit-1536x475.png 1536w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/single-test-suit-20x6.png 20w\" sizes=\"(max-width: 1730px) 100vw, 1730px\" \/><\/a><figcaption id=\"caption-attachment-19414\" class=\"wp-caption-text\">Single Test suite<\/figcaption><\/figure>\n<p>Having a single test suite for everything is cumbersome and will force developers to skip tests locally. Ideally, as a developer, I should be able to select any possible number of test suites to run against my feature branch allowing me to be flexible on how I test my feature.<\/p>\n<h2>Best Practice 12 &#8211; Create Test Environments On-demand<\/h2>\n<p>The traditional way of testing an application right before going into production is with a staging environment. Having only one staging environment is a big disadvantage because it means that developers must either test all their features at once or they have to enter a queue and \u201cbook\u201d the staging environment only for their feature.<\/p>\n<figure id=\"attachment_19416\" aria-describedby=\"caption-attachment-19416\" style=\"width: 1554px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/Flows-10.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/Flows-10.png\" alt=\"Static environments\" width=\"1554\" height=\"605\" class=\"size-full wp-image-19416\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/Flows-10.png 1554w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/Flows-10-300x117.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/Flows-10-1024x399.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/Flows-10-768x299.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/Flows-10-1536x598.png 1536w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/Flows-10-20x8.png 20w\" sizes=\"(max-width: 1554px) 100vw, 1554px\" \/><\/a><figcaption id=\"caption-attachment-19416\" class=\"wp-caption-text\">Static environments<\/figcaption><\/figure>\n<p>This forces a lot of organizations to create a fleet of test environments (e.g., QA1, QA2, QA3) so that multiple developers can test their features in parallel. This technique is still not ideal because:<\/p>\n<ul>\n<li>A maximum of N developers can test their feature (same as the number of environments) in parallel.<\/li>\n<li>\nTesting environments use resources all the time (even when they are not used)<\/li>\n<li>The static character of environments means that they have to be cleaned up and updated as well. This adds extra maintenance effort to the team responsible for test environments<\/li>\n<\/ul>\n<p>With a cloud-based architecture, it is now much easier to create test environments on-demand. Instead of having a predefined number of static environments, you should modify your pipeline workflow so that each time a Pull Request is created by a developer, then a dedicated test environment is also created with the contents of that particular Pull Request.<\/p>\n<figure id=\"attachment_19417\" aria-describedby=\"caption-attachment-19417\" style=\"width: 1788px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/Flows-06.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/Flows-06.png\" alt=\"Preview environments\" width=\"1788\" height=\"958\" class=\"size-full wp-image-19417\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/Flows-06.png 1788w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/Flows-06-300x161.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/Flows-06-1024x549.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/Flows-06-768x411.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/Flows-06-1536x823.png 1536w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/Flows-06-20x11.png 20w\" sizes=\"(max-width: 1788px) 100vw, 1788px\" \/><\/a><figcaption id=\"caption-attachment-19417\" class=\"wp-caption-text\">Preview environments<\/figcaption><\/figure>\n<p>The advantages of dynamic test environments cannot be overstated:<\/p>\n<ol>\n<li>Each developer can test in isolation without any conflicts with what other developers are doing<\/li>\n<li>You pay for the resources of test environments only while you use them<\/li>\n<li>Since the test environments are discarded at the end there is nothing to maintain or clean up<\/li>\n<\/ol>\n<p>Dynamic test environments can shine for teams that have an irregular development schedule (e.g., having too many features in flight at the end of a sprint)<\/p>\n<h2>Best Practice 13 &#8211; Run Test Suites Concurrently<\/h2>\n<p>This is a corollary of the previous best practice. If your development process has dynamic test environments, it means that different test suites can run at any point in time for any number of those environments even at the same time.<\/p>\n<p>If your tests have special dependencies (e.g., they must be launched in a specific order, or they expect specific data before they can function) then having a dynamic number of test environments will further exacerbate the pre-run and post-run functions that you have for your tests.<\/p>\n<figure id=\"attachment_19418\" aria-describedby=\"caption-attachment-19418\" style=\"width: 1484px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/test-clashes.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/test-clashes.png\" alt=\"Test clashes\" width=\"1484\" height=\"558\" class=\"size-full wp-image-19418\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/test-clashes.png 1484w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/test-clashes-300x113.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/test-clashes-1024x385.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/test-clashes-768x289.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/test-clashes-20x8.png 20w\" sizes=\"(max-width: 1484px) 100vw, 1484px\" \/><\/a><figcaption id=\"caption-attachment-19418\" class=\"wp-caption-text\">Test clashes<\/figcaption><\/figure>\n<p>The solution is to embrace best practice 10 and have each test prepare its state and clean up after itself. Tests that are read-only (i.e., don\u2019t have any side-effects) can run in parallel by definitions.<\/p>\n<p>Tests that write\/read information need to be self-sufficient. For example, if a test writes an entity in a database and then reads it back, you should not use a hardcoded primary key because that would mean that if two test suites with this test run at the same time, the second one will fail because of database constraints.<\/p>\n<p>While most developers think that test parallelism is only a way to speed up your tests, in practice it is also a way to have correct tests without any uncontrolled side effects.<\/p>\n<h2>Best Practice 14 &#8211; Security Scanning is part of the process<\/h2>\n<p>A lot of organizations still follow the traditional waterfall model of software development. And in most cases, the security analysis comes at the end. The software is produced and then a security scan (or even penetration test) is performed on the source code. The results are published and developers scramble to fix all the issues.<\/p>\n<p>Putting security scanning at the end of a release is a lost cause. Some major architectural decisions affect how vulnerabilities are detected and knowing them in advance is a must not only for developers but also all project stakeholders.<\/p>\n<p>Security is an ongoing process. An application should be checked for vulnerabilities at the same time as it is developed. This means that security scanning should be part of the pre-merge process (i.e as one of the checks of a Pull Request). Solving security issues in a finished software package is much harder than while it is in development.<\/p>\n<p>Security scans should also have the appropriate depth. You need to check at the very least:<\/p>\n<ol>\n<li>Your application source code<\/li>\n<li>The container or underlying runtime where the application is running on<\/li>\n<li>The computing node and the Operating System that will host the application<\/li>\n<\/ol>\n<p>A lot of companies focus only on two (or even one) of these areas and forget the security works exactly like a chain (the weakest link is responsible for the overall security)<\/p>\n<p>If you also want to be proactive with security, it is best to enforce it on the Pull Request level. Instead of simply scanning your source code and then reporting its vulnerabilities, it is better to prevent merges from happening in the first place if a certain security threshold is not passed.<\/p>\n<h2>Best Practice 15 &#8211; Quality Scanning\/Code reviews are part of the process<\/h2>\n<p>Similar to security scans, code scans should be part of the day-to-day developer operations. This includes:<\/p>\n<ol>\n<li>Static analysis of code for company-approved style\/formatting<\/li>\n<li>Static analysis of code for security problems, hidden bugs<\/li>\n<li>Runtime analysis of code for errors and other issues<\/li>\n<\/ol>\n<p>While there are existing tools that handle the analysis part, not all organizations execute those tools in an automated way. A very common pattern we see is enthusiastic software teams vowing to use these tools (e.g., Sonarqube) for the next software project, only to forget about them after some time or completely ignoring the warning and errors presented in the analysis reports.<\/p>\n<p>In the same manner as security scans, code quality scanning should be part of the Pull Request process. Instead of simply reporting the final results to developers, you should enforce good quality practices by preventing merges if a certain amount of warning is present.<\/p>\n<p>Continued <a href=\"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-3\/\">on part3<\/a>. You can download <a href=\"https:\/\/codefresh.io\/ebooks\/enterprise-ci-cd-best-practices\/\">all 3 parts in a single PDF as an ebook<\/a>.<\/p>\n<p>Cover photo by <a href=\"https:\/\/unsplash.com\/photos\/jHZ70nRk7Ns\">Unsplash<\/a>.<\/p>\n<input class=\"fooboxshare_post_id\" type=\"hidden\" value=\"19462\"\/>","protected":false},"excerpt":{"rendered":"<p>This is the second part in our &#8220;Enterprise CI\/CD best practices&#8221; series. See also part 1 for for the previous part and part 3 for the next part. You can also download all 3 parts in a PDF ebook. Best Practice 8 &#8211; Automate All your Tests The main goal of unit\/integration\/functional tests is to &hellip; <a href=\"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-2\/\">Read more<\/a><\/p>\n","protected":false},"author":62,"featured_media":19485,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[3120,5467,1543],"tags":[15,52,53,68,3174],"yoast_head":"<!-- This site is optimized with the Yoast SEO Premium plugin v17.9 (Yoast SEO v18.4.1) - https:\/\/yoast.com\/wordpress\/plugins\/seo\/ -->\n<title>Enterprise CI\/CD Best Practices - Part 2 | Codefresh<\/title>\n<meta name=\"robots\" content=\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\" \/>\n<link rel=\"canonical\" href=\"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-2\/\" \/>\n<meta property=\"og:locale\" content=\"en_US\" \/>\n<meta property=\"og:type\" content=\"article\" \/>\n<meta property=\"og:title\" content=\"Enterprise CI\/CD Best Practices - Part 2\" \/>\n<meta property=\"og:description\" content=\"This is the second part in our &#8220;Enterprise CI\/CD best practices&#8221; series. See also part 1 for for the previous part and part 3 for the next part. You can also download all 3 parts in a PDF ebook. Best Practice 8 &#8211; Automate All your Tests The main goal of unit\/integration\/functional tests is to &hellip; Read more\" \/>\n<meta property=\"og:url\" content=\"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-2\/\" \/>\n<meta property=\"og:site_name\" content=\"Codefresh\" \/>\n<meta property=\"article:publisher\" content=\"https:\/\/www.facebook.com\/codefresh.io\" \/>\n<meta property=\"article:published_time\" content=\"2021-06-11T12:43:01+00:00\" \/>\n<meta property=\"article:modified_time\" content=\"2021-06-11T13:07:04+00:00\" \/>\n<meta property=\"og:image\" content=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/blog-picture-4.jpg\" \/>\n\t<meta property=\"og:image:width\" content=\"1024\" \/>\n\t<meta property=\"og:image:height\" content=\"340\" \/>\n\t<meta property=\"og:image:type\" content=\"image\/jpeg\" \/>\n<meta name=\"twitter:card\" content=\"summary_large_image\" \/>\n<meta name=\"twitter:creator\" content=\"@codefresh\" \/>\n<meta name=\"twitter:site\" content=\"@codefresh\" \/>\n<meta name=\"twitter:label1\" content=\"Written by\" \/>\n\t<meta name=\"twitter:data1\" content=\"Kostis Kapelonis\" \/>\n\t<meta name=\"twitter:label2\" content=\"Est. reading time\" \/>\n\t<meta name=\"twitter:data2\" content=\"11 minutes\" \/>\n<script type=\"application\/ld+json\" class=\"yoast-schema-graph\">{\"@context\":\"https:\/\/schema.org\",\"@graph\":[{\"@type\":\"Organization\",\"@id\":\"https:\/\/codefresh.io\/#organization\",\"name\":\"Codefresh\",\"url\":\"https:\/\/codefresh.io\/\",\"sameAs\":[\"https:\/\/www.facebook.com\/codefresh.io\",\"https:\/\/www.linkedin.com\/company\/codefresh\",\"https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg\",\"https:\/\/twitter.com\/codefresh\"],\"logo\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#logo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"width\":800,\"height\":800,\"caption\":\"Codefresh\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/#logo\"}},{\"@type\":\"WebSite\",\"@id\":\"https:\/\/codefresh.io\/#website\",\"url\":\"https:\/\/codefresh.io\/\",\"name\":\"Codefresh\",\"description\":\"\",\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"potentialAction\":[{\"@type\":\"SearchAction\",\"target\":{\"@type\":\"EntryPoint\",\"urlTemplate\":\"https:\/\/codefresh.io\/?s={search_term_string}\"},\"query-input\":\"required name=search_term_string\"}],\"inLanguage\":\"en-US\"},{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-2\/#primaryimage\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/blog-picture-4.jpg\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/blog-picture-4.jpg\",\"width\":1024,\"height\":340},{\"@type\":\"WebPage\",\"@id\":\"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-2\/#webpage\",\"url\":\"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-2\/\",\"name\":\"Enterprise CI\/CD Best Practices - Part 2 | Codefresh\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/#website\"},\"primaryImageOfPage\":{\"@id\":\"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-2\/#primaryimage\"},\"datePublished\":\"2021-06-11T12:43:01+00:00\",\"dateModified\":\"2021-06-11T13:07:04+00:00\",\"breadcrumb\":{\"@id\":\"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-2\/#breadcrumb\"},\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"ReadAction\",\"target\":[\"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-2\/\"]}]},{\"@type\":\"BreadcrumbList\",\"@id\":\"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-2\/#breadcrumb\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"name\":\"Home\",\"item\":\"https:\/\/codefresh.io\/\"},{\"@type\":\"ListItem\",\"position\":2,\"name\":\"Enterprise CI\/CD Best Practices &#8211; Part 2\"}]},{\"@type\":\"Article\",\"@id\":\"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-2\/#article\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-2\/#webpage\"},\"author\":{\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87\"},\"headline\":\"Enterprise CI\/CD Best Practices &#8211; Part 2\",\"datePublished\":\"2021-06-11T12:43:01+00:00\",\"dateModified\":\"2021-06-11T13:07:04+00:00\",\"mainEntityOfPage\":{\"@id\":\"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-2\/#webpage\"},\"wordCount\":2251,\"commentCount\":0,\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-2\/#primaryimage\"},\"thumbnailUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/blog-picture-4.jpg\",\"keywords\":[\"continuous integration\",\"devops\",\"CI\/CD\",\"continuous delivery\",\"enterprise\"],\"articleSection\":[\"Continuous Deployment\/Delivery\",\"Devops\",\"Continuous Integration\"],\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"CommentAction\",\"name\":\"Comment\",\"target\":[\"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-2\/#respond\"]}]},{\"@type\":\"Person\",\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87\",\"name\":\"Kostis Kapelonis\",\"image\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#personlogo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png\",\"caption\":\"Kostis Kapelonis\"},\"description\":\"Kostis is a software engineer\/technical-writer dual class character. He lives and breathes automation, good testing practices and stress-free deployments with GitOps.\",\"url\":\"https:\/\/codefresh.io\/author\/kostiscodefresh-io\/\"}]}<\/script>\n<!-- \/ Yoast SEO Premium plugin. -->","yoast_head_json":{"title":"Enterprise CI\/CD Best Practices - Part 2 | Codefresh","robots":{"index":"index","follow":"follow","max-snippet":"max-snippet:-1","max-image-preview":"max-image-preview:large","max-video-preview":"max-video-preview:-1"},"canonical":"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-2\/","og_locale":"en_US","og_type":"article","og_title":"Enterprise CI\/CD Best Practices - Part 2","og_description":"This is the second part in our &#8220;Enterprise CI\/CD best practices&#8221; series. See also part 1 for for the previous part and part 3 for the next part. You can also download all 3 parts in a PDF ebook. Best Practice 8 &#8211; Automate All your Tests The main goal of unit\/integration\/functional tests is to &hellip; Read more","og_url":"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-2\/","og_site_name":"Codefresh","article_publisher":"https:\/\/www.facebook.com\/codefresh.io","article_published_time":"2021-06-11T12:43:01+00:00","article_modified_time":"2021-06-11T13:07:04+00:00","og_image":[{"width":1024,"height":340,"url":"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/blog-picture-4.jpg","type":"image\/jpeg"}],"twitter_card":"summary_large_image","twitter_creator":"@codefresh","twitter_site":"@codefresh","twitter_misc":{"Written by":"Kostis Kapelonis","Est. reading time":"11 minutes"},"schema":{"@context":"https:\/\/schema.org","@graph":[{"@type":"Organization","@id":"https:\/\/codefresh.io\/#organization","name":"Codefresh","url":"https:\/\/codefresh.io\/","sameAs":["https:\/\/www.facebook.com\/codefresh.io","https:\/\/www.linkedin.com\/company\/codefresh","https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg","https:\/\/twitter.com\/codefresh"],"logo":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#logo","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","width":800,"height":800,"caption":"Codefresh"},"image":{"@id":"https:\/\/codefresh.io\/#logo"}},{"@type":"WebSite","@id":"https:\/\/codefresh.io\/#website","url":"https:\/\/codefresh.io\/","name":"Codefresh","description":"","publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"potentialAction":[{"@type":"SearchAction","target":{"@type":"EntryPoint","urlTemplate":"https:\/\/codefresh.io\/?s={search_term_string}"},"query-input":"required name=search_term_string"}],"inLanguage":"en-US"},{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-2\/#primaryimage","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/blog-picture-4.jpg","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/blog-picture-4.jpg","width":1024,"height":340},{"@type":"WebPage","@id":"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-2\/#webpage","url":"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-2\/","name":"Enterprise CI\/CD Best Practices - Part 2 | Codefresh","isPartOf":{"@id":"https:\/\/codefresh.io\/#website"},"primaryImageOfPage":{"@id":"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-2\/#primaryimage"},"datePublished":"2021-06-11T12:43:01+00:00","dateModified":"2021-06-11T13:07:04+00:00","breadcrumb":{"@id":"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-2\/#breadcrumb"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-2\/"]}]},{"@type":"BreadcrumbList","@id":"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-2\/#breadcrumb","itemListElement":[{"@type":"ListItem","position":1,"name":"Home","item":"https:\/\/codefresh.io\/"},{"@type":"ListItem","position":2,"name":"Enterprise CI\/CD Best Practices &#8211; Part 2"}]},{"@type":"Article","@id":"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-2\/#article","isPartOf":{"@id":"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-2\/#webpage"},"author":{"@id":"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87"},"headline":"Enterprise CI\/CD Best Practices &#8211; Part 2","datePublished":"2021-06-11T12:43:01+00:00","dateModified":"2021-06-11T13:07:04+00:00","mainEntityOfPage":{"@id":"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-2\/#webpage"},"wordCount":2251,"commentCount":0,"publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"image":{"@id":"https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-2\/#primaryimage"},"thumbnailUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/06\/blog-picture-4.jpg","keywords":["continuous integration","devops","CI\/CD","continuous delivery","enterprise"],"articleSection":["Continuous Deployment\/Delivery","Devops","Continuous Integration"],"inLanguage":"en-US","potentialAction":[{"@type":"CommentAction","name":"Comment","target":["https:\/\/codefresh.io\/devops\/enterprise-ci-cd-best-practices-part-2\/#respond"]}]},{"@type":"Person","@id":"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87","name":"Kostis Kapelonis","image":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#personlogo","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png","caption":"Kostis Kapelonis"},"description":"Kostis is a software engineer\/technical-writer dual class character. He lives and breathes automation, good testing practices and stress-free deployments with GitOps.","url":"https:\/\/codefresh.io\/author\/kostiscodefresh-io\/"}]}},"acf":[],"_links":{"self":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/19462"}],"collection":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/users\/62"}],"replies":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/comments?post=19462"}],"version-history":[{"count":0,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/19462\/revisions"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media\/19485"}],"wp:attachment":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media?parent=19462"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/categories?post=19462"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/tags?post=19462"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}