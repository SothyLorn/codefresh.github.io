{"id":19803,"date":"2021-07-09T10:44:07","date_gmt":"2021-07-09T10:44:07","guid":{"rendered":"https:\/\/codefresh.io\/?p=19803"},"modified":"2021-07-09T10:44:07","modified_gmt":"2021-07-09T10:44:07","slug":"unlimited-preview-environments","status":"publish","type":"post","link":"https:\/\/codefresh.io\/kubernetes-tutorial\/unlimited-preview-environments\/","title":{"rendered":"Unlimited Preview Environments with Kubernetes Namespaces"},"content":{"rendered":"<p>In our <a href=\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-2\/\">big series of Kubernetes anti-patterns<\/a>, we briefly explained that static test environments are no longer needed if you are using Kubernetes. They are expensive, hard to maintain, and hard to clean up.<\/p>\n<figure id=\"attachment_19804\" aria-describedby=\"caption-attachment-19804\" style=\"width: 1554px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/static-envs.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/static-envs.png\" alt=\"Static environments\" width=\"1554\" height=\"605\" class=\"size-full wp-image-19804\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/static-envs.png 1554w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/static-envs-300x117.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/static-envs-1024x399.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/static-envs-768x299.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/static-envs-1536x598.png 1536w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/static-envs-20x8.png 20w\" sizes=\"(max-width: 1554px) 100vw, 1554px\" \/><\/a><figcaption id=\"caption-attachment-19804\" class=\"wp-caption-text\">Static environments<\/figcaption><\/figure>\n<p>Instead, we suggested the adoption of temporary environments that are created on demand when a pull request is opened.<\/p>\n<figure id=\"attachment_19805\" aria-describedby=\"caption-attachment-19805\" style=\"width: 1788px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/dynamic-envs.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/dynamic-envs.png\" alt=\"Dynamic environments\" width=\"1788\" height=\"958\" class=\"size-full wp-image-19805\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/dynamic-envs.png 1788w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/dynamic-envs-300x161.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/dynamic-envs-1024x549.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/dynamic-envs-768x411.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/dynamic-envs-1536x823.png 1536w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/dynamic-envs-20x11.png 20w\" sizes=\"(max-width: 1788px) 100vw, 1788px\" \/><\/a><figcaption id=\"caption-attachment-19805\" class=\"wp-caption-text\">Dynamic environments<\/figcaption><\/figure>\n<p>In this article, we will see the practical explanations on how to achieve unlimited temporary environments using Kubernetes namespaces.<\/p>\n<h2>Choosing a naming strategy<\/h2>\n<p>Since the preview environments will be created and destroyed in a dynamic manner, you need to select a strategy for their names. While several solutions exist for naming, the two most common variations are:<\/p>\n<ol>\n<li>Using the name of the branch as a context URL. This means <code>example.com\/feature1, example.com\/feature2, example.com\/feature3<\/code>, and so on<\/li>\n<li>Using the name of the branch as a host subdomain. This means <code>feature1.example.com, feature2.example.com, feature3.example.com<\/code><\/li>\n<\/ol>\n<p>The context-URL-based strategy is very easy to set up since it doesn\u2019t need any special DNS settings (or TLS certs\/wildcards). On the other hand, not all applications are designed to run with a different root context.<br \/>\nIf you are certain that your application will not have issues with the context URL, then that strategy is the easiest to start.<\/p>\n<p>The host-based naming strategy is much more robust, but it requires some configuration in your DNS provider to catch all subdomains and send them to the cluster that will hold all your preview namespaces.<\/p>\n<p>In both cases, we also use an underlying Kubernetes namespace with the same name as the branch. We take advantage of the fact that Git branches have unique names, making sure that there are no clashes between environment names or Kubernetes namespaces.<\/p>\n<p>It is also very common for teams to create branch names that represent specific issues (e.g. with JIRA). This makes it very easy to understand what developers are implementing for each feature environment.<\/p>\n<p>For example, if a developer starts working on \u201cissue 45 for billing\u201d, then:<\/p>\n<ol>\n<li>A Git branch is created with name issue-45-billing<\/li>\n<li>A temporary environment is deployed at Kubernetes namespace <code>issue-45-billing<\/code><\/li>\n<li>The environment is exposed at <code>example.com\/issue-45-billing<\/code> or at <code>issue-45-billing.example.com<\/code><\/li>\n<\/ol>\n<h2>Using a Kubernetes Ingress for traffic management<\/h2>\n<p>You can create a preview environment in a Kubernetes namespace using any of the available deployment mechanisms (e.g. Helm or Kustomize). In order to distinguish traffic between different pods, you also need to install a Kubernetes Ingress. An <a href=\"https:\/\/kubernetes.io\/docs\/concepts\/services-networking\/ingress\/\">Ingress <\/a>is a special Kubernetes resource responsible for routing requests inside the cluster.<\/p>\n<p>There are several implementations available, and for our example, we will use <a href=\"https:\/\/www.getambassador.io\/\">Ambassador gateway<\/a>. We will use <a href=\"https:\/\/www.getambassador.io\/products\/edge-stack\/\">Ambassador Edge stack 1.13.8<\/a> but the open source <a href=\"https:\/\/github.com\/emissary-ingress\/emissary\">Emissary Ingress<\/a> should work as well. Both host-based and context-based naming strategies are supported natively by the Ingress specification.<\/p>\n<p>You can see how we set up our Ingress in the <a href=\"https:\/\/github.com\/codefresh-contrib\/unlimited-test-environments-manifests\/blob\/main\/simple-java-app\/templates\/ingress.yaml\">example application<\/a> for the context-based naming strategy.<\/p>\n<pre>\nkind: Ingress\napiVersion: extensions\/v1beta1\nmetadata:\n  name: \"simple-java-app-ing\"\n  annotations:\n    kubernetes.io\/ingress.class: {{ .Values.ingress.class }}\n\nspec:\n  rules:\n    - http:\n        paths:\n          - path: {{ .Values.ingress.path }}\n            backend:\n              serviceName: simple-service\n              servicePort: 80\n<\/pre>\n<p>The most important property is the \u201cpath\u201d property that tells the Ingress what URL context to honor when a request comes in the cluster (e.g. <code>example.com\/feature1, example.com\/feature2<\/code>, and so on).<\/p>\n<p>We use Helm for making this path property configurable. This means we can pass a Helm value for each deployment that represents the URL of that preview environment.<\/p>\n<p>Apart from the configurable Ingress, our example application is a vanilla Kubernetes application. You can see the full <a href=\"https:\/\/github.com\/codefresh-contrib\/unlimited-test-environments-manifests\/tree\/main\/simple-java-app\/templates\">Helm chart in GitHub<\/a>.<\/p>\n<h2>Creating an environment for a pull request<\/h2>\n<p>With the application manifests in place and an Ingress installed in the cluster, we are now ready to set up the workflow for the temporary environments.<\/p>\n<p>First we need <a href=\"https:\/\/codefresh.io\/docs\/docs\/configure-ci-cd-pipeline\/pipelines\/\">a pipeline<\/a> that creates a temporary environment when a pull request is opened (or synced\/updated).<\/p>\n<p>Codefresh comes with a rich set of triggers that allow you to define exactly which events will launch the pipeline. Here is the trigger dialog:<\/p>\n<figure id=\"attachment_19808\" aria-describedby=\"caption-attachment-19808\" style=\"width: 742px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/pr-events.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/pr-events.png\" alt=\"catch all pull request events\" width=\"742\" height=\"462\" class=\"size-full wp-image-19808\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/pr-events.png 742w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/pr-events-300x187.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/pr-events-20x12.png 20w\" sizes=\"(max-width: 742px) 100vw, 742px\" \/><\/a><figcaption id=\"caption-attachment-19808\" class=\"wp-caption-text\">catch all pull request events<\/figcaption><\/figure>\n<p>We are only interested in the initial event of opening a pull request along with the \u201csync\u201d event. In GitHub terms, a pull request is synced when somebody pushes another commit to an already open pull request. We want to update the environment in this case as well.<\/p>\n<p>As for the pipeline itself, it is very simple with just 4 steps:<\/p>\n<pre>\nversion: \"1.0\"\nstages:\n  - \"prepare\"\n  - \"verify\"\n  - \"deploy\"\n\nsteps:\n  main_clone:\n    title: \"Cloning repository\"\n    type: \"git-clone\"\n    repo: \"codefresh-contrib\/unlimited-test-environments-source-code\"\n    revision: \"${{CF_REVISION}}\"\n    stage: \"prepare\"\n  build_app_image:\n    title: Building Docker Image\n    type: build\n    stage: prepare\n    image_name: kostiscodefresh\/spring-actuator-sample-app\n    working_directory: .\/\n    tag: '${{CF_BRANCH}}'\n    dockerfile: Dockerfile\n  clone:\n    title: \"Cloning repository\"\n    type: \"git-clone\"\n    repo: \"codefresh-contrib\/unlimited-test-environments-manifests\"\n    revision: main\n    stage: \"deploy\"\n  deploy:\n    title: Deploying Helm Chart\n    type: helm\n    stage: deploy\n    working_directory: .\/unlimited-test-environments-manifests\n    arguments:\n      action: install\n      chart_name: simple-java-app\n      release_name: my-spring-app\n      helm_version: 3.2.4\n      kube_context: myawscluster\n      namespace: ${{CF_BRANCH_TAG_NORMALIZED}}\n      cmd_ps: '--create-namespace --wait --timeout 5m'\n      custom_values:\n        - 'image_tag=${{CF_BRANCH_TAG_NORMALIZED}}'\n        - 'replicaCount=3'\n        - 'ingress_path=\/${{CF_BRANCH_TAG_NORMALIZED}}\/'\n<\/pre>\n<p>The 4 steps are:<\/p>\n<ol>\n<li>A <a href=\"https:\/\/codefresh.io\/docs\/docs\/codefresh-yaml\/steps\/git-clone\/\">clone step <\/a>for checking out the source of the application<\/li>\n<li>A <a href=\"https:\/\/codefresh.io\/docs\/docs\/codefresh-yaml\/steps\/build\/\">build step<\/a> to create a container image and also push it to Docker Hub<\/li>\n<li>Another clone step for checking out the Helm chart<\/li>\n<li>The <a href=\"https:\/\/codefresh.io\/docs\/docs\/new-helm\/using-helm-in-codefresh-pipeline\/\">Helm deploy step<\/a> to deploy the application to a new namespace<\/li>\n<\/ol>\n<p>The key point here is the <code>CF_BRANCH_TAG_NORMALIZED <\/code>variable. This <a href=\"https:\/\/codefresh.io\/docs\/docs\/codefresh-yaml\/variables\/\">variable <\/a>is provided by Codefresh and represents the Git branch that triggered this pipeline.<\/p>\n<p>We use the variable in the deploy step in the namespace property as well as the <code>ingress_path<\/code> property.<\/p>\n<p>As an example, if I create a pull request for a GitHub branch named \u201cdemo\u201d and run this pipeline:<\/p>\n<ol>\n<li>A namespace called <code>demo <\/code>will be created on the cluster<\/li>\n<li>Helm will deploy a version of the application on that namespace<\/li>\n<li>The Ingress of the cluster will be instructed to redirect all traffic at <code>\/demo\/<\/code> to this deployment<\/li>\n<\/ol>\n<p>Here is the result deployment in the browser:<\/p>\n<figure id=\"attachment_19809\" aria-describedby=\"caption-attachment-19809\" style=\"width: 795px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/demo-path.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/demo-path.png\" alt=\"Example deployment\" width=\"795\" height=\"205\" class=\"size-full wp-image-19809\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/demo-path.png 795w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/demo-path-300x77.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/demo-path-768x198.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/demo-path-20x5.png 20w\" sizes=\"(max-width: 795px) 100vw, 795px\" \/><\/a><figcaption id=\"caption-attachment-19809\" class=\"wp-caption-text\">Example deployment<\/figcaption><\/figure>\n<p>And that\u2019s it! Now each time a new pull request is opened, a new deployment will take place in the respective namespace.<\/p>\n<p>Because we also catch the PR sync event in our Git trigger, we can also commit again on a branch where a pull request is already open. Another deployment will take place with all our changes.<\/p>\n<h2>Automatic comments on the pull request with the environment URL<\/h2>\n<p>Even if you have a naming convention for preview environments that is easy to remember, it would be very helpful for all members of your team to actually have a written history log of the creation of a temporary environment.<\/p>\n<p>One of the most common patterns is adding the environment URL as a comment in the same pull request that created it.<\/p>\n<figure id=\"attachment_19810\" aria-describedby=\"caption-attachment-19810\" style=\"width: 1223px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/pull-request-comment.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/pull-request-comment.png\" alt=\"Pull request comment\" width=\"1223\" height=\"591\" class=\"size-full wp-image-19810\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/pull-request-comment.png 1223w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/pull-request-comment-300x145.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/pull-request-comment-1024x495.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/pull-request-comment-768x371.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/pull-request-comment-20x10.png 20w\" sizes=\"(max-width: 1223px) 100vw, 1223px\" \/><\/a><figcaption id=\"caption-attachment-19810\" class=\"wp-caption-text\">Pull request comment<\/figcaption><\/figure>\n<p>In the example above, I am working on feature 2345 or a branch called <code>pr-2345<\/code>. After I created the pull request, the environment was deployed to my Kubernetetes cluster, and a comment on the pull request has the exact URL.<\/p>\n<p>This way, anybody who is responsible for reviewing the pull request has, in a single place, both the file changes and the temporary environment for checking how the application looks after the changes.<\/p>\n<p>To achieve this pattern, you can use the Codefresh plugin for <a href=\"https:\/\/codefresh.io\/steps\/step\/kostis-codefresh%2Fgithub-pr-comment\">adding comments to pull requests<\/a>.<br \/>\nYou can add the following snippet in your Codefresh pipeline:<\/p>\n<pre>\n add_pr_comment:\n    title: Adding comment on PR\n    stage: deploy\n    type: kostis-codefresh\/github-pr-comment\n    fail_fast: false\n    arguments:\n      PR_COMMENT_TEXT: \"[CI] Staging environment is at https:\/\/kostis.sales-dev.codefresh.io\/${{CF_BRANCH_TAG_NORMALIZED}}\/\"\n      GIT_PROVIDER_NAME: 'github-1'\n<\/pre>\n<p>With this pipeline step, we add a comment on a pull request. For the comment itself, we again use the predefined <code>CF_BRANCH_TAG_NORMALIZED <\/code>variable that provides the name of the pull request.<\/p>\n<p>The plugin knows which pull request will be used for the comment by automatically fetching the pull request from the trigger of the pipeline. This is why we have no need to specify which pull request will be commented on.<\/p>\n<h2>Quality checks and smoke tests<\/h2>\n<p>Creating automatic preview environments for each pull request is a capability that is also offered by several other products in the Kubernetes ecosystem. The big power of Codefresh comes with the flexibility to add any verification steps before or after the creation of the environment.<\/p>\n<p>For example, it would be wise to run unit and integration tests before an environment is deployed. After all, if unit tests fail, does it really make sense to create a temporary environment? The developer should instead fix the unit tests and then try to deploy again.<\/p>\n<p>On the other hand, maybe you want to use the temporary environment for integration tests and possible security scans. This way when a pull request is created, the reviewer will have all the information needed at hand:<\/p>\n<ul>\n<li>The code that was changed<\/li>\n<li>How the application looks<\/li>\n<li>If the new code introduces security issues or not<\/li>\n<li>If the new code passes unit and integration tests.<\/li>\n<\/ul>\n<p>Making all this information available in a single place results in a much faster review process.<\/p>\n<p>It is also possible to add extra steps in the pipeline that check things <strong>after <\/strong>the environment is created. A very common example is running a set of smoke tests on the newly created temporary environment. This gives you even higher confidence about the correctness of the changes.<\/p>\n<p>You can also include other steps after the deployment such as posting a message to a Slack channel, sending an email, updating a dashboard, and so on.<\/p>\n<p>Here is our final pipeline for creating a preview environment when a pull request is opened.<\/p>\n<figure id=\"attachment_19811\" aria-describedby=\"caption-attachment-19811\" style=\"width: 1591px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/pull-request-preview-pipeline.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/pull-request-preview-pipeline.png\" alt=\"Pull Request preview pipeline\" width=\"1591\" height=\"831\" class=\"size-full wp-image-19811\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/pull-request-preview-pipeline.png 1591w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/pull-request-preview-pipeline-300x157.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/pull-request-preview-pipeline-1024x535.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/pull-request-preview-pipeline-768x401.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/pull-request-preview-pipeline-1536x802.png 1536w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/pull-request-preview-pipeline-20x10.png 20w\" sizes=\"(max-width: 1591px) 100vw, 1591px\" \/><\/a><figcaption id=\"caption-attachment-19811\" class=\"wp-caption-text\">Pull Request preview pipeline<\/figcaption><\/figure>\n<p>This pipeline has the following steps:<\/p>\n<ol>\n<li>A <a href=\"https:\/\/codefresh.io\/docs\/docs\/codefresh-yaml\/steps\/git-clone\/\">clone step<\/a> to fetch the source code of the application<\/li>\n<li>A <a href=\"https:\/\/codefresh.io\/docs\/docs\/codefresh-yaml\/steps\/freestyle\/\">freestyle step<\/a> that runs Maven for compilation and unit tests<\/li>\n<li>A <a href=\"https:\/\/codefresh.io\/docs\/docs\/codefresh-yaml\/steps\/build\/\">build step<\/a> to create the docker image of the application<\/li>\n<li>A step that scans the source code for security issues with <a href=\"https:\/\/snyk.io\/\">Snyk<\/a><\/li>\n<li>A step that scans the container image for <a href=\"https:\/\/codefresh.io\/docs\/docs\/testing\/security-scanning\/\">security issues<\/a> with <a href=\"https:\/\/github.com\/aquasecurity\/trivy\">trivy<\/a><\/li>\n<li>A step that runs <a href=\"https:\/\/codefresh.io\/docs\/docs\/testing\/integration-tests\/\">integration tests<\/a> by launching the app in a service container<\/li>\n<li>A step for <a href=\"https:\/\/codefresh.io\/docs\/docs\/testing\/security-scanning\/\">Sonar analysis<\/a><\/li>\n<li>A step that clones <a href=\"https:\/\/github.com\/codefresh-contrib\/unlimited-test-environments-manifests\">a second Git repository <\/a>that has the <a href=\"https:\/\/codefresh.io\/docs\/docs\/new-helm\/using-helm-in-codefresh-pipeline\/\">Helm chart<\/a> of the app<\/li>\n<li>A step that deploys the source code to a new namespace.<\/li>\n<li>A step that <a href=\"https:\/\/codefresh.io\/steps\/step\/kostis-codefresh%2Fgithub-pr-comment\">adds a comment on the pull request<\/a> with the URL of the temporary environment<\/li>\n<li>A step that runs smoke tests against the temporary test environment<\/li>\n<\/ol>\n<p>Here is the whole pipeline definition:<\/p>\n<pre>\nversion: \"1.0\"\nstages:\n  - \"prepare\"\n  - \"verify\"\n  - \"deploy\"\n\nsteps:\n  main_clone:\n    title: \"Cloning repository\"\n    type: \"git-clone\"\n    repo: \"codefresh-contrib\/unlimited-test-environments-source-code\"\n    revision: \"${{CF_REVISION}}\"\n    stage: \"prepare\"\n\n  run_unit_tests:\n    title: Compile\/Unit test\n    stage: prepare\n    image: 'maven:3.5.2-jdk-8-alpine'\n    commands:\n      - mvn -Dmaven.repo.local=\/codefresh\/volume\/m2_repository package   \n  build_app_image:\n    title: Building Docker Image\n    type: build\n    stage: prepare\n    image_name: kostiscodefresh\/spring-actuator-sample-app\n    working_directory: .\/\n    tag: '${{CF_BRANCH}}'\n    dockerfile: Dockerfile\n  scan_code:\n    title: Source security scan\n    stage: verify\n    image: 'snyk\/snyk-cli:maven-3.6.3_java11'\n    commands:\n      - snyk monitor       \n  scan_image:\n    title: Container security scan\n    stage: verify\n    image: 'aquasec\/trivy'\n    commands:\n      - trivy image docker.io\/kostiscodefresh\/spring-actuator-sample-app:${{CF_BRANCH}}\n  run_integration_tests:\n    title: Integration tests\n    stage: verify\n    image: maven:3.5.2-jdk-8-alpine\n    commands:\n     - mvn -Dmaven.repo.local=\/codefresh\/volume\/m2_repository verify -Dserver.host=http:\/\/my-spring-app -Dsonar.organization=kostis-codefresh-github\n    services:\n      composition:\n        my-spring-app:\n          image: '${{build_app_image}}'\n          ports:\n            - 8080\n      readiness:\n        timeoutSeconds: 30\n        periodSeconds: 15\n        image: byrnedo\/alpine-curl\n        commands:\n          - \"curl http:\/\/my-spring-app:8080\/\"\n  sonar_scan:\n    title: Sonar Scan\n    stage: verify\n    image: 'maven:3.8.1-jdk-11-slim'\n    commands:\n      - mvn -Dmaven.repo.local=\/codefresh\/volume\/m2_repository sonar:sonar -Dsonar.login=${{SONAR_TOKEN}} -Dsonar.host.url=https:\/\/sonarcloud.io -Dsonar.organization=kostis-codefresh-github\n  clone:\n    title: \"Cloning repository\"\n    type: \"git-clone\"\n    repo: \"codefresh-contrib\/unlimited-test-environments-manifests\"\n    revision: main\n    stage: \"deploy\"\n  deploy:\n    title: Deploying Helm Chart\n    type: helm\n    stage: deploy\n    working_directory: .\/unlimited-test-environments-manifests\n    arguments:\n      action: install\n      chart_name: simple-java-app\n      release_name: my-spring-app\n      helm_version: 3.2.4\n      kube_context: myawscluster\n      namespace: ${{CF_BRANCH_TAG_NORMALIZED}}\n      cmd_ps: '--create-namespace --wait --timeout 5m'\n      custom_values:\n        - 'image_tag=${{CF_BRANCH_TAG_NORMALIZED}}'\n        - 'replicaCount=3'\n        - 'ingress_path=\/${{CF_BRANCH_TAG_NORMALIZED}}\/'\n  add_pr_comment:\n    title: Adding comment on PR\n    stage: deploy\n    type: kostis-codefresh\/github-pr-comment\n    fail_fast: false\n    arguments:\n      PR_COMMENT_TEXT: \"[CI] Staging environment is at https:\/\/kostis.sales-dev.codefresh.io\/${{CF_BRANCH_TAG_NORMALIZED}}\/\"\n      GIT_PROVIDER_NAME: 'github-1'\n  run_smoke_tests:\n    title: Smoke tests\n    stage: deploy\n    image: maven:3.5.2-jdk-8-alpine\n    working_directory: \"${{main_clone}}\"\n    fail_fast: false\n    commands:\n     - mvn -Dmaven.repo.local=\/codefresh\/volume\/m2_repository verify -Dserver.host=https:\/\/kostis.sales-dev.codefresh.io\/${{CF_BRANCH_TAG_NORMALIZED}}\/  -Dserver.port=443\n<\/pre>\n<p>Now when a preview environment is created, you have the guarantee that it passed the checks defined by your team (quality and security), leaving only the actual business logic as a review item.<\/p>\n<p>This makes the process of reviewing pull requests as fast as possible, since all the common checks are fully automated and reviewers can focus solely on how the application works.<\/p>\n<h2>Destroying a preview environment<\/h2>\n<p>Creating a preview environment can be a costly operation in a big team. Reducing cloud costs is one of the biggest challenges when it comes to Kubernetes and cloud infrastructure.<\/p>\n<p>You need to have a way to clean up preview environments when they are no longer used. Even though some teams have an automatic job (e.g. via cron) to destroy preview environments that are no longer used, the most cost effective option is to delete a preview environment immediately after the respective pull request is closed.<\/p>\n<p>We can setup a trigger for this event using the Git dialog of Codefresh:<\/p>\n<figure id=\"attachment_19812\" aria-describedby=\"caption-attachment-19812\" style=\"width: 727px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/close-events.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/close-events.png\" alt=\"Closed pull request events\" width=\"727\" height=\"467\" class=\"size-full wp-image-19812\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/close-events.png 727w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/close-events-300x193.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/close-events-20x13.png 20w\" sizes=\"(max-width: 727px) 100vw, 727px\" \/><\/a><figcaption id=\"caption-attachment-19812\" class=\"wp-caption-text\">Closed pull request events<\/figcaption><\/figure>\n<p>For this pipeline, we capture the pull request closed events. It is not really important if the pull request was merged or not. Since it is closed, we assume that the respective preview environment is no longer needed.<\/p>\n<p>The pipeline that deletes the environment is trivial; it has only one step:<\/p>\n<figure id=\"attachment_19813\" aria-describedby=\"caption-attachment-19813\" style=\"width: 1602px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/pull-request-closed-pipeline.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/pull-request-closed-pipeline.png\" alt=\"destroy environment\" width=\"1602\" height=\"790\" class=\"size-full wp-image-19813\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/pull-request-closed-pipeline.png 1602w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/pull-request-closed-pipeline-300x148.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/pull-request-closed-pipeline-1024x505.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/pull-request-closed-pipeline-768x379.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/pull-request-closed-pipeline-1536x757.png 1536w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/pull-request-closed-pipeline-20x10.png 20w\" sizes=\"(max-width: 1602px) 100vw, 1602px\" \/><\/a><figcaption id=\"caption-attachment-19813\" class=\"wp-caption-text\">destroy environment<\/figcaption><\/figure>\n<p>Here is the full definition of the delete pipeline:<\/p>\n<pre>\nversion: \"1.0\"\nsteps:\n  delete_app:\n    title: Delete app\n    type: helm\n    arguments:\n      action: auth\n      helm_version: 3.2.4\n      kube_context: myawscluster\n      namespace: ${{CF_BRANCH_TAG_NORMALIZED}}\n      commands:\n            - helm delete my-spring-app --namespace ${{CF_BRANCH_TAG_NORMALIZED}}\n            - kubectl delete namespace ${{CF_BRANCH_TAG_NORMALIZED}}\n<\/pre>\n<p>In the pipeline, we uninstall the Helm application and also delete the respective namespace with the same name.<\/p>\n<h2>Adopting the mindset of preview environments<\/h2>\n<p>We hope you enjoyed this tutorial for preview environments. Adopting Kubernetes is both a technical challenge and a paradigm shift, as several traditional practices are no longer needed. Stop using predefined test environments and switch to dynamic preview environments today!<\/p>\n<p>For more details, see our <a href=\"https:\/\/codefresh.io\/docs\/docs\/ci-cd-guides\/preview-environments\/\">documentation for preview environments<\/a>.<\/p>\n<p>Note that preview environments can affect your billing if they are not properly configured and managed. If you are running an open source project with public infrastructure you need to take precautions to prevent abuse of this mechanism.<\/p>\n<p>New to Codefresh? <a href=\"https:\/\/codefresh.io\/codefresh-signup\/?utm_source=Blog&#038;utm_medium=Post&#038;utm_campaign=previewenvs\">Create your free account today<\/a>!<\/p>\n<input class=\"fooboxshare_post_id\" type=\"hidden\" value=\"19803\"\/>","protected":false},"excerpt":{"rendered":"<p>In our big series of Kubernetes anti-patterns, we briefly explained that static test environments are no longer needed if you are using Kubernetes. They are expensive, hard to maintain, and hard to clean up. Instead, we suggested the adoption of temporary environments that are created on demand when a pull request is opened. In this &hellip; <a href=\"https:\/\/codefresh.io\/kubernetes-tutorial\/unlimited-preview-environments\/\">Read more<\/a><\/p>\n","protected":false},"author":62,"featured_media":19806,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[2367,3120,5467,1657,1505,1538,6],"tags":[24,44,52,53,58,59,65,67,68],"yoast_head":"<!-- This site is optimized with the Yoast SEO Premium plugin v17.9 (Yoast SEO v18.4.1) - https:\/\/yoast.com\/wordpress\/plugins\/seo\/ -->\n<title>Unlimited Preview Environments with Kubernetes Namespaces | Codefresh<\/title>\n<meta name=\"robots\" content=\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\" \/>\n<link rel=\"canonical\" href=\"https:\/\/codefresh.io\/kubernetes-tutorial\/unlimited-preview-environments\/\" \/>\n<meta property=\"og:locale\" content=\"en_US\" \/>\n<meta property=\"og:type\" content=\"article\" \/>\n<meta property=\"og:title\" content=\"Unlimited Preview Environments with Kubernetes Namespaces\" \/>\n<meta property=\"og:description\" content=\"In our big series of Kubernetes anti-patterns, we briefly explained that static test environments are no longer needed if you are using Kubernetes. They are expensive, hard to maintain, and hard to clean up. Instead, we suggested the adoption of temporary environments that are created on demand when a pull request is opened. In this &hellip; Read more\" \/>\n<meta property=\"og:url\" content=\"https:\/\/codefresh.io\/kubernetes-tutorial\/unlimited-preview-environments\/\" \/>\n<meta property=\"og:site_name\" content=\"Codefresh\" \/>\n<meta property=\"article:publisher\" content=\"https:\/\/www.facebook.com\/codefresh.io\" \/>\n<meta property=\"article:published_time\" content=\"2021-07-09T10:44:07+00:00\" \/>\n<meta property=\"og:image\" content=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/blog-image.png\" \/>\n\t<meta property=\"og:image:width\" content=\"1024\" \/>\n\t<meta property=\"og:image:height\" content=\"340\" \/>\n\t<meta property=\"og:image:type\" content=\"image\/png\" \/>\n<meta name=\"twitter:card\" content=\"summary_large_image\" \/>\n<meta name=\"twitter:creator\" content=\"@codefresh\" \/>\n<meta name=\"twitter:site\" content=\"@codefresh\" \/>\n<meta name=\"twitter:label1\" content=\"Written by\" \/>\n\t<meta name=\"twitter:data1\" content=\"Kostis Kapelonis\" \/>\n\t<meta name=\"twitter:label2\" content=\"Est. reading time\" \/>\n\t<meta name=\"twitter:data2\" content=\"13 minutes\" \/>\n<script type=\"application\/ld+json\" class=\"yoast-schema-graph\">{\"@context\":\"https:\/\/schema.org\",\"@graph\":[{\"@type\":\"Organization\",\"@id\":\"https:\/\/codefresh.io\/#organization\",\"name\":\"Codefresh\",\"url\":\"https:\/\/codefresh.io\/\",\"sameAs\":[\"https:\/\/www.facebook.com\/codefresh.io\",\"https:\/\/www.linkedin.com\/company\/codefresh\",\"https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg\",\"https:\/\/twitter.com\/codefresh\"],\"logo\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#logo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"width\":800,\"height\":800,\"caption\":\"Codefresh\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/#logo\"}},{\"@type\":\"WebSite\",\"@id\":\"https:\/\/codefresh.io\/#website\",\"url\":\"https:\/\/codefresh.io\/\",\"name\":\"Codefresh\",\"description\":\"\",\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"potentialAction\":[{\"@type\":\"SearchAction\",\"target\":{\"@type\":\"EntryPoint\",\"urlTemplate\":\"https:\/\/codefresh.io\/?s={search_term_string}\"},\"query-input\":\"required name=search_term_string\"}],\"inLanguage\":\"en-US\"},{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/unlimited-preview-environments\/#primaryimage\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/blog-image.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/blog-image.png\",\"width\":1024,\"height\":340},{\"@type\":\"WebPage\",\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/unlimited-preview-environments\/#webpage\",\"url\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/unlimited-preview-environments\/\",\"name\":\"Unlimited Preview Environments with Kubernetes Namespaces | Codefresh\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/#website\"},\"primaryImageOfPage\":{\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/unlimited-preview-environments\/#primaryimage\"},\"datePublished\":\"2021-07-09T10:44:07+00:00\",\"dateModified\":\"2021-07-09T10:44:07+00:00\",\"breadcrumb\":{\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/unlimited-preview-environments\/#breadcrumb\"},\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"ReadAction\",\"target\":[\"https:\/\/codefresh.io\/kubernetes-tutorial\/unlimited-preview-environments\/\"]}]},{\"@type\":\"BreadcrumbList\",\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/unlimited-preview-environments\/#breadcrumb\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"name\":\"Home\",\"item\":\"https:\/\/codefresh.io\/\"},{\"@type\":\"ListItem\",\"position\":2,\"name\":\"Unlimited Preview Environments with Kubernetes Namespaces\"}]},{\"@type\":\"Article\",\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/unlimited-preview-environments\/#article\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/unlimited-preview-environments\/#webpage\"},\"author\":{\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87\"},\"headline\":\"Unlimited Preview Environments with Kubernetes Namespaces\",\"datePublished\":\"2021-07-09T10:44:07+00:00\",\"dateModified\":\"2021-07-09T10:44:07+00:00\",\"mainEntityOfPage\":{\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/unlimited-preview-environments\/#webpage\"},\"wordCount\":1974,\"commentCount\":0,\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/unlimited-preview-environments\/#primaryimage\"},\"thumbnailUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/blog-image.png\",\"keywords\":[\"Containers\",\"Kubernetes\",\"devops\",\"CI\/CD\",\"security\",\"codefresh\",\"testing\",\"unit testing\",\"continuous delivery\"],\"articleSection\":[\"Helm Tutorials\",\"Continuous Deployment\/Delivery\",\"Devops\",\"Kubernetes Tutorials\",\"Containers\",\"DevOps Tutorials\",\"How Tos\"],\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"CommentAction\",\"name\":\"Comment\",\"target\":[\"https:\/\/codefresh.io\/kubernetes-tutorial\/unlimited-preview-environments\/#respond\"]}]},{\"@type\":\"Person\",\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87\",\"name\":\"Kostis Kapelonis\",\"image\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#personlogo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png\",\"caption\":\"Kostis Kapelonis\"},\"description\":\"Kostis is a software engineer\/technical-writer dual class character. He lives and breathes automation, good testing practices and stress-free deployments with GitOps.\",\"url\":\"https:\/\/codefresh.io\/author\/kostiscodefresh-io\/\"}]}<\/script>\n<!-- \/ Yoast SEO Premium plugin. -->","yoast_head_json":{"title":"Unlimited Preview Environments with Kubernetes Namespaces | Codefresh","robots":{"index":"index","follow":"follow","max-snippet":"max-snippet:-1","max-image-preview":"max-image-preview:large","max-video-preview":"max-video-preview:-1"},"canonical":"https:\/\/codefresh.io\/kubernetes-tutorial\/unlimited-preview-environments\/","og_locale":"en_US","og_type":"article","og_title":"Unlimited Preview Environments with Kubernetes Namespaces","og_description":"In our big series of Kubernetes anti-patterns, we briefly explained that static test environments are no longer needed if you are using Kubernetes. They are expensive, hard to maintain, and hard to clean up. Instead, we suggested the adoption of temporary environments that are created on demand when a pull request is opened. In this &hellip; Read more","og_url":"https:\/\/codefresh.io\/kubernetes-tutorial\/unlimited-preview-environments\/","og_site_name":"Codefresh","article_publisher":"https:\/\/www.facebook.com\/codefresh.io","article_published_time":"2021-07-09T10:44:07+00:00","og_image":[{"width":1024,"height":340,"url":"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/blog-image.png","type":"image\/png"}],"twitter_card":"summary_large_image","twitter_creator":"@codefresh","twitter_site":"@codefresh","twitter_misc":{"Written by":"Kostis Kapelonis","Est. reading time":"13 minutes"},"schema":{"@context":"https:\/\/schema.org","@graph":[{"@type":"Organization","@id":"https:\/\/codefresh.io\/#organization","name":"Codefresh","url":"https:\/\/codefresh.io\/","sameAs":["https:\/\/www.facebook.com\/codefresh.io","https:\/\/www.linkedin.com\/company\/codefresh","https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg","https:\/\/twitter.com\/codefresh"],"logo":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#logo","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","width":800,"height":800,"caption":"Codefresh"},"image":{"@id":"https:\/\/codefresh.io\/#logo"}},{"@type":"WebSite","@id":"https:\/\/codefresh.io\/#website","url":"https:\/\/codefresh.io\/","name":"Codefresh","description":"","publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"potentialAction":[{"@type":"SearchAction","target":{"@type":"EntryPoint","urlTemplate":"https:\/\/codefresh.io\/?s={search_term_string}"},"query-input":"required name=search_term_string"}],"inLanguage":"en-US"},{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/unlimited-preview-environments\/#primaryimage","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/blog-image.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/blog-image.png","width":1024,"height":340},{"@type":"WebPage","@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/unlimited-preview-environments\/#webpage","url":"https:\/\/codefresh.io\/kubernetes-tutorial\/unlimited-preview-environments\/","name":"Unlimited Preview Environments with Kubernetes Namespaces | Codefresh","isPartOf":{"@id":"https:\/\/codefresh.io\/#website"},"primaryImageOfPage":{"@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/unlimited-preview-environments\/#primaryimage"},"datePublished":"2021-07-09T10:44:07+00:00","dateModified":"2021-07-09T10:44:07+00:00","breadcrumb":{"@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/unlimited-preview-environments\/#breadcrumb"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https:\/\/codefresh.io\/kubernetes-tutorial\/unlimited-preview-environments\/"]}]},{"@type":"BreadcrumbList","@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/unlimited-preview-environments\/#breadcrumb","itemListElement":[{"@type":"ListItem","position":1,"name":"Home","item":"https:\/\/codefresh.io\/"},{"@type":"ListItem","position":2,"name":"Unlimited Preview Environments with Kubernetes Namespaces"}]},{"@type":"Article","@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/unlimited-preview-environments\/#article","isPartOf":{"@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/unlimited-preview-environments\/#webpage"},"author":{"@id":"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87"},"headline":"Unlimited Preview Environments with Kubernetes Namespaces","datePublished":"2021-07-09T10:44:07+00:00","dateModified":"2021-07-09T10:44:07+00:00","mainEntityOfPage":{"@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/unlimited-preview-environments\/#webpage"},"wordCount":1974,"commentCount":0,"publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"image":{"@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/unlimited-preview-environments\/#primaryimage"},"thumbnailUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/07\/blog-image.png","keywords":["Containers","Kubernetes","devops","CI\/CD","security","codefresh","testing","unit testing","continuous delivery"],"articleSection":["Helm Tutorials","Continuous Deployment\/Delivery","Devops","Kubernetes Tutorials","Containers","DevOps Tutorials","How Tos"],"inLanguage":"en-US","potentialAction":[{"@type":"CommentAction","name":"Comment","target":["https:\/\/codefresh.io\/kubernetes-tutorial\/unlimited-preview-environments\/#respond"]}]},{"@type":"Person","@id":"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87","name":"Kostis Kapelonis","image":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#personlogo","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png","caption":"Kostis Kapelonis"},"description":"Kostis is a software engineer\/technical-writer dual class character. He lives and breathes automation, good testing practices and stress-free deployments with GitOps.","url":"https:\/\/codefresh.io\/author\/kostiscodefresh-io\/"}]}},"acf":[],"_links":{"self":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/19803"}],"collection":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/users\/62"}],"replies":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/comments?post=19803"}],"version-history":[{"count":0,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/19803\/revisions"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media\/19806"}],"wp:attachment":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media?parent=19803"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/categories?post=19803"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/tags?post=19803"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}