{"id":20792,"date":"2021-12-17T11:47:07","date_gmt":"2021-12-17T11:47:07","guid":{"rendered":"https:\/\/codefresh.io\/?p=20792"},"modified":"2022-03-23T11:55:27","modified_gmt":"2022-03-23T11:55:27","slug":"stop-using-branches-deploying-different-gitops-environments","status":"publish","type":"post","link":"https:\/\/codefresh.io\/about-gitops\/branches-gitops-environments\/","title":{"rendered":"Stop Using Branches for Deploying to Different GitOps Environments"},"content":{"rendered":"<p>In our big guide <a href=\"https:\/\/codefresh.io\/about-gitops\/pains-gitops-1-0\/\">for GitOps problems<\/a>, we briefly explained (see points 3 and 4) how the current crop of GitOps tools don\u2019t really cover the case of promotion between different environments or how even to model multi-cluster setups.<\/p>\n<figure id=\"attachment_20793\" aria-describedby=\"caption-attachment-20793\" style=\"width: 851px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/12\/promotion.png\"><img class=\"size-full wp-image-20793\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/12\/promotion.png\" alt=\"GitOps promotion\" width=\"851\" height=\"218\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/12\/promotion.png 851w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/12\/promotion-300x77.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/12\/promotion-768x197.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/12\/promotion-20x5.png 20w\" sizes=\"(max-width: 851px) 100vw, 851px\" \/><\/a><figcaption id=\"caption-attachment-20793\" class=\"wp-caption-text\">GitOps promotion<\/figcaption><\/figure>\n<p>The question of \u201cHow do I promote a release to the next environment?\u201d <a href=\"https:\/\/github.com\/argoproj\/argocd-example-apps\/issues\/57\">is becoming increasingly popular<\/a> among organizations that want to adopt GitOps. And even though there are several possible answers, in this particular article I want to focus on what you should NOT do.<\/p>\n<p>You should NOT use Git branches for modeling different environments. If the Git repository holding your configuration (manifests\/templates in the case of Kubernetes) has branches named \u201cstaging\u201d, \u201cQA\u201d, \u201cProduction\u201d and so on, then you have fallen into a trap.<\/p>\n<figure id=\"attachment_20794\" aria-describedby=\"caption-attachment-20794\" style=\"width: 1024px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/12\/branch-per-environment.png\"><img class=\"size-large wp-image-20794\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/12\/branch-per-environment-1024x731.png\" alt=\"Branch Per environment\" width=\"1024\" height=\"731\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/12\/branch-per-environment-1024x731.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/12\/branch-per-environment-300x214.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/12\/branch-per-environment-768x548.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/12\/branch-per-environment-20x14.png 20w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/12\/branch-per-environment.png 1200w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" \/><\/a><figcaption id=\"caption-attachment-20794\" class=\"wp-caption-text\">Branch Per environment<\/figcaption><\/figure>\n<p>Let me repeat that. Using Git branches for modeling different environments is an anti-pattern. Don\u2019t do it!<\/p>\n<p>We will explore the following points on why this practice is an anti-pattern:<\/p>\n<ol>\n<li>Using different Git branches for deployment environments is a relic of the past.<\/li>\n<li>Pull requests and merges between different branches is problematic.<\/li>\n<li>People are tempted to include environment specific code and create configuration drift.<\/li>\n<li>As soon as you have a large number of environments, maintenance of all environments gets quickly out of hand.<\/li>\n<li>The branch-per-environment model goes against the existing Kubernetes ecosystem.<\/li>\n<\/ol>\n<h2>Using branches for different environments should only be applied to legacy applications.<\/h2>\n<p>When I ask people why they chose to use Git branches for modelling different environments, almost always the answer is a variation of \u201cwe\u2019ve always done it that way,\u201d \u201cit feels natural,\u201d \u201cthis is what our developers know,\u201d and so on.<\/p>\n<p>And that is true. Most people are familiar with using branches for different environments. This practice was heavily popularized by the <a href=\"https:\/\/nvie.com\/posts\/a-successful-git-branching-model\/\">venerable Git-Flow model<\/a>. But since the introduction of this model, things have changed a lot. Even the original author has placed a huge warning at the top advising people against adopting this model without understanding the repercussions.<\/p>\n<p>The fact is that the Git-flow model:<\/p>\n<ul>\n<li>Is focused on application source code and not environment configuration (let alone Kubernetes manifests).<\/li>\n<li>Is best used when you need to support multiple versions of your application in production. This happens, but is not usually the case.<\/li>\n<\/ul>\n<p>I am not going to talk too much about Git-flow here and its disadvantages because the present article is about GitOps environments and not application source code, but in summary, you should follow <a href=\"https:\/\/trunkbaseddevelopment.com\/\">trunk-based development<\/a> and use <a href=\"https:\/\/trunkbaseddevelopment.com\/feature-flags\/\">feature-flags<\/a> if you need to support different features for different environments.<\/p>\n<p>In the context of GitOps, the application source code and your configuration should also be in different Git repositories (one repository with just application code and one repository with Kubernetes manifests\/templates). This means that your choice of branching for the application source code should not affect how branches are used in the environment repository that defines your environments.<\/p>\n<figure id=\"attachment_20798\" aria-describedby=\"caption-attachment-20798\" style=\"width: 1024px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/12\/two-repos.png\"><img class=\"size-large wp-image-20798\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/12\/two-repos-1024x577.png\" alt=\"Use different repositories\" width=\"1024\" height=\"577\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/12\/two-repos-1024x577.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/12\/two-repos-300x169.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/12\/two-repos-768x433.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/12\/two-repos-20x11.png 20w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/12\/two-repos.png 1200w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" \/><\/a><figcaption id=\"caption-attachment-20798\" class=\"wp-caption-text\">Use different repositories<\/figcaption><\/figure>\n<p>When you adopt GitOps for your next project, you should start with a clean slate. Application developers can choose whatever branching strategy they want for the application source code (and even use Git-flow), but the configuration Git repository (that has all the Kubernetes manifests\/templates) should NOT follow the branch-per-environment model.<\/p>\n<h2>Promotion is never a simple Git merge<\/h2>\n<p>Now that we know the history of using a branch-per-environment approach for deployments, we can talk about the actual disadvantages.<\/p>\n<p>The main advantage of this approach is the argument that \u201cPromotion is a simple git merge.\u201d In theory, if you want to promote a release from QA to staging, you simply merge your QA branch into the staging branch. And when you are ready for production, you again merge the staging branch into the production branch, and you can be certain that all changes from staging have reached production.<\/p>\n<p>Do you want to see what is different between production and staging? Just do a standard <a href=\"https:\/\/git-scm.com\/docs\/git-diff\">git diff<\/a> between the two branches. Do you want to backport a configuration change from staging to QA? Again, a simple Git merge from the staging branch to qa will do the trick.<\/p>\n<p>And if you want to place extra restrictions on promotions, you can use Pull Requests. So even though anybody could merge from qa to staging, if you want to merge something in the production branch, you can use a Pull Request and demand manual approval from all critical stakeholders.<\/p>\n<p>This all sounds great in theory, and some trivial scenarios can actually work like this. But in practice, this is never the case. Promoting a release via a Git merge can suffer from merge conflicts, unwanted changes, and even the wrong order of changes.<\/p>\n<p>As a simple example, let\u2019s take this Kubernetes deployment that is currently sitting in the staging branch:<\/p>\n<pre>apiVersion: apps\/v1\r\nkind: Deployment\r\nmetadata:\r\n  name: example-deployment\r\nspec:\r\n  replicas: 15\r\n  template:\r\n    metadata:\r\n      labels:\r\n        app: my-app\r\n    spec:\r\n      containers:\r\n      - name: backend\r\n        image: my-app:2.2\r\n        ports:\r\n        - containerPort: 80\r\n<\/pre>\n<p>Your QA team has informed you that version 2.3 (which is in the QA branch) looks good, and it is ready to be moved to staging. You merge the QA branch to the staging branch, promoting the application and think that everything is good.<\/p>\n<p>What you didn\u2019t know is that somebody also changed the number of replicas in the QA branch to 2 because of some resource limitations. With your Git merge, you not only deployed 2.3 to staging, but you also scaled the replicas to 2 (instead of 15), and that is probably something that you don\u2019t want.<\/p>\n<p>You might argue that it would be easy to look at the replica count before merging, but remember that in a real scenario you have a large number of applications with a big number of manifests that are almost always templated (via Helm or Kustomize). So understanding what changes you want to bring and what to leave behind is not a trivial task.<\/p>\n<p>And even if you do find changes that should not be promoted, you need to manually choose the \u201cgood\u201d parts using <a href=\"https:\/\/git-scm.com\/docs\/git-cherry-pick\">git cherry-pick<\/a> or other non-standard methods which are a far cry from the original \u201csimple\u201d Git merge.<\/p>\n<p>But even if you are aware of all the changes that can be promoted, there are several cases where the order of promotion is not the same as the order of committing. As an example, the following 4 changes happen to the QA environment.<\/p>\n<ol>\n<li>The <a href=\"https:\/\/kubernetes.io\/docs\/concepts\/services-networking\/ingress\/\">ingress of the application<\/a> is updated with an extra hostname.<\/li>\n<li>Release 2.5 is promoted to the QA branch and all QA people start testing.<\/li>\n<li>A problem is found with 2.5 and a Kubernetes configmap is fixed.<\/li>\n<li><a href=\"https:\/\/kubernetes.io\/docs\/concepts\/configuration\/manage-resources-containers\/\">Resource limits<\/a> are fine-tuned and committed to QA.<\/li>\n<\/ol>\n<p>It is then decided that the ingress setting and the resource limits should move to the next environment (staging). But the QA team has not finished testing with the 2.5 release.<\/p>\n<p>If you blindly merge the QA branch to the staging branch, you will get all 4 changes at once, including the promotion of 2.5.<\/p>\n<p>To resolve this, again you need to use git cherry-pick or other manual methods.<\/p>\n<p>There are even more complicated cases where the commits have dependencies between them, so even cherry-pick will not work.<\/p>\n<figure id=\"attachment_20800\" aria-describedby=\"caption-attachment-20800\" style=\"width: 1024px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/12\/deps.png\"><img class=\"size-large wp-image-20800\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/12\/deps-1024x798.png\" alt=\"Commit dependencies\" width=\"1024\" height=\"798\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/12\/deps-1024x798.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/12\/deps-300x234.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/12\/deps-768x598.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/12\/deps-20x16.png 20w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/12\/deps.png 1177w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" \/><\/a><figcaption id=\"caption-attachment-20800\" class=\"wp-caption-text\">Commit dependencies<\/figcaption><\/figure>\n<p>In the example above, release 1.24 must be promoted to production. The problem is that one of the commits (the hotfix) contains a multitude of changes where some of them depend on another commit (the ingress config change) which itself cannot be moved to production (as it only applies only to staging). So even with cherry-picks, it is impossible to bring only the required changes from staging to production.<\/p>\n<p>The end result is that promotion is never a simple Git merge. Most organizations will also have a large number of applications that go on a large number of clusters, composed by a large number of manifests. Manually choosing commits is a losing battle.<\/p>\n<h2>Configuration drift can be easily created by environment-specific changes<\/h2>\n<p>In theory, configuration drift should not be an issue with Git merges. If you make a change in staging and then merge that branch to production, then all your changes should transfer to the new environment.<\/p>\n<p>In practice, however, things are different because most organizations only merge to one direction, and team members are easily tempted to change upstream environments and never back-port the changes to downstream environments.<\/p>\n<p>In the classic example with 3 environments for QA, Staging, and Production, the direction of Git merges only goes to one direction. People merge the qa branch to staging and the staging branch to production. This means that changes only flow upwards.<\/p>\n<p>QA -&gt; Staging -&gt; Production.<\/p>\n<p>The classic scenario is that a quick configuration change is needed in production (a hotfix), and somebody applies the fix there. In the case of Kubernetes, this hotfix can be anything such as a change in an existing manifest or even a brand new manifest.<\/p>\n<p>Now Production has a completely different configuration than staging. Next time a release is promoted from Staging to Production, Git will only notify you on what you will bring from Staging. The ad hoc change on production will never appear anywhere in the Pull Request.<\/p>\n<figure id=\"attachment_20801\" aria-describedby=\"caption-attachment-20801\" style=\"width: 1024px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/12\/one-direction-only.png\"><img class=\"size-large wp-image-20801\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/12\/one-direction-only-1024x753.png\" alt=\"One direction only\" width=\"1024\" height=\"753\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/12\/one-direction-only-1024x753.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/12\/one-direction-only-300x221.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/12\/one-direction-only-768x564.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/12\/one-direction-only-20x15.png 20w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/12\/one-direction-only.png 1034w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" \/><\/a><figcaption id=\"caption-attachment-20801\" class=\"wp-caption-text\">One direction only<\/figcaption><\/figure>\n<p>This means that all subsequent deployments can fail, as production now has an undocumented change that will never be detected by any subsequent promotions.<\/p>\n<p>In theory, you could backport such changes and merge periodically all commits from production to staging (and staging to QA). In practice, this never happens due to the reasons outlined in the previous point.<\/p>\n<p>You can imagine that a large number of environments (and not just 3) further increases the problem.<\/p>\n<p>In summary, promoting releases by Git merges does not solve configuration drift and in fact makes it even more problematic as teams are tempted to make ad hoc changes that are never promoted in sequence.<\/p>\n<h2>Managing different Git branches for a large number of environments is a losing battle<\/h2>\n<p>In all the previous examples, I only used 3 environments (qa-&gt; staging-&gt; production) to illustrate the disadvantages of branch-based environment promotion.<\/p>\n<p>Depending on the size of your organization, you will have many more environments. If you factor in other dimensions such as geographical location, the number of environments can quickly skyrocket.<\/p>\n<p>For example, let\u2019s take a company that has 5 environments:<\/p>\n<ol>\n<li>Load Testing<\/li>\n<li>Integration testing<\/li>\n<li>QA<\/li>\n<li>Staging<\/li>\n<li>Production<\/li>\n<\/ol>\n<p>Then let\u2019s assume that the last 3 environments are also deployed to EU, US, and Asia while the first 2 also have GPU and Non-GPU variations. This means that the company has a total of 13 environments. And this is for a single application.<\/p>\n<p>If you follow a branch-based approach for your environments:<\/p>\n<ul>\n<li>You need to have 13 long living Git branches at all times.<\/li>\n<li>You need 13 pull requests for promoting a single change across all environments.<\/li>\n<li>You have a two dimensional promotion matrix with 5 steps upwards and 2-3 steps outwards.<\/li>\n<li>The possibilities for wrong merges, configuration drift and ad-hoc changes is now non-trivial across all environment combinations.<\/li>\n<\/ul>\n<p>In the context of this example organization, all previous issues are now more prevalent.<\/p>\n<h2>The branch-per-environment model goes against Helm\/Kustomize<\/h2>\n<p>Two of the most popular Kubernetes tools for describing applications are Helm and Kustomize. Let\u2019s see how these two tools recommend modeling different environments.<\/p>\n<p>For Helm, you need to create a generic chart that itself accepts parameters in the form of a values.yaml file. If you want to have different environments, <a href=\"https:\/\/codefresh.io\/helm-tutorial\/helm-deployment-environments\/\">you need multiple values files<\/a>.<\/p>\n<figure id=\"attachment_20802\" aria-describedby=\"caption-attachment-20802\" style=\"width: 397px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/12\/helm-environments.png\"><img class=\"size-full wp-image-20802\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/12\/helm-environments.png\" alt=\"Helm environments\" width=\"397\" height=\"344\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/12\/helm-environments.png 397w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/12\/helm-environments-300x260.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/12\/helm-environments-20x17.png 20w\" sizes=\"(max-width: 397px) 100vw, 397px\" \/><\/a><figcaption id=\"caption-attachment-20802\" class=\"wp-caption-text\">Helm environments<\/figcaption><\/figure>\n<p>For Kustomize, you need to create a \u201cbase\u201d configuration, and then each environment is modeled as <a href=\"https:\/\/codefresh.io\/about-gitops\/applied-gitops-with-kustomize\/\">an overlay that has its own folder<\/a>:<\/p>\n<figure id=\"attachment_20803\" aria-describedby=\"caption-attachment-20803\" style=\"width: 616px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/12\/kustomize-envs.png\"><img class=\"size-full wp-image-20803\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/12\/kustomize-envs.png\" alt=\"Kustomize environments\" width=\"616\" height=\"630\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/12\/kustomize-envs.png 616w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/12\/kustomize-envs-293x300.png 293w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/12\/kustomize-envs-20x20.png 20w\" sizes=\"(max-width: 616px) 100vw, 616px\" \/><\/a><figcaption id=\"caption-attachment-20803\" class=\"wp-caption-text\">Kustomize environments<\/figcaption><\/figure>\n<p>In both cases, different environments are modeled with different folders\/files. Helm and Kustomize know nothing about Git branches or Git merges or Pull Requests. They use just plain files.<\/p>\n<p>Let me repeat that again: Both Helm and Kustomize use plain files for different environments and not Git branches. This should be a good hint on how to model different Kubernetes configurations using either of these tools.<\/p>\n<p>If you introduce Git branches in the mix, you not only introduce extra complexity, but you also go against your own tooling.<\/p>\n<h2>The recommended way to promote releases in GitOps environments<\/h2>\n<p>Modeling different Kubernetes environments and promoting a release between them is a very common issue for all teams that adopt GitOps. Even though a very popular method is to use Git branches for each environment and assume that a promotion is a \u201csimple\u201d Git merge, we have seen in this article that this is an anti-pattern.<\/p>\n<p>In the <a href=\"https:\/\/codefresh.io\/about-gitops\/how-to-model-your-gitops-environments-and-promote-releases-between-them\/\">next article<\/a>, we will see a better approach to model your different environments and promote releases between your Kubernetes cluster. The last point of the article (regarding Helm\/Kustomize) should already give you a hint on how this approach works.<\/p>\n<p>Stay tuned!<\/p>\n<input class=\"fooboxshare_post_id\" type=\"hidden\" value=\"20792\"\/>","protected":false},"excerpt":{"rendered":"<p>In our big guide for GitOps problems, we briefly explained (see points 3 and 4) how the current crop of GitOps tools don\u2019t really cover the case of promotion between different environments or how even to model multi-cluster setups. The question of \u201cHow do I promote a release to the next environment?\u201d is becoming increasingly &hellip; <a href=\"https:\/\/codefresh.io\/about-gitops\/branches-gitops-environments\/\">Read more<\/a><\/p>\n","protected":false},"author":62,"featured_media":20796,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[3120,5467,5703,1657],"tags":[14,44,52,53,68,994,2954,4322,5725,5731],"yoast_head":"<!-- This site is optimized with the Yoast SEO Premium plugin v17.9 (Yoast SEO v18.4.1) - https:\/\/yoast.com\/wordpress\/plugins\/seo\/ -->\n<title>Stop Using Branches for Deploying to Different GitOps Environments | Codefresh<\/title>\n<meta name=\"robots\" content=\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\" \/>\n<link rel=\"canonical\" href=\"https:\/\/codefresh.io\/about-gitops\/branches-gitops-environments\/\" \/>\n<meta property=\"og:locale\" content=\"en_US\" \/>\n<meta property=\"og:type\" content=\"article\" \/>\n<meta property=\"og:title\" content=\"Stop Using Branches for Deploying to Different GitOps Environments\" \/>\n<meta property=\"og:description\" content=\"In our big guide for GitOps problems, we briefly explained (see points 3 and 4) how the current crop of GitOps tools don\u2019t really cover the case of promotion between different environments or how even to model multi-cluster setups. The question of \u201cHow do I promote a release to the next environment?\u201d is becoming increasingly &hellip; Read more\" \/>\n<meta property=\"og:url\" content=\"https:\/\/codefresh.io\/about-gitops\/branches-gitops-environments\/\" \/>\n<meta property=\"og:site_name\" content=\"Codefresh\" \/>\n<meta property=\"article:publisher\" content=\"https:\/\/www.facebook.com\/codefresh.io\" \/>\n<meta property=\"article:published_time\" content=\"2021-12-17T11:47:07+00:00\" \/>\n<meta property=\"article:modified_time\" content=\"2022-03-23T11:55:27+00:00\" \/>\n<meta property=\"og:image\" content=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/12\/GitOps_Header_Linkedin.png\" \/>\n<meta name=\"twitter:card\" content=\"summary_large_image\" \/>\n<meta name=\"twitter:creator\" content=\"@codefresh\" \/>\n<meta name=\"twitter:site\" content=\"@codefresh\" \/>\n<meta name=\"twitter:label1\" content=\"Written by\" \/>\n\t<meta name=\"twitter:data1\" content=\"Kostis Kapelonis\" \/>\n\t<meta name=\"twitter:label2\" content=\"Est. reading time\" \/>\n\t<meta name=\"twitter:data2\" content=\"11 minutes\" \/>\n<script type=\"application\/ld+json\" class=\"yoast-schema-graph\">{\"@context\":\"https:\/\/schema.org\",\"@graph\":[{\"@type\":\"Organization\",\"@id\":\"https:\/\/codefresh.io\/#organization\",\"name\":\"Codefresh\",\"url\":\"https:\/\/codefresh.io\/\",\"sameAs\":[\"https:\/\/www.facebook.com\/codefresh.io\",\"https:\/\/www.linkedin.com\/company\/codefresh\",\"https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg\",\"https:\/\/twitter.com\/codefresh\"],\"logo\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#logo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"width\":800,\"height\":800,\"caption\":\"Codefresh\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/#logo\"}},{\"@type\":\"WebSite\",\"@id\":\"https:\/\/codefresh.io\/#website\",\"url\":\"https:\/\/codefresh.io\/\",\"name\":\"Codefresh\",\"description\":\"\",\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"potentialAction\":[{\"@type\":\"SearchAction\",\"target\":{\"@type\":\"EntryPoint\",\"urlTemplate\":\"https:\/\/codefresh.io\/?s={search_term_string}\"},\"query-input\":\"required name=search_term_string\"}],\"inLanguage\":\"en-US\"},{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/about-gitops\/branches-gitops-environments\/#primaryimage\",\"inLanguage\":\"en-US\",\"url\":\"\",\"contentUrl\":\"\"},{\"@type\":\"WebPage\",\"@id\":\"https:\/\/codefresh.io\/about-gitops\/branches-gitops-environments\/#webpage\",\"url\":\"https:\/\/codefresh.io\/about-gitops\/branches-gitops-environments\/\",\"name\":\"Stop Using Branches for Deploying to Different GitOps Environments | Codefresh\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/#website\"},\"primaryImageOfPage\":{\"@id\":\"https:\/\/codefresh.io\/about-gitops\/branches-gitops-environments\/#primaryimage\"},\"datePublished\":\"2021-12-17T11:47:07+00:00\",\"dateModified\":\"2022-03-23T11:55:27+00:00\",\"breadcrumb\":{\"@id\":\"https:\/\/codefresh.io\/about-gitops\/branches-gitops-environments\/#breadcrumb\"},\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"ReadAction\",\"target\":[\"https:\/\/codefresh.io\/about-gitops\/branches-gitops-environments\/\"]}]},{\"@type\":\"BreadcrumbList\",\"@id\":\"https:\/\/codefresh.io\/about-gitops\/branches-gitops-environments\/#breadcrumb\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"name\":\"Home\",\"item\":\"https:\/\/codefresh.io\/\"},{\"@type\":\"ListItem\",\"position\":2,\"name\":\"Stop Using Branches for Deploying to Different GitOps Environments\"}]},{\"@type\":\"Article\",\"@id\":\"https:\/\/codefresh.io\/about-gitops\/branches-gitops-environments\/#article\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/about-gitops\/branches-gitops-environments\/#webpage\"},\"author\":{\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87\"},\"headline\":\"Stop Using Branches for Deploying to Different GitOps Environments\",\"datePublished\":\"2021-12-17T11:47:07+00:00\",\"dateModified\":\"2022-03-23T11:55:27+00:00\",\"mainEntityOfPage\":{\"@id\":\"https:\/\/codefresh.io\/about-gitops\/branches-gitops-environments\/#webpage\"},\"wordCount\":2154,\"commentCount\":30,\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/about-gitops\/branches-gitops-environments\/#primaryimage\"},\"thumbnailUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/12\/Branches_deploying.png\",\"keywords\":[\"docker\",\"Kubernetes\",\"devops\",\"CI\/CD\",\"continuous delivery\",\"helm\",\"git\",\"GitOps\",\"Kustomize\",\"branches\"],\"articleSection\":[\"Continuous Deployment\/Delivery\",\"Devops\",\"GitOps\",\"Kubernetes Tutorials\"],\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"CommentAction\",\"name\":\"Comment\",\"target\":[\"https:\/\/codefresh.io\/about-gitops\/branches-gitops-environments\/#respond\"]}]},{\"@type\":\"Person\",\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87\",\"name\":\"Kostis Kapelonis\",\"image\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#personlogo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png\",\"caption\":\"Kostis Kapelonis\"},\"description\":\"Kostis is a software engineer\/technical-writer dual class character. He lives and breathes automation, good testing practices and stress-free deployments with GitOps.\",\"url\":\"https:\/\/codefresh.io\/author\/kostiscodefresh-io\/\"}]}<\/script>\n<!-- \/ Yoast SEO Premium plugin. -->","yoast_head_json":{"title":"Stop Using Branches for Deploying to Different GitOps Environments | Codefresh","robots":{"index":"index","follow":"follow","max-snippet":"max-snippet:-1","max-image-preview":"max-image-preview:large","max-video-preview":"max-video-preview:-1"},"canonical":"https:\/\/codefresh.io\/about-gitops\/branches-gitops-environments\/","og_locale":"en_US","og_type":"article","og_title":"Stop Using Branches for Deploying to Different GitOps Environments","og_description":"In our big guide for GitOps problems, we briefly explained (see points 3 and 4) how the current crop of GitOps tools don\u2019t really cover the case of promotion between different environments or how even to model multi-cluster setups. The question of \u201cHow do I promote a release to the next environment?\u201d is becoming increasingly &hellip; Read more","og_url":"https:\/\/codefresh.io\/about-gitops\/branches-gitops-environments\/","og_site_name":"Codefresh","article_publisher":"https:\/\/www.facebook.com\/codefresh.io","article_published_time":"2021-12-17T11:47:07+00:00","article_modified_time":"2022-03-23T11:55:27+00:00","og_image":[{"url":"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/12\/GitOps_Header_Linkedin.png"}],"twitter_card":"summary_large_image","twitter_creator":"@codefresh","twitter_site":"@codefresh","twitter_misc":{"Written by":"Kostis Kapelonis","Est. reading time":"11 minutes"},"schema":{"@context":"https:\/\/schema.org","@graph":[{"@type":"Organization","@id":"https:\/\/codefresh.io\/#organization","name":"Codefresh","url":"https:\/\/codefresh.io\/","sameAs":["https:\/\/www.facebook.com\/codefresh.io","https:\/\/www.linkedin.com\/company\/codefresh","https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg","https:\/\/twitter.com\/codefresh"],"logo":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#logo","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","width":800,"height":800,"caption":"Codefresh"},"image":{"@id":"https:\/\/codefresh.io\/#logo"}},{"@type":"WebSite","@id":"https:\/\/codefresh.io\/#website","url":"https:\/\/codefresh.io\/","name":"Codefresh","description":"","publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"potentialAction":[{"@type":"SearchAction","target":{"@type":"EntryPoint","urlTemplate":"https:\/\/codefresh.io\/?s={search_term_string}"},"query-input":"required name=search_term_string"}],"inLanguage":"en-US"},{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/about-gitops\/branches-gitops-environments\/#primaryimage","inLanguage":"en-US","url":"","contentUrl":""},{"@type":"WebPage","@id":"https:\/\/codefresh.io\/about-gitops\/branches-gitops-environments\/#webpage","url":"https:\/\/codefresh.io\/about-gitops\/branches-gitops-environments\/","name":"Stop Using Branches for Deploying to Different GitOps Environments | Codefresh","isPartOf":{"@id":"https:\/\/codefresh.io\/#website"},"primaryImageOfPage":{"@id":"https:\/\/codefresh.io\/about-gitops\/branches-gitops-environments\/#primaryimage"},"datePublished":"2021-12-17T11:47:07+00:00","dateModified":"2022-03-23T11:55:27+00:00","breadcrumb":{"@id":"https:\/\/codefresh.io\/about-gitops\/branches-gitops-environments\/#breadcrumb"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https:\/\/codefresh.io\/about-gitops\/branches-gitops-environments\/"]}]},{"@type":"BreadcrumbList","@id":"https:\/\/codefresh.io\/about-gitops\/branches-gitops-environments\/#breadcrumb","itemListElement":[{"@type":"ListItem","position":1,"name":"Home","item":"https:\/\/codefresh.io\/"},{"@type":"ListItem","position":2,"name":"Stop Using Branches for Deploying to Different GitOps Environments"}]},{"@type":"Article","@id":"https:\/\/codefresh.io\/about-gitops\/branches-gitops-environments\/#article","isPartOf":{"@id":"https:\/\/codefresh.io\/about-gitops\/branches-gitops-environments\/#webpage"},"author":{"@id":"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87"},"headline":"Stop Using Branches for Deploying to Different GitOps Environments","datePublished":"2021-12-17T11:47:07+00:00","dateModified":"2022-03-23T11:55:27+00:00","mainEntityOfPage":{"@id":"https:\/\/codefresh.io\/about-gitops\/branches-gitops-environments\/#webpage"},"wordCount":2154,"commentCount":30,"publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"image":{"@id":"https:\/\/codefresh.io\/about-gitops\/branches-gitops-environments\/#primaryimage"},"thumbnailUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/12\/Branches_deploying.png","keywords":["docker","Kubernetes","devops","CI\/CD","continuous delivery","helm","git","GitOps","Kustomize","branches"],"articleSection":["Continuous Deployment\/Delivery","Devops","GitOps","Kubernetes Tutorials"],"inLanguage":"en-US","potentialAction":[{"@type":"CommentAction","name":"Comment","target":["https:\/\/codefresh.io\/about-gitops\/branches-gitops-environments\/#respond"]}]},{"@type":"Person","@id":"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87","name":"Kostis Kapelonis","image":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#personlogo","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png","caption":"Kostis Kapelonis"},"description":"Kostis is a software engineer\/technical-writer dual class character. He lives and breathes automation, good testing practices and stress-free deployments with GitOps.","url":"https:\/\/codefresh.io\/author\/kostiscodefresh-io\/"}]}},"acf":[],"_links":{"self":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/20792"}],"collection":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/users\/62"}],"replies":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/comments?post=20792"}],"version-history":[{"count":7,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/20792\/revisions"}],"predecessor-version":[{"id":21897,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/20792\/revisions\/21897"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media\/20796"}],"wp:attachment":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media?parent=20792"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/categories?post=20792"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/tags?post=20792"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}