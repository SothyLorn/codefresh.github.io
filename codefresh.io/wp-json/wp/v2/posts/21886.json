{"id":21886,"date":"2022-03-23T11:22:55","date_gmt":"2022-03-23T11:22:55","guid":{"rendered":"https:\/\/codefresh.io\/?p=21886"},"modified":"2022-03-23T11:22:55","modified_gmt":"2022-03-23T11:22:55","slug":"how-to-model-your-gitops-environments-and-promote-releases-between-them","status":"publish","type":"post","link":"https:\/\/codefresh.io\/about-gitops\/how-to-model-your-gitops-environments-and-promote-releases-between-them\/","title":{"rendered":"How to Model Your Gitops Environments and Promote Releases between Them"},"content":{"rendered":"<p>Two of the most important questions that people ask themselves on day 2 after adopting GitOps are:<\/p>\n<ol>\n<li>How should I represent different environments on Git?<\/li>\n<li>How should I handle promoting releases between environments?<\/li>\n<\/ol>\n<p>In the <a href=\"https:\/\/codefresh.io\/about-gitops\/branches-gitops-environments\/\">previous article of the series<\/a>, I focused on what <strong>NOT <\/strong>to do and explained why using Git branches for different environments is a bad idea. I also hinted that the \u201cenvironment-per-folder\u201d approach is a better idea. This article has proved hugely popular and several people wanted to see all the details about the suggested structure for environments when folders are used.<\/p>\n<p>In this article, I am going to explain how to model your GitOps environments using different folders on the same Git branch, and as an added bonus, how to handle environment promotion (both simple and complex) with simple file copy operations.<\/p>\n<figure id=\"attachment_20793\" aria-describedby=\"caption-attachment-20793\" style=\"width: 851px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/12\/promotion.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/12\/promotion.png\" alt=\"GitOps promotion\" width=\"851\" height=\"218\" class=\"size-full wp-image-20793\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2021\/12\/promotion.png 851w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/12\/promotion-300x77.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/12\/promotion-768x197.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2021\/12\/promotion-20x5.png 20w\" sizes=\"(max-width: 851px) 100vw, 851px\" \/><\/a><figcaption id=\"caption-attachment-20793\" class=\"wp-caption-text\">GitOps promotion<\/figcaption><\/figure>\n<p>Hopefully this article will help with the endless stream of <a href=\"https:\/\/github.com\/argoproj\/argocd-example-apps\/issues\/57\">questions <\/a>and <a href=\"https:\/\/github.com\/argoproj\/argo-cd\/discussions\/5667\">discussions <\/a>on this hot topic.<\/p>\n<h2>Learn your application first<\/h2>\n<p>Before creating your folder structure you need to do some research first and understand the \u201csettings\u201d of your application. Even though several people talk about application configuration in a generic manner, in reality not all configuration settings are equally important.<\/p>\n<p>In the context of a Kubernetes application, we have the following categories of \u201cenvironment configuration\u201d:<\/p>\n<ol>\n<li>The <strong>application version<\/strong> in the form of the container tag used. This is probably the most important setting in a Kubernetes manifest (as far as environment promotions are concerned). Depending on your use case, you might get away with simply changing the version of the container image. However, several times a new change in the source code also requires a new change in the deployment environment<\/li>\n<li><strong>Kubernetes specific settings<\/strong> for your application. This includes the replicas of the application and other Kubernetes related information such as resource limits, health checks, persistent volumes, affinity rules, etc.<\/li>\n<li>Mostly <strong>static business settings<\/strong>. This is the set of settings that are unrelated to Kubernetes but have to do with the business of your application. It might be external URLs, internal queue sizes, UI defaults, authentication profiles, etc. By \u201cmostly static,\u201d I mean settings that are defined once for each environment and then never change afterwards. For example, you always want your production environment to use production.paypal.com and your non-production environments to use staging.paypal.com. This is a setting that you never want to promote between environments<\/li>\n<li><strong>Non-static business settings<\/strong>. This is the same thing as the previous point, but it includes settings that you DO want to promote between environments. This could be a global VAT setting, your recommendation engine parameters, the available bitrate encodings, and any other setting that is specific to your business.<\/li>\n<\/ol>\n<p>It is imperative that you understand what all the different settings are and, more importantly, which of them belong to category 4 as these are the ones that you also want to promote along with your application version.<\/p>\n<p>This way you can cover all possible promotion scenarios:<\/p>\n<ol>\n<li>Your application moves from version 1.34 to 1.35 in QA. This is a simple source code change. Therefore you only need to change the container image property in your QA environment.<\/li>\n<li>Your application moves from version 3.23 to 3.24 in Staging. This is not a simple source code change. You need to update the container image property and also bring the new setting \u201crecommender.batch_size\u201d from QA to staging.<\/li>\n<\/ol>\n<p>I see too many teams that don\u2019t understand the distinction between different configuration parameters and have a single configuration file (or mechanism) with values from different areas (i.e. both runtime and application business settings).<\/p>\n<p>Once you have the list of your settings and which area they belong to, you are ready to create your environment structure and optimize the file copy operations for the settings that change a lot and need to be moved between environments.<\/p>\n<h2>Example with 5 GitOps environments and variations between them<\/h2>\n<p>Let\u2019s see an actual example. I thought about doing the classic QA\/Staging\/Production trilogy, but this is rather boring so let\u2019s dive into a more realistic example. <\/p>\n<p>We are going to model the environment situation mentioned in the first article of the series. The company that we will examine has 5 distinct environments:<\/p>\n<ul>\n<li>Load Testing<\/li>\n<li>Integration Testing<\/li>\n<li>QA<\/li>\n<li>Staging<\/li>\n<li>Production<\/li>\n<\/ul>\n<p>Then let\u2019s assume that the last 2 environments are also deployed to EU, US, and Asia while the first 2 also have GPU and Non-GPU variations. This means that the company has a total of 11 environments. <\/p>\n<p>You can find the suggested folder structure at  <a href=\"https:\/\/github.com\/kostis-codefresh\/gitops-environment-promotion\">https:\/\/github.com\/kostis-codefresh\/gitops-environment-promotion<\/a>. All environments are different folders in the same branch. There are NO branches for the different environments. If you want to know what is deployed in an environment, you simply look at envs\/<environment-name> in the main branch of the repo.<\/p>\n<p>Before we explain the structure, here are some disclaimers: <\/p>\n<p><strong>Disclaimer 1:<\/strong> Writing this article took a long time because I wasn\u2019t sure if I should cover <a href=\"https:\/\/kustomize.io\/\">Kustomize <\/a>or <a href=\"https:\/\/helm.sh\/\">Helm <\/a>or plain manifests. I chose Kustomize as it makes things a bit easier (and I also mention Helm at the end of the article). Note however that the Kustomize templates in the example repo are simply for illustration purposes. The present article is <strong>NOT <\/strong>a Kustomize tutorial. In a real application, you might have <a href=\"https:\/\/kubectl.docs.kubernetes.io\/references\/kustomize\/kustomization\/configmapgenerator\/\">Configmap generators<\/a>, <a href=\"https:\/\/kubectl.docs.kubernetes.io\/references\/kustomize\/kustomization\/patchesstrategicmerge\/\">custom patches<\/a> and adopt a completely different \u201ccomponent\u201d structure than the one I am showing here. If you are not familiar with Kustomize, spend some time understanding its capabilities first and then come back to this article.<\/p>\n<p><strong>Disclaimer 2:<\/strong> The <a href=\"https:\/\/github.com\/kostis-codefresh\/gitops-promotion-source-code\">application I use<\/a> for the promotions is completely dummy, and its configuration misses several best practices mainly for brevity and simplicity reasons. For example, some deployments are missing <a href=\"https:\/\/kubernetes.io\/docs\/tasks\/configure-pod-container\/configure-liveness-readiness-startup-probes\/\">health checks<\/a>, and all of them are missing <a href=\"https:\/\/kubernetes.io\/docs\/concepts\/configuration\/manage-resources-containers\/\">resource limits<\/a>. Again, this article is <strong>NOT <\/strong>about how to create Kubernetes deployments. You should already know how proper deployment manifests look. If you want to learn more about production-grade best practices, then see my other article at <a href=\"https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-1\/\">https:\/\/codefresh.io\/kubernetes-tutorial\/kubernetes-antipatterns-1\/<\/a> <\/p>\n<p>With the disclaimers out of the way, here is the repository structure:<\/p>\n<figure id=\"attachment_21887\" aria-describedby=\"caption-attachment-21887\" style=\"width: 566px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/basic-structure.jpg\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/basic-structure.jpg\" alt=\"GitOps folder structure\" width=\"566\" height=\"627\" class=\"size-full wp-image-21887\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/basic-structure.jpg 566w, https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/basic-structure-271x300.jpg 271w, https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/basic-structure-18x20.jpg 18w\" sizes=\"(max-width: 566px) 100vw, 566px\" \/><\/a><figcaption id=\"caption-attachment-21887\" class=\"wp-caption-text\">GitOps folder structure<\/figcaption><\/figure>\n<p>The base directory holds configuration which is common to all environments. It is not expected to change often. If you want to do changes to multiple environments at the same time, it is best to use the \u201cvariants\u201d folder.<\/p>\n<p>The variants folder (a.k.a mixins, a.k.a. components) holds common characteristics between environments. It is up to you to define what exactly you think is \u201ccommon\u201d between your environments after researching your application as discussed in the previous section.<\/p>\n<p>In the example application, we have variants for all prod and non-prod environments and also the regions. Here is an example of the <a href=\"https:\/\/raw.githubusercontent.com\/kostis-codefresh\/gitops-environment-promotion\/main\/variants\/prod\/prod.yml\">prod variant<\/a> that applies to ALL production environments.<\/p>\n<pre>\r\n---\r\napiVersion: apps\/v1\r\nkind: Deployment\r\nmetadata:\r\n  name: simple-deployment\r\nspec:\r\n  template:\r\n    spec:\r\n      containers:\r\n      - name: webserver-simple\r\n        env:\r\n        - name: ENV_TYPE\r\n          value: \"production\"\r\n        - name: PAYPAL_URL\r\n          value: \"production.paypal.com\"   \r\n        - name: DB_USER\r\n          value: \"prod_username\"\r\n        - name: DB_PASSWORD\r\n          value: \"prod_password\"                     \r\n        livenessProbe:\r\n          httpGet:\r\n            path: \/health\r\n            port: 8080\r\n<\/pre>\n<p>In the example above, we make sure that all production environments are using the production DB credentials, the production payment gateway, and a liveness probe (this is a contrived example, please see disclaimer 2 at the start of this section). These settings belong to the set of configuration that we don\u2019t expect to promote between environments, but we assume that they will be static across the application lifecycle.<\/p>\n<p>With the base and variants ready, we can now define every final environment with a combination of those properties.<\/p>\n<p>Here is an example of the <a href=\"https:\/\/github.com\/kostis-codefresh\/gitops-environment-promotion\/tree\/main\/envs\/staging-asia\">staging ASIA environment<\/a>:<\/p>\n<pre>\r\napiVersion: kustomize.config.k8s.io\/v1beta1\r\nkind: Kustomization\r\n\r\nnamespace: staging\r\nnamePrefix: staging-asia-\r\n\r\nresources:\r\n- ..\/..\/base\r\n\r\ncomponents:\r\n  - ..\/..\/variants\/non-prod\r\n  - ..\/..\/variants\/asia\r\n\r\npatchesStrategicMerge:\r\n- deployment.yml\r\n- version.yml\r\n- replicas.yml\r\n- settings.yml\r\n<\/pre>\n<p>First we define some common properties. We inherit all configuration from base, from non-prod environments, and for all environments in Asia.<\/p>\n<p>The key point here is the patches that we apply. The <a href=\"https:\/\/github.com\/kostis-codefresh\/gitops-environment-promotion\/blob\/main\/envs\/staging-asia\/version.yml\">version.yml<\/a> and <a href=\"https:\/\/github.com\/kostis-codefresh\/gitops-environment-promotion\/blob\/main\/envs\/staging-asia\/replicas.yml\">replicas.yml<\/a> are self-explanatory. They only define the image and replicas on their own and nothing else.<\/p>\n<p>The version.yml file (which is the most important thing to promote between environments) defines only the image of the application and nothing else.<\/p>\n<pre>\r\n---\r\napiVersion: apps\/v1\r\nkind: Deployment\r\nmetadata:\r\n  name: simple-deployment\r\nspec:\r\n  template:\r\n    spec:\r\n      containers:\r\n      - name: webserver-simple\r\n        image: docker.io\/kostiscodefresh\/simple-env-app:2.0\r\n<\/pre>\n<p>The associated settings for each release that we <strong>DO <\/strong>expect to promote between environments are also defined in <a href=\"https:\/\/github.com\/kostis-codefresh\/gitops-environment-promotion\/blob\/main\/envs\/staging-asia\/settings.yml\">settings.yml <\/a><\/p>\n<pre>\r\n---\r\napiVersion: apps\/v1\r\nkind: Deployment\r\nmetadata:\r\n  name: simple-deployment\r\nspec:\r\n  template:\r\n    spec:\r\n      containers:\r\n      - name: webserver-simple\r\n        env:\r\n        - name: UI_THEME\r\n          value: \"dark\"\r\n        - name: CACHE_SIZE\r\n          value: \"1024kb\"\r\n        - name: PAGE_LIMIT\r\n          value: \"25\"\r\n        - name: SORTING\r\n          value: \"ascending\"    \r\n        - name: N_BUCKETS\r\n          value: \"42\"         \r\n<\/pre>\n<p>Feel free to look at the <a href=\"https:\/\/github.com\/kostis-codefresh\/gitops-environment-promotion\">whole repository<\/a> to understand the way all kustomizations are formed.<\/p>\n<h2>Performing the initial deployment via GitOps<\/h2>\n<p>To deploy an application to its associated environment, just point your GitOps controller to the respective \u201cenv\u201d folder and kustomize will create the complete hierarchy of settings and values.<\/p>\n<p>Here is the <a href=\"https:\/\/github.com\/kostis-codefresh\/gitops-promotion-source-code\">example application<\/a> as it runs in Staging\/Asia<\/p>\n<figure id=\"attachment_21890\" aria-describedby=\"caption-attachment-21890\" style=\"width: 537px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/application-example.jpg\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/application-example.jpg\" alt=\"GitOps application example\" width=\"537\" height=\"360\" class=\"size-full wp-image-21890\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/application-example.jpg 537w, https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/application-example-300x201.jpg 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/application-example-20x13.jpg 20w\" sizes=\"(max-width: 537px) 100vw, 537px\" \/><\/a><figcaption id=\"caption-attachment-21890\" class=\"wp-caption-text\">GitOps application example<\/figcaption><\/figure>\n<p>You can also use Kustomize on the command line to preview what is going to be deployed for each environment. Examples:<\/p>\n<pre>\r\nkustomize build envs\/staging-asia\r\nkustomize build envs\/qa\r\nkustomize build envs\/integration-gpu\r\n<\/pre>\n<p>You can of course pipe the output to kubectl to deploy each environment, but in the context of GitOps, you should always let your GitOps controller deploy your environments and avoid manual kubectl operations.<\/p>\n<h2>Comparing the configuration of two environments<\/h2>\n<p>A very common need for a software team is to understand what is different between two environments. I have seen several teams who have the misconception that only with branches you can easily find differences between environments.<\/p>\n<p>This could not be further from the truth. You can easily use mature file-diffing utilities to find what is different between environments just by comparing files and folders.<\/p>\n<p>The simplest way is to diff only the settings that are critical to the app.<\/p>\n<pre>\r\nvimdiff envs\/integration-gpu\/settings.yml envs\/integration-non-gpu\/settings.yml\r\n<\/pre>\n<figure id=\"attachment_21891\" aria-describedby=\"caption-attachment-21891\" style=\"width: 1024px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/only-settings-diff.jpg\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/only-settings-diff-1024x558.jpg\" alt=\"GitOps settings diff\" width=\"1024\" height=\"558\" class=\"size-large wp-image-21891\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/only-settings-diff-1024x558.jpg 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/only-settings-diff-300x164.jpg 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/only-settings-diff-768x419.jpg 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/only-settings-diff-20x11.jpg 20w, https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/only-settings-diff.jpg 1203w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" \/><\/a><figcaption id=\"caption-attachment-21891\" class=\"wp-caption-text\">GitOps settings diff<\/figcaption><\/figure>\n<p>And with the help of kustomize, you can compare any number of whole environments for the full picture:<\/p>\n<pre>\r\nkustomize build envs\/qa\/> \/tmp\/qa.yml\r\nkustomize build envs\/staging-us\/ > \/tmp\/staging-us.yml\r\nkustomize build envs\/prod-us\/ > \/tmp\/prod-us.yml\r\nvimdiff \/tmp\/staging-us.yml \/tmp\/qa.yml \/tmp\/prod-us.yml\r\n<\/pre>\n<figure id=\"attachment_21892\" aria-describedby=\"caption-attachment-21892\" style=\"width: 1024px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/environment-diff.jpg\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/environment-diff-1024x520.jpg\" alt=\"GitOps environment diff\" width=\"1024\" height=\"520\" class=\"size-large wp-image-21892\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/environment-diff-1024x520.jpg 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/environment-diff-300x152.jpg 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/environment-diff-768x390.jpg 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/environment-diff-1536x781.jpg 1536w, https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/environment-diff-20x10.jpg 20w, https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/environment-diff.jpg 1883w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" \/><\/a><figcaption id=\"caption-attachment-21892\" class=\"wp-caption-text\">GitOps environment diff<\/figcaption><\/figure>\n<p>I personally don\u2019t see any disadvantage between this method and performing \u201cgit diff\u201d between environment branches.<\/p>\n<h2>How to perform promotions between GitOps environments<\/h2>\n<p>Now that the file structure is clear, we can finally answer the age-old question \u201chow do I promote releases with GitOps\u201d?<\/p>\n<p>Let\u2019s see some promotion scenarios. If you have been paying attention to the file structure, you should already understand how all promotions resolve to simple file copy operations.<\/p>\n<p><strong>Scenario:<\/strong> Promote application version from QA to staging environment in the US:<\/p>\n<ol>\n<li>cp envs\/qa\/version.yml envs\/staging-us\/version.yml<\/li>\n<li>commit\/push changes<\/li>\n<\/ol>\n<p><strong>Scenario:<\/strong> Promote application version from integration testing (GPU) to load testing (GPU) and then to QA. This is a 2 step process<\/p>\n<ol>\n<li>cp envs\/integration-gpu\/version.yml  envs\/load-gpu\/version.yml<\/li>\n<li>commit\/push changes<\/li>\n<li>cp envs\/load-gpu\/version.yml  envs\/qa\/version.yml<\/li>\n<li>commit\/push changes<\/li>\n<\/ol>\n<p><strong>Scenario:<\/strong> Promote an application from prod-eu to prod-us along with the extra configuration. Here we also copy our setting file(s).<\/p>\n<ol>\n<li>cp envs\/prod-eu\/version.yml  envs\/prod-us\/version.yml<\/li>\n<li>cp envs\/prod-eu\/settings.yml  envs\/prod-us\/settings.yml<\/li>\n<li>commit\/push changes<\/li>\n<\/ol>\n<p><strong>Scenario: <\/strong>Make sure that QA has the same replica count as staging-asia<\/p>\n<ol>\n<li>cp envs\/staging-asia\/replicas.yml envs\/qa\/replicas.yml<\/li>\n<li>commit\/push changes<\/li>\n<\/ol>\n<p><strong>Scenario:<\/strong> Backport all settings from qa to integration testing (non-gpu variant)<\/p>\n<ol>\n<li>cp envs\/qa\/settings.yml envs\/integration-non-gpu\/settings.yml<\/li>\n<li>commit\/push changes<\/li>\n<\/ol>\n<p><strong>Scenario:<\/strong> Make a global change to all non-prod environments at once (but see also next section for some discussion on this operation)<\/p>\n<ol>\n<li>Make your change in variants\/non-prod\/non-prod.yml <\/li>\n<li>commit\/push changes<\/li>\n<\/ol>\n<p><strong>Scenario:<\/strong> Add a new configuration file to all US environments (both production and staging).<\/p>\n<ol>\n<li>Add the new manifest in the variants\/us folder<\/li>\n<li>Modify the variants\/us\/kustomization.yml file to include the new manifest<\/li>\n<li>commit\/push changes<\/li>\n<\/ol>\n<p>In general, all promotions are just copy operations. Unlike the environment-per-branch approach, you are now free to promote anything from any environment to any other environment without any fear of taking the wrong changes. Especially when it comes to back-porting configuration, environment-per-folder really shines as you can simply move configuration both \u201cupwards\u201d and \u201cbackwards\u201d even between unrelated environments.<\/p>\n<p>Note that I am using cp operations just for illustration purposes. In a real application, this operation would be performed automatically by your CI system or other orchestration tool. And depending on the environment, you might want to create a Pull Request first instead of directly editing the folder in the main branch.<\/p>\n<h2>Making changes to multiple environments at once<\/h2>\n<p>Several people have asked in the comments of the <a href=\"https:\/\/codefresh.io\/about-gitops\/branches-gitops-environments\/\">first article<\/a> about the use-case of changing multiple environments at once and how to achieve and\/or prevent this scenario.<\/p>\n<p>First of all, we need to define what exactly we mean by \u201cmultiple\u201d environments. We can assume the following 2 cases.<\/p>\n<ol>\n<li>Changing multiple environments at once that are on the same \u201clevel.\u201d As an example, you want to make a change that affects prod-us, prod-eu and prod-asia at the same time<\/li>\n<li>Changing multiple environments at once that are NOT on the same level. As an example, you want to make a change to \u201cintegration\u201d and \u201cstaging-eu\u201d at the same time<\/li>\n<\/ol>\n<p>The first case is a valid scenario, and we will cover this below. However, I consider the second scenario an anti-pattern. The whole point of having different environments is to be able to release things in a gradual way and promote a change from one environment to the next. So if you find yourself deploying the same change in environments of different importance, ask yourself if this is really needed and why.<\/p>\n<p>For the valid scenario of deploying a single change to multiple \u201csimilar\u201d environments, there are two strategies:<\/p>\n<ol>\n<li>If you are absolutely certain that the change is \u201csafe\u201d and you want it to reach all environments at once, you can make that change in the appropriate variant (or respective folders). For example, if you commit\/push a change in the variants\/non-prod folder then all non-production environments will get this change at the same time. I am personally <strong>against <\/strong>this approach because several changes look \u201csafe\u201d in theory but can be problematic in practice<\/li>\n<li>The preferable approach is to apply the change to each individual folder and then move it to the \u201cparent\u201d variant when it is live on all environments.<\/li>\n<\/ol>\n<p>Let\u2019s take an example. We want to make a change that affects all EU environments (e.g. a <a href=\"https:\/\/gdpr-info.eu\/\">GDPR feature<\/a>). The naive way would be to commit\/push the configuration change directly to variants\/eu folder. This would indeed affect all EU environments (prod-eu and staging-eu). However this is a bit risky, because if the deployment fails, you have just brought down a production environment.<\/p>\n<p>The suggested approach is the following:<\/p>\n<ol>\n<li>Make the change to envs\/staging-eu first<\/li>\n<li>Then make the same change to envs\/prod-eu<\/li>\n<li>Finally, delete the change from both environments and add it in variants\/eu (in a single commit\/push action).<\/li>\n<\/ol>\n<figure id=\"attachment_21893\" aria-describedby=\"caption-attachment-21893\" style=\"width: 1024px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/gradual-promotion.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/gradual-promotion-1024x681.png\" alt=\"Gradual GitOps promotion\" width=\"1024\" height=\"681\" class=\"size-large wp-image-21893\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/gradual-promotion-1024x681.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/gradual-promotion-300x199.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/gradual-promotion-768x511.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/gradual-promotion-1536x1021.png 1536w, https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/gradual-promotion-20x13.png 20w, https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/gradual-promotion.png 1548w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" \/><\/a><figcaption id=\"caption-attachment-21893\" class=\"wp-caption-text\">Gradual GitOps promotion<\/figcaption><\/figure>\n<p>You might recognize this pattern from gradual <a href=\"https:\/\/databaserefactoring.com\/\">database refactorings<\/a>. The final commit is \u201ctransitional\u201d in the sense that it doesn\u2019t really affect any environments in any way. Kustomize will create the exact same definition in both cases. Your GitOps controller shouldn\u2019t find any differences at all.<\/p>\n<p>The advantages of this approach are of course the easy way to rollback\/revert the change as you move it through environments. The disadvantage is the increased effort (and commits) you need to promote the change to all environments, but I believe that the effort outweighs the risks.<\/p>\n<p>If you adopt this approach, it means that you <strong>never <\/strong>apply new changes to the base folder directly. If you want a change to happen to all environments, you first apply the change to individual environments and\/or variants and then backport it to the base folder while simultaneously removing it from all downstream folders.<\/p>\n<h2>The advantages of the \u201cenvironment-per-folder\u201d approach<\/h2>\n<p>Now that we have analyzed all the inner workings of the \u201cenvironment-per-folder\u201d approach, it is time to explain why it is better than the \u201cenvironment-per-branch\u201d approach. If you have been paying attention to the previous sections, you should already understand how the \u201cenvironment-per-folder\u201d approach directly avoids all the problems analyzed in the <a href=\"https:\/\/codefresh.io\/about-gitops\/branches-gitops-environments\/\">previous article<\/a>. <\/p>\n<p>The most glaring issues with environment branches is the order of commits and the danger of bringing unwanted changes when you merge from one environment to another. With the folder approach, this problem is completely eliminated:<\/p>\n<ol>\n<li>The order of commits on the repo is now irrelevant. When you copy a file from one folder to the next, you don\u2019t care about its commit history, just its content<\/li>\n<li>By only copying files around, you only take exactly what you need and nothing else. When you copy envs\/qa\/version.yml to envs\/staging-asia\/version.yml you can be certain that you only promote the container image and nothing else. If somebody else has changed the replicas in the QA environment in the meantime, it doesn\u2019t affect your promotion action.<\/li>\n<li>You don\u2019t need to use git cherry-picks or any other advanced git method to promote releases. You only copy files around and have access to the mature ecosystem of utilities for file processing.<\/li>\n<li>You are free to take any change from any environment to either an upstream or downstream environment without any constraints about the correct \u201corder\u201d of environments. If for example you want to backport your settings from production US to staging US, you can do a simple copy operation of <code>envs\/prod-us\/settings.yml<\/code> to <code>envs\/staging-us\/settings.yml<\/code> without the fear that you might take inadvertently unrelated hotfixes that were supposed to be only in production.<\/li>\n<li>You can easily use file diff operations to understand what is different between environments in all directions (both from source and target environments and vice versa)<\/li>\n<\/ol>\n<p>I consider these advantages very important for any non-trivial application, and I bet that several \u201cfailed deployments\u201d in big organizations could be directly or indirectly attributed to the problematic environment-per-branch model.<\/p>\n<p>The second problem mentioned in the previous article was the presence of configuration drift when you merge a branch to the next environment. The reason for this is that when you do a \u201cgit merge,\u201d git only notifies you about the changes it will bring, and it doesn\u2019t say anything about what changes are already in the target branch.<\/p>\n<p>Again this problem is completely eliminated with folders. As we said already, file diff operations have no concept of \u201cdirection.\u201d You can copy any setting from any environment either upwards or downwards, and if you do a diff operation on the files, you will see all changes between environments regardless of their upstream\/downstream position.<\/p>\n<p>The last point about environment branches was the linear complexity of branches as the number of environments grows. With 5 environments, you need to juggle changes between 5 branches, and with 20 environments, you need to have 20 branches. Moving a release correctly between a large number of branches is a cumbersome process, and in the case of production environments, it is a recipe for disaster.<\/p>\n<p>With the folder approach, the number of branches is not only static but it is exactly 1. If you have 5 environments you manage them all with your \u201cmain\u201d branch, and if you need more environments, you only add extra folders. If you have 20 environments, you still need a single Git branch. Getting a centralized view on what is deployed where is trivial when you have a single branch.<\/p>\n<h2>Using Helm with GitOps environments<\/h2>\n<p>If you don\u2019t use Kustomize but prefer Helm instead, it is also possible to create a hierarchy of folders with \u201ccommon\u201d stuff for all environments, specific features\/mixins\/components, and final folders specific to each environment.<\/p>\n<p>Here is how the folder structure would look like<\/p>\n<pre>\r\nchart\/\r\n  [...chart files here..]\r\ncommon\/\r\n  values-common.yml\r\nvariants\/\r\n  prod\/\r\n     values-prod.yml\r\n  non-prod\/\r\n    Values-non-prod.yml\r\n  [...other variants\u2026]\r\n envs\/\r\n     prod-eu\/\r\n           values-env-default.yaml\r\n           values-replicas.yaml\r\n           values-version.yaml\r\n           values-settings.yaml\r\n   [..other environments\u2026]\r\n<\/pre>\n<p>Again you need to spend some time to examine your application properties and decide how to split them into different value files for optimal promotion speed.<\/p>\n<p>Other than this, most of the processes are the same when it comes to environment promotion.<\/p>\n<p><strong>Scenario: <\/strong>Promote application version from  QA to staging environment in the US:<\/p>\n<ol>\n<li>cp envs\/qa\/values-version.yml envs\/staging-us\/values-version.yml<\/li>\n<li>commit\/push changes<\/li>\n<\/ol>\n<p><strong>Scenario:<\/strong> Promote application version from integration testing (GPU) to load testing (GPU) and then to QA. This is a 2 step process<\/p>\n<ol>\n<li>cp envs\/integration-gpu\/values-version.yml  envs\/load-gpu\/values-version.yml<\/li>\n<li>commit\/push changes<\/li>\n<li>cp envs\/load-gpu\/values-version.yml  envs\/qa\/values-version.yml<\/li>\n<li>commit\/push changes<\/li>\n<\/ol>\n<p><strong>Scenario:<\/strong> Promote an application from prod-eu to prod-us along with the extra configuration. Here we also copy our setting file(s).<\/p>\n<ol>\n<li>cp envs\/prod-eu\/values-version.yml  envs\/prod-us\/values-version.yml<\/li>\n<li>cp envs\/prod-eu\/values-settings.yml  envs\/prod-us\/values-settings.yml<\/li>\n<li>commit\/push changes<\/li>\n<\/ol>\n<p>It is also critical to understand how Helm (or your GitOps agent which handles Helm) works with multiple value files and the order in which they override each other.<\/p>\n<p>If you want to preview one of your environments, instead of \u201ckustomize build\u201d you can use the following command <\/p>\n<pre>\r\nhelm template chart\/ --values common\/values-common.yaml --values variants\/prod\/values-prod.yaml \u2013values envs\/prod-eu\/values-env-default.yml \u2013values envs\/prod-eu\/values-replicas.yml \u2013values envs\/prod-eu\/values-version.yml \u2013values envs\/prod-eu\/values-settings.yml\r\n<\/pre>\n<p>You can see that Helm is a bit more cumbersome than Kustomize, if you have a large number of variants or files in each environment folder.<\/p>\n<h2>The \u201cenvironment-per-git-repo\u201d approach<\/h2>\n<p>When I talk with big organizations about the folder approach, one of the first objections I see is that people (especially security teams) don\u2019t like to see a single branch in a single Git repository that contains both prod and non-prod environments.<\/p>\n<p>This is an understandable objection and arguably can be the single weak point of the folder approach against the \u201cenvironment-per-branch\u201d paradigm. After all, it is much easier to secure individual branches in a Git repository instead of folders in a single branch.<\/p>\n<p>This problem can be easily solved with automation, validation checks, or even manual approvals if you think it is critical for your organization. I want to stress again that I only use \u201ccp\u201d in the file operations for promoting releases just for illustration purposes. It doesn&#8217;t mean that an actual human should run cp manually in an interactive terminal when a promotion happens.<\/p>\n<p>Ideally you should have an automated system that copies files around and commits\/pushes them. This can be your Continuous Integration (CI) system or other platform that deals with your software lifecycle. And if you still have humans that make the changes themselves, they should never commit to \u201cmain\u201d directly. They should open a Pull Request instead. Then you should have a proper workflow that checks that Pull Request before merging.<\/p>\n<p>I realize however that some organizations are particularly sensitive to security issues and they prefer a bulletproof approach when it comes to Git protection. For these organizations, you can employ 2 Git repositories. One has the base configuration, all prod variants, and all prod environments (and everything else related to production) while the second Git repository has all non-production stuff.<\/p>\n<p>This approach makes promotions a bit harder, as now you need to checkout 2 git repositories before doing any promotion. On the other hand, it allows your security team to place extra security constraints to the \u201cproduction\u201d Git repository, and you still have a static number of Git repositories (exactly 2) regardless of the amount of environments you deploy to.<\/p>\n<p>I personally consider this approach an overkill that, at least to me, shows a lack of trust against developers and operators. The discussion on whether or not people should have direct access to production environments is a complex one and probably deserves a blog post on its own.<\/p>\n<h2>Embrace folders and forget branches<\/h2>\n<p>We hope that with this blog post we addressed all the questions that arose from the \u201c<a href=\"https:\/\/codefresh.io\/about-gitops\/branches-gitops-environments\/\">don\u2019t use branches for environments<\/a>\u201d article and you now have a good understanding about the benefits of the folder approach and why you should use it.<\/p>\n<p>If you have other interesting use cases or have extra questions on the subject of organizing your GitOps environments, please ask in the comments section.<\/p>\n<p>Happy GitOps deployments!<\/p>\n<input class=\"fooboxshare_post_id\" type=\"hidden\" value=\"21886\"\/>","protected":false},"excerpt":{"rendered":"<p>Two of the most important questions that people ask themselves on day 2 after adopting GitOps are: How should I represent different environments on Git? How should I handle promoting releases between environments? In the previous article of the series, I focused on what NOT to do and explained why using Git branches for different &hellip; <a href=\"https:\/\/codefresh.io\/about-gitops\/how-to-model-your-gitops-environments-and-promote-releases-between-them\/\">Read more<\/a><\/p>\n","protected":false},"author":62,"featured_media":21889,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[3120,5467,5703,5722,1657,1538,6],"tags":[24,885,994,4322,5725,5740],"yoast_head":"<!-- This site is optimized with the Yoast SEO Premium plugin v17.9 (Yoast SEO v18.4.1) - https:\/\/yoast.com\/wordpress\/plugins\/seo\/ -->\n<title>How to Model Your Gitops Environments<\/title>\n<meta name=\"description\" content=\"Learn how to model your GitOps environments using different folders on the same Git branch, and how to handle environment promotion.\" \/>\n<meta name=\"robots\" content=\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\" \/>\n<link rel=\"canonical\" href=\"https:\/\/codefresh.io\/about-gitops\/how-to-model-your-gitops-environments-and-promote-releases-between-them\/\" \/>\n<meta property=\"og:locale\" content=\"en_US\" \/>\n<meta property=\"og:type\" content=\"article\" \/>\n<meta property=\"og:title\" content=\"How to Model Your Gitops Environments and Promote Releases between Them\" \/>\n<meta property=\"og:description\" content=\"Learn how to model your GitOps environments using different folders on the same Git branch, and how to handle environment promotion.\" \/>\n<meta property=\"og:url\" content=\"https:\/\/codefresh.io\/about-gitops\/how-to-model-your-gitops-environments-and-promote-releases-between-them\/\" \/>\n<meta property=\"og:site_name\" content=\"Codefresh\" \/>\n<meta property=\"article:publisher\" content=\"https:\/\/www.facebook.com\/codefresh.io\" \/>\n<meta property=\"article:published_time\" content=\"2022-03-23T11:22:55+00:00\" \/>\n<meta property=\"og:image\" content=\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/Blog_Header_GitOps_Environment_Linkedin.png\" \/>\n\t<meta property=\"og:image:width\" content=\"2400\" \/>\n\t<meta property=\"og:image:height\" content=\"1254\" \/>\n\t<meta property=\"og:image:type\" content=\"image\/png\" \/>\n<meta name=\"twitter:card\" content=\"summary_large_image\" \/>\n<meta name=\"twitter:description\" content=\"Learn how to model your GitOps environments using different folders on the same Git branch, and how to handle environment promotion.\" \/>\n<meta name=\"twitter:creator\" content=\"@codefresh\" \/>\n<meta name=\"twitter:site\" content=\"@codefresh\" \/>\n<meta name=\"twitter:label1\" content=\"Written by\" \/>\n\t<meta name=\"twitter:data1\" content=\"Kostis Kapelonis\" \/>\n\t<meta name=\"twitter:label2\" content=\"Est. reading time\" \/>\n\t<meta name=\"twitter:data2\" content=\"21 minutes\" \/>\n<script type=\"application\/ld+json\" class=\"yoast-schema-graph\">{\"@context\":\"https:\/\/schema.org\",\"@graph\":[{\"@type\":\"Organization\",\"@id\":\"https:\/\/codefresh.io\/#organization\",\"name\":\"Codefresh\",\"url\":\"https:\/\/codefresh.io\/\",\"sameAs\":[\"https:\/\/www.facebook.com\/codefresh.io\",\"https:\/\/www.linkedin.com\/company\/codefresh\",\"https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg\",\"https:\/\/twitter.com\/codefresh\"],\"logo\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#logo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"width\":800,\"height\":800,\"caption\":\"Codefresh\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/#logo\"}},{\"@type\":\"WebSite\",\"@id\":\"https:\/\/codefresh.io\/#website\",\"url\":\"https:\/\/codefresh.io\/\",\"name\":\"Codefresh\",\"description\":\"\",\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"potentialAction\":[{\"@type\":\"SearchAction\",\"target\":{\"@type\":\"EntryPoint\",\"urlTemplate\":\"https:\/\/codefresh.io\/?s={search_term_string}\"},\"query-input\":\"required name=search_term_string\"}],\"inLanguage\":\"en-US\"},{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/about-gitops\/how-to-model-your-gitops-environments-and-promote-releases-between-them\/#primaryimage\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/Blog_Header_GitOps_Environment_Linkedin.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/Blog_Header_GitOps_Environment_Linkedin.png\",\"width\":2400,\"height\":1254},{\"@type\":\"WebPage\",\"@id\":\"https:\/\/codefresh.io\/about-gitops\/how-to-model-your-gitops-environments-and-promote-releases-between-them\/#webpage\",\"url\":\"https:\/\/codefresh.io\/about-gitops\/how-to-model-your-gitops-environments-and-promote-releases-between-them\/\",\"name\":\"How to Model Your Gitops Environments\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/#website\"},\"primaryImageOfPage\":{\"@id\":\"https:\/\/codefresh.io\/about-gitops\/how-to-model-your-gitops-environments-and-promote-releases-between-them\/#primaryimage\"},\"datePublished\":\"2022-03-23T11:22:55+00:00\",\"dateModified\":\"2022-03-23T11:22:55+00:00\",\"description\":\"Learn how to model your GitOps environments using different folders on the same Git branch, and how to handle environment promotion.\",\"breadcrumb\":{\"@id\":\"https:\/\/codefresh.io\/about-gitops\/how-to-model-your-gitops-environments-and-promote-releases-between-them\/#breadcrumb\"},\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"ReadAction\",\"target\":[\"https:\/\/codefresh.io\/about-gitops\/how-to-model-your-gitops-environments-and-promote-releases-between-them\/\"]}]},{\"@type\":\"BreadcrumbList\",\"@id\":\"https:\/\/codefresh.io\/about-gitops\/how-to-model-your-gitops-environments-and-promote-releases-between-them\/#breadcrumb\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"name\":\"Home\",\"item\":\"https:\/\/codefresh.io\/\"},{\"@type\":\"ListItem\",\"position\":2,\"name\":\"How to Model Your Gitops Environments and Promote Releases between Them\"}]},{\"@type\":\"Article\",\"@id\":\"https:\/\/codefresh.io\/about-gitops\/how-to-model-your-gitops-environments-and-promote-releases-between-them\/#article\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/about-gitops\/how-to-model-your-gitops-environments-and-promote-releases-between-them\/#webpage\"},\"author\":{\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87\"},\"headline\":\"How to Model Your Gitops Environments and Promote Releases between Them\",\"datePublished\":\"2022-03-23T11:22:55+00:00\",\"dateModified\":\"2022-03-23T11:22:55+00:00\",\"mainEntityOfPage\":{\"@id\":\"https:\/\/codefresh.io\/about-gitops\/how-to-model-your-gitops-environments-and-promote-releases-between-them\/#webpage\"},\"wordCount\":3916,\"commentCount\":13,\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/about-gitops\/how-to-model-your-gitops-environments-and-promote-releases-between-them\/#primaryimage\"},\"thumbnailUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/Blog_Header_GitOps_Environment.png\",\"keywords\":[\"Containers\",\"kubernetes tutorial\",\"helm\",\"GitOps\",\"Kustomize\",\"Multiple Environments\"],\"articleSection\":[\"Continuous Deployment\/Delivery\",\"Devops\",\"GitOps\",\"Argo Platform\",\"Kubernetes Tutorials\",\"DevOps Tutorials\",\"How Tos\"],\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"CommentAction\",\"name\":\"Comment\",\"target\":[\"https:\/\/codefresh.io\/about-gitops\/how-to-model-your-gitops-environments-and-promote-releases-between-them\/#respond\"]}]},{\"@type\":\"Person\",\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87\",\"name\":\"Kostis Kapelonis\",\"image\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#personlogo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png\",\"caption\":\"Kostis Kapelonis\"},\"description\":\"Kostis is a software engineer\/technical-writer dual class character. He lives and breathes automation, good testing practices and stress-free deployments with GitOps.\",\"url\":\"https:\/\/codefresh.io\/author\/kostiscodefresh-io\/\"}]}<\/script>\n<!-- \/ Yoast SEO Premium plugin. -->","yoast_head_json":{"title":"How to Model Your Gitops Environments","description":"Learn how to model your GitOps environments using different folders on the same Git branch, and how to handle environment promotion.","robots":{"index":"index","follow":"follow","max-snippet":"max-snippet:-1","max-image-preview":"max-image-preview:large","max-video-preview":"max-video-preview:-1"},"canonical":"https:\/\/codefresh.io\/about-gitops\/how-to-model-your-gitops-environments-and-promote-releases-between-them\/","og_locale":"en_US","og_type":"article","og_title":"How to Model Your Gitops Environments and Promote Releases between Them","og_description":"Learn how to model your GitOps environments using different folders on the same Git branch, and how to handle environment promotion.","og_url":"https:\/\/codefresh.io\/about-gitops\/how-to-model-your-gitops-environments-and-promote-releases-between-them\/","og_site_name":"Codefresh","article_publisher":"https:\/\/www.facebook.com\/codefresh.io","article_published_time":"2022-03-23T11:22:55+00:00","og_image":[{"width":2400,"height":1254,"url":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/Blog_Header_GitOps_Environment_Linkedin.png","type":"image\/png"}],"twitter_card":"summary_large_image","twitter_description":"Learn how to model your GitOps environments using different folders on the same Git branch, and how to handle environment promotion.","twitter_creator":"@codefresh","twitter_site":"@codefresh","twitter_misc":{"Written by":"Kostis Kapelonis","Est. reading time":"21 minutes"},"schema":{"@context":"https:\/\/schema.org","@graph":[{"@type":"Organization","@id":"https:\/\/codefresh.io\/#organization","name":"Codefresh","url":"https:\/\/codefresh.io\/","sameAs":["https:\/\/www.facebook.com\/codefresh.io","https:\/\/www.linkedin.com\/company\/codefresh","https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg","https:\/\/twitter.com\/codefresh"],"logo":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#logo","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","width":800,"height":800,"caption":"Codefresh"},"image":{"@id":"https:\/\/codefresh.io\/#logo"}},{"@type":"WebSite","@id":"https:\/\/codefresh.io\/#website","url":"https:\/\/codefresh.io\/","name":"Codefresh","description":"","publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"potentialAction":[{"@type":"SearchAction","target":{"@type":"EntryPoint","urlTemplate":"https:\/\/codefresh.io\/?s={search_term_string}"},"query-input":"required name=search_term_string"}],"inLanguage":"en-US"},{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/about-gitops\/how-to-model-your-gitops-environments-and-promote-releases-between-them\/#primaryimage","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/Blog_Header_GitOps_Environment_Linkedin.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/Blog_Header_GitOps_Environment_Linkedin.png","width":2400,"height":1254},{"@type":"WebPage","@id":"https:\/\/codefresh.io\/about-gitops\/how-to-model-your-gitops-environments-and-promote-releases-between-them\/#webpage","url":"https:\/\/codefresh.io\/about-gitops\/how-to-model-your-gitops-environments-and-promote-releases-between-them\/","name":"How to Model Your Gitops Environments","isPartOf":{"@id":"https:\/\/codefresh.io\/#website"},"primaryImageOfPage":{"@id":"https:\/\/codefresh.io\/about-gitops\/how-to-model-your-gitops-environments-and-promote-releases-between-them\/#primaryimage"},"datePublished":"2022-03-23T11:22:55+00:00","dateModified":"2022-03-23T11:22:55+00:00","description":"Learn how to model your GitOps environments using different folders on the same Git branch, and how to handle environment promotion.","breadcrumb":{"@id":"https:\/\/codefresh.io\/about-gitops\/how-to-model-your-gitops-environments-and-promote-releases-between-them\/#breadcrumb"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https:\/\/codefresh.io\/about-gitops\/how-to-model-your-gitops-environments-and-promote-releases-between-them\/"]}]},{"@type":"BreadcrumbList","@id":"https:\/\/codefresh.io\/about-gitops\/how-to-model-your-gitops-environments-and-promote-releases-between-them\/#breadcrumb","itemListElement":[{"@type":"ListItem","position":1,"name":"Home","item":"https:\/\/codefresh.io\/"},{"@type":"ListItem","position":2,"name":"How to Model Your Gitops Environments and Promote Releases between Them"}]},{"@type":"Article","@id":"https:\/\/codefresh.io\/about-gitops\/how-to-model-your-gitops-environments-and-promote-releases-between-them\/#article","isPartOf":{"@id":"https:\/\/codefresh.io\/about-gitops\/how-to-model-your-gitops-environments-and-promote-releases-between-them\/#webpage"},"author":{"@id":"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87"},"headline":"How to Model Your Gitops Environments and Promote Releases between Them","datePublished":"2022-03-23T11:22:55+00:00","dateModified":"2022-03-23T11:22:55+00:00","mainEntityOfPage":{"@id":"https:\/\/codefresh.io\/about-gitops\/how-to-model-your-gitops-environments-and-promote-releases-between-them\/#webpage"},"wordCount":3916,"commentCount":13,"publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"image":{"@id":"https:\/\/codefresh.io\/about-gitops\/how-to-model-your-gitops-environments-and-promote-releases-between-them\/#primaryimage"},"thumbnailUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/Blog_Header_GitOps_Environment.png","keywords":["Containers","kubernetes tutorial","helm","GitOps","Kustomize","Multiple Environments"],"articleSection":["Continuous Deployment\/Delivery","Devops","GitOps","Argo Platform","Kubernetes Tutorials","DevOps Tutorials","How Tos"],"inLanguage":"en-US","potentialAction":[{"@type":"CommentAction","name":"Comment","target":["https:\/\/codefresh.io\/about-gitops\/how-to-model-your-gitops-environments-and-promote-releases-between-them\/#respond"]}]},{"@type":"Person","@id":"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87","name":"Kostis Kapelonis","image":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#personlogo","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png","caption":"Kostis Kapelonis"},"description":"Kostis is a software engineer\/technical-writer dual class character. He lives and breathes automation, good testing practices and stress-free deployments with GitOps.","url":"https:\/\/codefresh.io\/author\/kostiscodefresh-io\/"}]}},"acf":[],"_links":{"self":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/21886"}],"collection":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/users\/62"}],"replies":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/comments?post=21886"}],"version-history":[{"count":3,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/21886\/revisions"}],"predecessor-version":[{"id":21896,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/21886\/revisions\/21896"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media\/21889"}],"wp:attachment":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media?parent=21886"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/categories?post=21886"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/tags?post=21886"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}