{"id":2343,"date":"2019-10-17T17:31:21","date_gmt":"2019-10-17T17:31:21","guid":{"rendered":"https:\/\/codefresh.io\/?p=2343"},"modified":"2019-10-18T14:45:24","modified_gmt":"2019-10-18T14:45:24","slug":"java_docker_pipeline","status":"publish","type":"post","link":"https:\/\/codefresh.io\/docker-tutorial\/java_docker_pipeline\/","title":{"rendered":"Crafting the perfect Java Docker build flow"},"content":{"rendered":"<h2>TL;DR<\/h2>\n<blockquote><p>\n<em>What is the bare minimum you need to <strong>build<\/strong>, <strong>test<\/strong> and <strong>run<\/strong> your Java application in Docker container?<\/em><\/p>\n<p><strong>The recipe:<\/strong> Create a separate Docker image for each step and optimize the way you are running it.\n<\/p><\/blockquote>\n<h2 id=\"introduction\">Introduction<\/h2>\n<p>I started working\u00a0with Java in 1998, and for a long time, it was my main programming language. It was a long love\u2013hate relationship.<\/p>\n<p>During my work career, I wrote a lot of code in Java. Despite that fact, I don&#8217;t think Java is usually the right choice for microservices.<\/p>\n<p>But, sometimes you have to work with Java. Maybe Java is your favorite language and you do not want to learn a new one, or you have a legacy codebase that you need to maintain, or your company decided on Java and you have no other option.<\/p>\n<p>Whatever reason, if you have to <em><strong>marry Java with Docker<\/strong><\/em>, you better <em><strong>do it properly<\/strong><\/em>.<\/p>\n<p>In this post, I will show you how to\u00a0create an effective Java-Docker build pipeline to consistently produce small, efficient, and secure Docker images.<\/p>\n<p>Spoiler alert, it\u2019s gonna be a long article. To follow along, please <strong><a href=\"https:\/\/g.codefresh.io\/signup?utm_source=Blog&amp;utm_medium=Post&amp;utm_campaign=CraftingT\">create a free Codefresh account<\/a><\/strong> by adding one of your repos, and start building, testing and deploying Docker images instantly.<\/p>\n<h2 id=\"attention\">Be careful<\/h2>\n<p>There are plenty of <em>&#8220;Docker for Java developers&#8221;<\/em> tutorials out there, that unintentionally encourage some Docker bad practices.<\/p>\n<p>For example:<\/p>\n<ul>\n<li><a href=\"http:\/\/sparkjava.com\/tutorials\/docker\">Spark and Docker tutorial<\/a><\/li>\n<li><a href=\"https:\/\/examples.javacodegeeks.com\/devops\/docker\/introduction-docker-java-developers\/\">Introducing Docker for Java Developers<\/a><\/li>\n<li><a href=\"http:\/\/www.developer.com\/java\/data\/using-java-with-docker-engine.html\">Using Java with Docker Engine<\/a><\/li>\n<li>and others &#8230;<\/li>\n<\/ul>\n<p>These are examples of <em><strong>not so good<\/strong><\/em> tutorials. Following these tutorials, you will get <em>huge<\/em> Docker images and <em>long build<\/em> times.<\/p>\n<p>For the current demo project,\u00a0the first two tutorials took around 15 minutes to build (first build) and produced images of 1.3GB size each.<\/p>\n<blockquote><p><em>Make yourself a favor and do not follow these tutorials!<\/em><\/p><\/blockquote>\n<h2 id=\"what-should-you-know-about-docker-\">What should you know about Docker?<\/h2>\n<p>Developers new to Docker are often tempted to think of it as just another VM. Instead, think of Docker as a &#8220;child process&#8221;. The files and packages needed for an entire VM are different from those needed\u00a0by just another process running a dev machine. Docker is even better than a child process because it allows better isolation and environmental control. Trying to reuse VM practices on Docker containers is actually the number 1 <a href=\"https:\/\/codefresh.io\/containers\/docker-anti-patterns\/\">Docker anti-pattern<\/a> that I see in companies trying to adopt docker.<\/p>\n<p>If you&#8217;re new to Docker, I suggest reading this <a href=\"https:\/\/docs.docker.com\/engine\/understanding-docker\/\">Understanding Docker<\/a> article. Docker isn&#8217;t so complex than any developer shouldn&#8217;t be able to understand how it\u00a0works. You should also understand that using Docker is actually two completely different and unrelated things: Using Docker as a deployment artifact and using docker in a CI\/CD pipeline in order to package all the build tools needed by an application.<\/p>\n<h2 id=\"running-java-application\">Dockerizing a Java application<\/h2>\n<h3>What files need to be\u00a0included in a\u00a0Java Application&#8217;s Docker image?<\/h3>\n<p>Since Docker containers are\u00a0just isolated processes, your Java Docker image should only contain the files required to run your\u00a0application.<\/p>\n<p><em>What are these files?<\/em><\/p>\n<p>It starts with a\u00a0Java Runtime Environment (<strong>JRE<\/strong>). <strong>JRE<\/strong> is a software package, that has everything\u00a0required to run a Java program. It includes an implementation of the Java Virtual Machine (<strong>JVM<\/strong>) with an implementation of the <em>Java Class Library<\/em>.<\/p>\n<p>I recommend using <a href=\"http:\/\/openjdk.java.net\/\">OpenJDK<\/a> JRE. OpenJDK is licensed under <a href=\"https:\/\/en.wikipedia.org\/wiki\/GNU_General_Public_License\">GPL<\/a> with <a href=\"http:\/\/www.gnu.org\/software\/classpath\/license.html\">Classpath Exception<\/a>. The <em>Classpath Exception<\/em> part is important. This license allows using OpenJDK with any software license, not just the GPL. In particular, you can use OpenJDK in\u00a0proprietary software without disclosing your\u00a0code.<\/p>\n<p>Before using Oracle&#8217;s JDK\/JRE, please read the following post: &#8220;<a href=\"http:\/\/blog.takipi.com\/running-java-on-docker-youre-breaking-the-law\/\">Running Java on Docker? You\u2019re Breaking the Law.<\/a>&#8221;<\/p>\n<p>Since it&#8217;s rare for Java applications to be developed using only the standard library, you most likely need to also add 3rd party Java libraries. Then add the application compiled bytecode as plain<em> Java Class<\/em> files or packaged into\u00a0<em>JAR<\/em> archives. And, if you are using native code, you will need to add the corresponding native libraries\/packages too.<\/p>\n<h3>Choosing a base Docker image for a Java Application<\/h3>\n<p>In order to choose the base Docker image, you need to answer the following questions:<\/p>\n<ul>\n<li><em>What native packages do you need for your Java application? <\/em><\/li>\n<li><em>Should you choose Ubuntu or Debian (or even Alpine) as your base image?<\/em><\/li>\n<li><em>What is your strategy for patching security holes, including packages you are not using at all?<\/em><\/li>\n<li><em>Do you mind paying extra (money and time) for network traffic and storage of unused files?<\/em><\/li>\n<\/ul>\n<p>Some might say: <em>\u201cbut, if all your images share the same Docker layers, you only download them once, right?<\/em>\u201d<\/p>\n<p>That&#8217;s<em> true in theory<\/em>,\u00a0but in\u00a0reality is often\u00a0very different.<\/p>\n<p>Usually, you have lots of different images: some you built recently, others a long time ago, others you pull\u00a0from DockerHub. All these images do not share the same base image or version. You need to invest a lot of time to align these\u00a0images to share the\u00a0same base image and then keep these images up-to-date (for no reason).<\/p>\n<p>Some might say: <em>\u201cbut, who cares about image size? we download them just once and run forever\u201d<\/em>.<\/p>\n<p>Docker image size is actually very important.<\/p>\n<p>The size has an\u00a0impact on \u2026<\/p>\n<ul>\n<li><strong><em>network latency<\/em><\/strong> &#8211; need to transfer Docker image\u00a0over\u00a0the web<\/li>\n<li><strong><em>storage<\/em><\/strong> &#8211; need to store all these bits\u00a0somewhere<\/li>\n<li><strong><em>service availability and elasticity<\/em><\/strong> &#8211; when using a Docker scheduler, like Kubernetes, Swarm, Nomad, DC\/OS or other (the scheduler can move containers between hosts)<\/li>\n<li><strong><em>security<\/em><\/strong> &#8211; do you really, I mean <strong>really<\/strong> need the\u00a0<code>libpng<\/code> package with all its <a href=\"https:\/\/www.cvedetails.com\/vulnerability-list\/vendor_id-7294\/Libpng.html\">CVE vulnerabilities<\/a>\u00a0for your Java application?<\/li>\n<li><strong><em>development agility<\/em><\/strong> &#8211; small Docker images == faster build time and faster deployment<\/li>\n<\/ul>\n<p>Without being careful, Java Docker images tend to grow to enormous sizes. I\u2019ve seen 3GB\u00a0Java images where\u00a0the required code and JAR libraries only take 150MBs.<\/p>\n<p>Consider using <a href=\"https:\/\/hub.docker.com\/_\/alpine\/\">Alpine Linux image<\/a>, which is only 5MBs, as a base Docker image. Lots of \u201cOfficial Docker images\u201d have an Alpine-based flavor.<\/p>\n<p><strong>Note<\/strong>: Many, but not all Linux packages have versions compiled with <code>musl libc<\/code> C runtime library. Sometimes you want to use a package that is compiled with <code>glibc<\/code> (GNU C runtime library). The <a href=\"https:\/\/hub.docker.com\/r\/frolvlad\/alpine-glibc\/\">frolvlad\/alpine-glibc<\/a> image based on Alpine Linux image contains <code>glibc<\/code> to\u00a0enable proprietary projects, compiled against <code>glibc<\/code> (e.g. OracleJDK, Anaconda).<\/p>\n<h3>Choosing the right Java Application server<\/h3>\n<p>Frequently, you also need to expose some kind of interface to reach your <a href=\"https:\/\/codefresh.io\/docker-tutorial\/dockerize-java-application\/\">Java application<\/a> that runs in Docker a container.<\/p>\n<p>When you deploy Java applications with <a href=\"https:\/\/codefresh.io\/docs\/docs\/docker-registries\/codefresh-registry\/\">Docker containers<\/a>, the default Java deployment model changes.<\/p>\n<p>Originally, Java server-side deployment assumes you have pre-configured a Java Web Server (Tomcat, WebLogic, JBoss, or other) and you are deploying an application <strong>WAR<\/strong> (Web Archive) packaged Java application to this server and run it together with other applications, deployed on the same server.<\/p>\n<p>Lots of tools are developed around this concept, allowing you to update running applications without stopping the Java Application server, route traffic to the new application, resolve possible class loading conflicts and more.<\/p>\n<p>With Docker-based deployments, you do not need these tools anymore, you don&#8217;t even need the\u00a0fat enterprise-ready Java Application servers. The only thing you need is a stable and scalable network server that can serve your API over HTTP\/TCP or other protocol of your choice. Search Google for <a href=\"https:\/\/www.google.com\/search?q=&quot;embedded java server&quot;\"><em>\u201cembedded Java server\u201d<\/em><\/a>\u00a0and take one that you like most.<\/p>\n<p>For this demo, I forked <a href=\"https:\/\/github.com\/khoubyari\/spring-boot-rest-example\">Spring Boot&#8217;s REST example<\/a> and modified it a bit. The demo uses <a href=\"https:\/\/projects.spring.io\/spring-boot\/\">Spring Boot<\/a>\u00a0with an embedded <a href=\"http:\/\/tomcat.apache.org\/\">Tomcat<\/a> server. Here&#8217;s my <a href=\"https:\/\/github.com\/alexei-led\/spring-boot-rest-example\">fork\u00a0on GitHub<\/a> (<code>blog<\/code>\u00a0branch).<\/p>\n<p>The Codefresh documentation also includes a <a href=\"https:\/\/codefresh.io\/docs\/docs\/learn-by-example\/java\/spring-boot-2\/\">complete Maven Spring boot example<\/a> as well as a <a href=\"https:\/\/codefresh.io\/docs\/docs\/learn-by-example\/java\/gradle\/\">Gradle Spring Boot example<\/a>.<\/p>\n<h3 id=\"building-application-docker-image\">Building a Java Application Docker image<\/h3>\n<p>In order to run this demo, I need to create a Docker image with JRE, the compiled and packaged Java application, and all 3rd party libraries.<\/p>\n<p>Here&#8217;s the\u00a0<code>Dockerfile<\/code>\u00a0I used to build my\u00a0image. This demo Docker image is based on slim Alpine Linux with OpenJDK JRE and contains the application WAR file with all dependencies embedded into it. It&#8217;s just the bare minimum required to run the demo application.<\/p>\n<pre># Base Alpine Linux based image with OpenJDK JRE only\nFROM openjdk:8-jre-alpine\n# copy application WAR (with libraries inside)\nCOPY target\/spring-boot-*.war \/app.war\n# specify default command\nCMD [\"\/usr\/bin\/java\", \"-jar\", \"-Dspring.profiles.active=test\", \"\/app.war\"]<\/pre>\n<p>To build the Docker image, run the following command:<\/p>\n<pre>$ docker build -t blog\/sbdemo:latest .<\/pre>\n<p>Running the\u00a0<code>docker history<\/code> command on created Docker image\u00a0will let you\u00a0see all layers that\u00a0make up this image:<\/p>\n<ul>\n<li>4.8MB Alpine Linux Layer<\/li>\n<li>103MB OpenJDK JRE Layer<\/li>\n<li>61.8MB Application WAR file<\/li>\n<\/ul>\n<pre class=\"lang:sh decode:true\">$ docker history blog\/sbdemo:latest\nIMAGE CREATED CREATED BY SIZE COMMENT\n16d5236aa7c8 About an hour ago \/bin\/sh -c #(nop) CMD [\"\/usr\/bin\/java\" \"-... 0 B\ne1bbd125efc4 About an hour ago \/bin\/sh -c #(nop) COPY file:1af38329f6f390... 61.8 MB\nd85b17c6762e 2 months ago \/bin\/sh -c set -x &amp;&amp; apk add --no-cache ... 103 MB\n&lt;missing&gt; 2 months ago \/bin\/sh -c #(nop) ENV JAVA_ALPINE_VERSION... 0 B\n&lt;missing&gt; 2 months ago \/bin\/sh -c #(nop) ENV JAVA_VERSION=8u111 0 B\n&lt;missing&gt; 2 months ago \/bin\/sh -c #(nop) ENV PATH=\/usr\/local\/sbi... 0 B\n&lt;missing&gt; 2 months ago \/bin\/sh -c #(nop) ENV JAVA_HOME=\/usr\/lib\/... 0 B\n&lt;missing&gt; 2 months ago \/bin\/sh -c { echo '#!\/bin\/sh'; echo 's... 87 B\n&lt;missing&gt; 2 months ago \/bin\/sh -c #(nop) ENV LANG=C.UTF-8 0 B\n&lt;missing&gt; 2 months ago \/bin\/sh -c #(nop) ADD file:eeed5f514a35d18... 4.8 MB<\/pre>\n<h3 id=\"running-application-docker-container\">Running the Java Application Docker container<\/h3>\n<p>In order to run the demo application, run the following command:<\/p>\n<pre class=\"lang:sh decode:true\">$ docker run -d --name demo-default -p 8090:8090 -p 8091:8091 blog\/sbdemo:latest<\/pre>\n<p>Let&#8217;s check that the application is up and running (I\u2019m using the\u00a0<a href=\"https:\/\/httpie.org\/\">httpie<\/a> tool here):<\/p>\n<pre class=\"lang:sh decode:true\">$ http http:\/\/localhost:8091\/info\nHTTP\/1.1 200 OK\nContent-Type: application\/json\nDate: Thu, 09 Mar 2017 14:43:28 GMT\nServer: Apache-Coyote\/1.1\nTransfer-Encoding: chunked\n{\n \"build\": {\n \"artifact\": \"${project.artifactId}\",\n \"description\": \"boot-example default description\",\n \"name\": \"spring-boot-rest-example\",\n \"version\": \"0.1\"\n }\n}<\/pre>\n<h4 id=\"setting-docker-container-memory-constraints\">Setting Docker container memory constraints<\/h4>\n<p>One thing you need to know about Java process memory allocation\u00a0is that in reality it consumes more physical memory than specified with the <code>-Xmx<\/code> JVM option. The <code>-Xmx<\/code> option specifies only the\u00a0<em>maximum<\/em> Java heap size. But the Java process is a regular Linux process and we are more interested in how much actual <em>physical memory<\/em> this process is consuming.<\/p>\n<p>Or in other words &#8211; <em>what is the <strong>R<\/strong>esident <strong>S<\/strong>et <strong>S<\/strong>ize (<strong>RSS<\/strong>) value for running a Java process?<\/em><\/p>\n<p>Theoretically, in the\u00a0case of a Java application, a required <code>RSS<\/code> size can be calculated by:<\/p>\n<pre class=\"lang:default decode:true\">RSS = Heap size + MetaSpace + OffHeap size<\/pre>\n<p>where <em>OffHeap<\/em> consists of thread stacks, direct buffers, mapped files (libraries and jars) and the JVM code itself.<\/p>\n<p>There is a very good post on this topic: <a href=\"http:\/\/trustmeiamadeveloper.com\/2016\/03\/18\/where-is-my-memory-java\/\">Analyzing java memory usage in a Docker container<\/a> by Mikhail Krestjaninoff.<\/p>\n<p>When\u00a0using the\u00a0<code>--memory<\/code>\u00a0 option in\u00a0<code>docker run<\/code>\u00a0 make sure the limit is larger than what you specify for\u00a0-Xmx.<\/p>\n<h4 id=\"offtopic-using-oom-killer-instead-of-gc\">Offtopic: Using OOM Killer instead of GC<\/h4>\n<p>There is an interesting <strong>JDK Enhancement Proposal<\/strong> (<strong>JEP<\/strong>) by Aleksey Shipilev: <a href=\"http:\/\/openjdk.java.net\/jeps\/8174901\">Epsilon GC<\/a>. This JEP developed\u00a0a GC that only handles memory allocation, but does not implement any actual memory reclamation mechanism.<\/p>\n<p>This GC, combined with <code>--restart<\/code> (Docker restart policy) should theoretically allow supporting \u201cExtremely short lived jobs\u201d implemented in Java.<\/p>\n<p>For ultra-performance-sensitive applications, where developers are conscious about memory allocations or want to create completely garbage-free applications &#8211; GC cycle may be considered an implementation bug that wastes cycles for no good reason. In such use cases, it could be better to allow <strong>OOM Killer<\/strong> (Out of Memory) to kill the process and use Docker&#8217;s restart policy to restart the process.<\/p>\n<p>Anyway <strong>Epsilon GC<\/strong> is not available yet, so it\u2019s just an interesting theoretical use case for a moment.<\/p>\n<h2 id=\"building-java-application-with-builder-container\">Building Java applications with Builder container<\/h2>\n<p>As you can probably see, in the previous step, I did not explain how I\u2019ve created the application WAR file.<\/p>\n<p>Of course, there is a Maven project file <code>pom.xml<\/code>\u00a0which every Java developer should be familiar with. But, in order to actually build, you need to install <em>same Java Build tools<\/em> (JDK and Maven) on <em>every machine<\/em>, where you are building the application. You need to have the same versions, use the same repositories and share the same configurations. While&#8217;s it\u2019s possible,\u00a0managing different projects that rely\u00a0on\u00a0different tools, versions, configurations, and\u00a0development environments can quickly become a nightmare.<\/p>\n<p>What if you\u00a0want to run a\u00a0build on a clean machine that does not have Java or Maven installed? <em>What should you do?<\/em><\/p>\n<h3>Java Builder Container<\/h3>\n<p>Docker can help here too. With Docker, you can create and share portable development and build environments. The idea is to create a special <strong>Builder<\/strong> Docker image, that contains all tools you need to properly build your Java application, e.g.: JDK, Ant, Maven, Gradle, SBT or others.<\/p>\n<p>To create a really useful <strong>Builder<\/strong> Docker image, you need to know how your Java Build tools work and how <code>docker build<\/code> invalidates build cache. Without proper design, you will end up with ineffective and slow builds.<\/p>\n<h3 id=\"maven-in-docker\">Running Maven in Docker<\/h3>\n<p>While most of these tools were created nearly a generation ago, they are still\u00a0very popular and widely used by Java developers.<\/p>\n<p>The Java development life is hard to imagine without extra build tools. There are multiple Java build tools out there, but most of them share similar concepts and serve the same targets &#8211; resolve cumbersome package dependencies, and run different build tasks, such as, <strong><em>compile, lint, test, package, and deploy<\/em><\/strong>.<\/p>\n<p>In this post, I will use <a href=\"https:\/\/maven.apache.org\">Maven<\/a>, but the same approach can be applied to <a href=\"https:\/\/gradle.org\/\">Gradle<\/a>, <a href=\"http:\/\/www.scala-sbt.org\/\">SBT<\/a>, and other less popular Java Build tools.<\/p>\n<p>It\u2019s important to learn how your Java Build tool works and how it&#8217;s tuned. Apply this knowledge, when creating a <strong>Builder<\/strong> Docker image and the way you run a\u00a0<strong>Builder\u00a0<\/strong>Docker container.<\/p>\n<p>Maven uses the project level <code>pom.xml<\/code> file to resolve project dependencies. It downloads missing <code>JAR<\/code> files from private and public Maven repositories, and\u00a0<em>caches<\/em> these files for future builds. Thus, the next time you run your build, it won\u2019t download anything if your dependency had not been changed.<\/p>\n<h4 id=\"official-maven-docker-image-should-you-use-it-\">Official Maven Docker image: should you use it?<\/h4>\n<p>The Maven team provides an official <a href=\"https:\/\/hub.docker.com\/r\/_\/maven\/\">Docker image<\/a>. There are multiple images (under different tags) that allow\u00a0you to select an image that can answer your needs. Take a deeper look at the\u00a0<code>Dockerfile<\/code> files and <code>mvn-entrypoint.sh<\/code> shell scripts when selecting Maven image to use.<\/p>\n<p>There are two flavors of official Maven Docker images: regular images (JDK version, Maven version, and Linux distro) and <code>onbuild<\/code> images.<\/p>\n<h4><em>What is the official Maven image good for?<\/em><\/h4>\n<p>The official Maven image does a good job containerizing the Maven tool itself. Using such an image, you can run Maven build on any machine without installing a JDK and Maven.<\/p>\n<p><strong>Example:<\/strong> running <code>mvn clean install<\/code> on local folder<\/p>\n<pre class=\"lang:default decode:true\">$ docker run -it --rm --name my-maven-project -v \"$PWD\":\/usr\/src\/app -w \/usr\/src\/app maven:3.2-jdk-7 mvn clean install<\/pre>\n<p>By default the Maven local repository, for official Maven images, is placed inside a Docker <em>data volume<\/em>. That means, all downloaded dependencies <strong>are not part of the image<\/strong> and will <strong>disappear<\/strong> once the Maven container is destroyed. If you do not want to download dependencies on every build, mount Maven&#8217;s repository Docker volume to some persistent storage (at least local folder on the Docker\u00a0host).\u00a0When setting up your builds on Codefresh, it&#8217;s a simple matter of overriding the\u00a0<span class=\"lang:default decode:true crayon-inline \">MAVEN_CONFIG<\/span>environment variable to store it&#8217;s cache in the persistent volume, for example\u00a0<span class=\"lang:default decode:true crayon-inline \">\/codefresh\/volume\/.m2<\/span>\u00a0.<\/p>\n<p><strong>Example:<\/strong> running <code>mvn clean install<\/code> on local folder with properly mounted Maven local repository<\/p>\n<pre class=\"lang:sh decode:true\">$ docker run -it --rm --name my-maven-project -v \"$PWD\":\/usr\/src\/app \\\n -v \"$HOME\"\/.m2:\/root\/.m2 -w \/usr\/src\/app maven:3.2-jdk-7 mvn clean install<\/pre>\n<p>Now, let&#8217;s take a look at <code>onbuild<\/code> Maven Docker images.<\/p>\n<h4><em>What is the Maven\u00a0<code>onbuild<\/code> image?<\/em><\/h4>\n<p>Maven <code>onbuild<\/code> Docker images exists to <em>\u201csimplify\u201d<\/em> developer\u2019s life by allowing him\/er to skip writing\u00a0a <code>Dockerfile<\/code>. Actually, a developer should write a <code>Dockerfile<\/code>, but it\u2019s usually enough to have the\u00a0single line in it:<\/p>\n<pre class=\"lang:default decode:true\">FROM maven:&lt;versions&gt;-onbuild<\/pre>\n<p>Looking into <code>onbuild<\/code><code>Dockerfile<\/code> on the <a href=\"https:\/\/github.com\/carlossg\/docker-maven\">GitHub repository<\/a> \u2026<\/p>\n<pre class=\"lang:default decode:true\">FROM maven:{version}\nRUN mkdir -p \/usr\/src\/app\nWORKDIR \/usr\/src\/app\nONBUILD ADD . \/usr\/src\/app\nONBUILD RUN mvn install<\/pre>\n<p>\u2026 you can see several <code>Dockerfile<\/code> commands with the\u00a0<code>ONBUILD<\/code> prefix. The <code>ONBUILD<\/code> tells Docker to postpone the\u00a0execution of these build commands until building a new image that inherits from the current image.<\/p>\n<p>In our example, two build commands will be executed, when you build the application <code>Dockerfile<\/code> created <span class=\"lang:default decode:true crayon-inline \">FROM: maven:&lt;version&gt;-onbuild<\/span>\u00a0:<\/p>\n<ol>\n<li>Add the current folder (all files, if you are not using <code>.dockerignore<\/code>) to the new Docker image<\/li>\n<li>Run <code>mvn install<\/code> target<\/li>\n<\/ol>\n<p>The\u00a0<code>onbuild<\/code> Maven Docker image is not as useful as the\u00a0previous image.<\/p>\n<p>First of all, it copies everything from the current repository, so do not use it without a\u00a0properly configured <a href=\"https:\/\/codefresh.io\/docker-tutorial\/not-ignore-dockerignore-2\/\">.dockerignore<\/a> file.<\/p>\n<p>Then, think: <em>what kind of image you are trying to build?<\/em><\/p>\n<p>The new image, created from <span class=\"lang:default decode:true crayon-inline \">onbuild<\/span>\u00a0 Maven Docker image, includes JDK, Maven, application code (and potentially <strong>all files<\/strong> from current directory), and <strong>all files<\/strong> produced by Maven <code>install<\/code> phase (compiled, tested and packaged app; plus lots of build junk files you do not really need).<\/p>\n<p>So, this Docker image contains everything, but, for some strange reason, does not contain a local Maven repository. I have no idea why the Maven team created this image.<\/p>\n<blockquote><p><strong>Recommendation<\/strong>: Do not use Maven <code>onbuild<\/code> images!<\/p><\/blockquote>\n<p>I will show you how to create a proper\u00a0<strong>Builder<\/strong> image later in this post.<\/p>\n<h4 id=\"where-to-keep-maven-cache-\">Where to keep the Maven cache?<\/h4>\n<p>Official Maven Docker images keep Maven&#8217;s cache folder outside of the container, exposing it as a Docker <em>data<\/em> <em>volume<\/em>, using <code>VOLUME root\/.m2<\/code> command in the <code>Dockerfile<\/code>. A Docker <em>data volume<\/em> is a directory within one or more containers that bypasses the Docker Union File System, in simple words: <em>it\u2019s not part of the Docker image<\/em>.<\/p>\n<p>What you should know about Docker <em>data volumes<\/em>:<\/p>\n<ul>\n<li>Volumes are initialized when a container is created.<\/li>\n<li>Data volumes can be shared and reused among containers.<\/li>\n<li>Changes to a data volume are made directly to the mounted endpoint (usually some directory on host, but can be some storage device too)<\/li>\n<li>Changes to a data volume will not be included when you update an image or persist Docker container.<\/li>\n<li>Data volumes persist even if the container itself is deleted.<\/li>\n<\/ul>\n<p>So, in order to <em>reuse<\/em> Maven <em>cache<\/em> between different builds, mount a Maven cache <em>data volume<\/em> to some persistent storage (for example, a\u00a0local directory on the Docker host).<\/p>\n<pre class=\"lang:sh decode:true\">$ docker run -it --rm --volume \"$PWD\"\/pom.xml:\/\/usr\/src\/app\/pom.xml \\\n --volume \"$HOME\"\/.m2:\/root\/.m2 maven:3-jdk-8-alpine mvn install<\/pre>\n<p>The command above runs the official Maven Docker image (Maven 3 and OpenJDK 8), mounts project <code>pom.xml<\/code> file into working directory and <code>\"$HOME\"\/.m2<\/code> folder for Maven <em>cache<\/em> data volume.<\/p>\n<p>Running Maven inside this Docker container will download all required JAR files into host\u2019s local folder <code>$HOME\/.m2<\/code>. The next time you create a new Maven Docker container for the\u00a0same <code>pom.xml<\/code> file and the same <em>cache<\/em> mount, Maven will reuse the\u00a0<em>cache<\/em> and will download only missing or updated JAR files.<\/p>\n<h4 id=\"maven-builder-docker-image\">Maven Builder Docker image<\/h4>\n<p>First, let\u2019s try to formulate <em>what is the <strong>Builder<\/strong> Docker image<\/em> and <em>what should it contain?<\/em><\/p>\n<blockquote><p>A <strong>Builder<\/strong> is a Docker image that contains <strong>everything<\/strong> to allow you creating a reproducible build on any machine and at any point of time.<\/p><\/blockquote>\n<p>So, <em>what should it contain?<\/em><\/p>\n<ul>\n<li>Linux shell and some tools &#8211; I prefer\u00a0Alpine Linux<\/li>\n<li>JDK (version) &#8211; for\u00a0the\u00a0<code>javac<\/code> compiler<\/li>\n<li>Maven (version) &#8211; Java build tool<\/li>\n<li>Application source code and <code>pom.xml<\/code> file\/s &#8211; it\u2019s the application code <em>SNAPSHOT<\/em> at specific point of time; just code, no need to include a\u00a0<code>.git<\/code> repository or other files<\/li>\n<li>Project dependencies (Maven local repository) &#8211; all <code>pom<\/code> and <code>JAR<\/code>\u00a0files you need to build and test Java applications, at any time, even offline, even if library disappears from the web<\/li>\n<\/ul>\n<p>The <strong>Builder<\/strong>\u00a0image captures code, dependencies, and tools at a\u00a0specific point of time and stores them inside a Docker image. The <strong>Builder<\/strong> container can be used to create the application \u201cbinaries\u201d on any machine, at any time and even without internet connection (or with poor connection).<\/p>\n<p>Here is the sample <code>Dockerfile<\/code> for my demo <strong>Builder<\/strong>:<\/p>\n<pre class=\"lang:default decode:true \">FROM openjdk:8-jdk-alpine\n# ----\n# Install Maven\nRUN apk add --no-cache curl tar bash\nARG MAVEN_VERSION=3.3.9\nARG USER_HOME_DIR=\"\/root\"\nRUN mkdir -p \/usr\/share\/maven &amp;&amp; \\\ncurl -fsSL http:\/\/apache.osuosl.org\/maven\/maven-3\/$MAVEN_VERSION\/binaries\/apache-maven-$MAVEN_VERSION-bin.tar.gz | tar -xzC \/usr\/share\/maven --strip-components=1 &amp;&amp; \\\nln -s \/usr\/share\/maven\/bin\/mvn \/usr\/bin\/mvn\nENV MAVEN_HOME \/usr\/share\/maven\nENV MAVEN_CONFIG \"$USER_HOME_DIR\/.m2\"\n# speed up Maven JVM a bit\nENV MAVEN_OPTS=\"-XX:+TieredCompilation -XX:TieredStopAtLevel=1\"\nENTRYPOINT [\"\/usr\/bin\/mvn\"]\n# ----\n# Install project dependencies and keep sources\n# make source folder\nRUN mkdir -p \/usr\/src\/app\nWORKDIR \/usr\/src\/app\n# install maven dependency packages (keep in image)\nCOPY pom.xml \/usr\/src\/app\nRUN mvn -T 1C install &amp;&amp; rm -rf target\n# copy other source files (keep in image)\nCOPY src \/usr\/src\/app\/src<\/pre>\n<p>Let\u2019s go over this <code>Dockerfile<\/code> and I the\u00a0reasoning behind each command.<\/p>\n<ul>\n<li><code>FROM: openjdk:8-jdk-alpine<\/code> &#8211; select and freeze JDK version: OpenJDK 8 and Linux Alpine<\/li>\n<li>Install Maven\n<ul>\n<li>Speed up Maven JVM a bit: <code>MAVEN_OPTS=\"-XX:+TieredCompilation -XX:TieredStopAtLevel=1\"<\/code>, read the\u00a0following <a href=\"https:\/\/zeroturnaround.com\/rebellabs\/your-maven-build-is-slow-speed-it-up\/\">post<\/a><\/li>\n<li><code>RUN mkdir -p ... curl ... tar ...\u00a0<\/code>&#8211; download and install (<code>untar<\/code> and <code>ln -s<\/code>) Apache Maven<\/li>\n<li><code>ARG ...<\/code> &#8211; Use build arguments to allow overriding Maven version and local repository location (<code>MAVEN_VERSION<\/code> and <code>USER_HOME_DIR<\/code>) with <code>docker build --build-arg ...<\/code><\/li>\n<\/ul>\n<\/li>\n<li><code>RUN mvn -T 1C install &amp;&amp; rm -rf target<\/code>\u00a0&#8211; download project dependencies:\n<ul>\n<li>Copy project <code>pom.xml<\/code> file, run <code>mvn install<\/code> command, and remove build artifacts (as far as I know, there is no Maven command that will let you download without\u00a0installing)<\/li>\n<li>This Docker image layer will be rebuilt only when project\u2019s <code>pom.xml<\/code> file changes<\/li>\n<\/ul>\n<\/li>\n<li><code>COPY src \/usr\/src\/app\/src<\/code> &#8211; copy project source files (source, tests, and resources)<\/li>\n<\/ul>\n<p><strong>Note:<\/strong> if you are using Maven <a href=\"http:\/\/maven.apache.org\/surefire\/maven-surefire-plugin\">Surefire plugin<\/a> and want to have all dependencies for the\u00a0offline build, make sure to <a href=\"http:\/\/maven.apache.org\/surefire\/maven-surefire-plugin\/examples\/providers.html\">lock down Surefire test provider<\/a>.<\/p>\n<p>When you build a new <strong>Builder<\/strong> version, I suggest you use a <code>--cache-from<\/code> option passing previous <strong>Builder<\/strong> image to it. This will allow you reuse any unmodified Docker layer and avoid obsolete downloads most of the time (if <code>pom.xml<\/code> did not change or you did not decide to upgrade Maven or JDK).<\/p>\n<p><strong>Fun fact:<\/strong> One of the benefits of Codefresh pipelines is the fact that they automatically use <code>--cache-from<\/code> for you in all steps that build Docker images. So this technique is only needed when you run locally docker on your workstation, (it is completely automated in Codefresh).<\/p>\n<pre class=\"lang:sh decode:true\">$ # pull latest (or specific version) builder image\n$ docker pull myrep\/mvn-builder:latest\n$ # build new builder\n$ docker build -t myrep\/mvn-builder:latest --cache-from myrep\/mvn-builder:latest .<\/pre>\n<h5 id=\"use-builder-container-to-run-tests\">Use Builder container to run tests<\/h5>\n<pre class=\"lang:sh decode:true\">$ # run tests - test results are saved into $PWD\/target\/surefire-reports\n$ docker run -it --rm -v \"$PWD\"\/target:\/usr\/src\/app\/target myrep\/mvn-builder -T 1C -o test<\/pre>\n<h5 id=\"use-builder-container-to-create-application-war\">Use Builder container to create application WAR<\/h5>\n<pre class=\"lang:sh decode:true\">$ # create application WAR file (skip tests) - $PWD\/target\/spring-boot-rest-example-0.3.0.war\n$ docker run -it --rm -v $(shell pwd)\/target:\/usr\/src\/app\/target myrep\/mvn-builder package -T 1C -o -Dmaven.test.skip=true<\/pre>\n<h2>Summary<\/h2>\n<p>Take a look at images bellow:<\/p>\n<pre class=\"lang:default decode:true\">REPOSITORY      TAG     IMAGE ID     CREATED        SIZE\nsbdemo\/run      latest  6f432638aa60 7 minutes ago   143 MB\nsbdemo\/tutorial 1       669333d13d71 12 minutes ago 1.28 GB\nsbdemo\/tutorial 2       38634e4d9d5e 3 hours ago    1.26 GB\nsbdemo\/builder  mvn     2d325a403c5f 5 days ago      263 MB<\/pre>\n<ul>\n<li><span class=\"lang:default decode:true crayon-inline\">sbdemo\/run:latest<\/span>\u00a0 &#8211; Docker image for demo runtime: Alpine, OpenJDK JRE only, demo WAR<\/li>\n<li><span class=\"lang:default decode:true crayon-inline \">sbdemo\/builder:mvn<\/span>\u00a0 &#8211; <strong>Builder<\/strong>\u00a0Docker image: Alpine, OpenJDK 8, Maven 3, code, dependency<\/li>\n<li><span class=\"lang:default decode:true crayon-inline \">sbdemo\/tutorial:1<\/span>\u00a0 &#8211; Docker image created following first tutorial (just for reference)<\/li>\n<li><span class=\"lang:default decode:true crayon-inline \">sbdemo\/tutorial:2<\/span>\u00a0 &#8211; Docker image created following second tutorial (just for reference)<\/li>\n<\/ul>\n<h2 id=\"build-flow-automation\">Bonus: Build flow automation<\/h2>\n<p>In this section, I will show how to use Docker build flow automation service to automate and orchestrate all steps from this post.<\/p>\n<h3>Build Pipeline Steps<\/h3>\n<p>Here is the list of steps you need to complete:<\/p>\n<ol>\n<li>Create a Maven <strong>Builder<\/strong> Docker image<\/li>\n<li>Run tests and store test results<\/li>\n<li>Compile the application code and assemble the application WAR file<\/li>\n<li>Build the application Docker image<\/li>\n<li>Push the application Docker image to a\u00a0Docker Registry<\/li>\n<\/ol>\n<p>It&#8217;s possible\u00a0to execute these steps manually. But it&#8217;s better to automate them and avoid typing long commands. You can use a Bash script, Makefile, or some other tool. In this post, I will show how to use the <a href=\"https:\/\/www.codefresh.io\">Codefresh<\/a> Docker CI\/CD service (the company I work for) to automate the Java-Docker build pipeline for this demo.<\/p>\n<h3>Java Docker build pipeline automation with Codefresh<\/h3>\n<p>Using Codefresh, you can define automated CI\/CD pipelines for your Docker images.<\/p>\n<p>The Codefresh <span class=\"lang:default decode:true crayon-inline \">YAML<\/span>\u00a0 syntax is pretty straight forward:<\/p>\n<ul>\n<li>it contains an ordered list of steps<\/li>\n<li>each step has a\u00a0type:\n<ul>\n<li><code>build<\/code> &#8211; for <code>docker build<\/code> command<\/li>\n<\/ul>\n<ul>\n<li><code>push<\/code> &#8211; for <code>docker push<\/code><\/li>\n<\/ul>\n<ul>\n<li><code>composition<\/code> &#8211; for creating tests or runnning tests environment, specified with <code>docker-compose<\/code><\/li>\n<\/ul>\n<ul>\n<li><code>freestyle<\/code> (default if not specified) &#8211; for <code>docker run<\/code> command<\/li>\n<\/ul>\n<\/li>\n<li><code>\/codefresh\/volume\/<\/code><em>data volume<\/em> (<code>git clone<\/code> and files generated by steps) is mounted into each step<\/li>\n<li>current working directory for each step is set to <code>\/codefresh\/volume\/<\/code> by default (can be changed)<\/li>\n<\/ul>\n<p>For a more\u00a0detailed description and other examples, take a look at the <a href=\"https:\/\/docs.codefresh.io\/docs\/steps\">build steps documentation<\/a>.<\/p>\n<p>For my demo flow I\u2019ve created the following automation steps:<\/p>\n<ol>\n<li><code>mvn_builder<\/code> &#8211; create Maven <strong>Builder<\/strong> Docker image<\/li>\n<li><code>mv_test<\/code> &#8211; execute tests in <strong>Builder<\/strong> container, place test results into <code>\/codefresh\/volume\/target\/surefire-reports\/<\/code><em>data volume<\/em> folder<\/li>\n<li><code>mv_package<\/code> &#8211; create application <code>WAR<\/code> file, place created file into <code>\/codefresh\/volume\/target\/<\/code><em>data volume<\/em> folder<\/li>\n<li><code>build_image<\/code> &#8211; build application Docker image with JRE and application <code>WAR<\/code> file<\/li>\n<li><code>push_image<\/code> &#8211; tag and push the application Docker image to DockerHub<\/li>\n<\/ol>\n<p>Here is the full Codefresh <code>YAML<\/code>:<\/p>\n<pre class=\"lang:yaml decode:true\">version: '1.0'\n steps:\n    mvn_builder:\n        type: build\n        description: 'create Maven builder'\n        dockerfile: Dockerfile.build\n        image_name: '{my-repository}\/mvn-builder'\n    mvn_test:\n        description: 'run unit tests'\n        image: '${{mvn_builder}}'\n        commands:\n            - 'mvn -T 1C -o test'\n    mvn_package:\n        description: 'package application WAR'\n        image: '${{mvn_builder}}'\n        commands:\n            - 'mvn package -T 1C -o -Dmaven.test.skip=true'\n    build_image:\n        type: build\n        description: 'create Docker image with application WAR'\n        dockerfile: Dockerfile\n        working_directory: '${{main_clone}}\/target'\n        image_name: '{my-repository}\/sbdemo'\n    image_push:\n        type: push\n        description: 'push to DockerHub'\n        candidate: '${{build_image}}'\n        tag: '${{CF_BRANCH}}'\n        credentials: null\n        username: '${{DOCKER_USER}}'\n        password: '${{DOCKER_PASS}}'\n\n\n<\/pre>\n<p>Hope, you find this post useful. I look forward to your comments and any questions you have.\u00a0<\/p>\n<p>Be sure to read the <a href=\"https:\/\/codefresh.io\/howtos\/using-docker-maven-maven-docker\/\">Using Docker from Maven and Maven from Docker<\/a> blog post as well as our <a href=\"https:\/\/codefresh.io\/docker-tutorial\/docker-multi-stage-builds\/\">multi-stage builds<\/a> tutorial.<\/p>\n<p>Ready to try Codefresh, the CI\/CD platform for Docker\/Kubernetes\/Helm? <a href=\"https:\/\/codefresh.io\/codefresh-signup\/?utm_source=Blog&#038;utm_medium=Post&#038;utm_campaign=perfectjava\">Create Your Free Account Today<\/a>!<\/p>\n<input class=\"fooboxshare_post_id\" type=\"hidden\" value=\"2343\"\/>","protected":false},"excerpt":{"rendered":"<p>TL;DR What is the bare minimum you need to build, test and run your Java application in Docker container? The recipe: Create a separate Docker image for each step and optimize the way you are running it. Introduction I started working\u00a0with Java in 1998, and for a long time, it was my main programming language. &hellip; <a href=\"https:\/\/codefresh.io\/docker-tutorial\/java_docker_pipeline\/\">Read more<\/a><\/p>\n","protected":false},"author":28,"featured_media":2344,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[8],"tags":[14,24,53,59,64,71,86,87],"yoast_head":"<!-- This site is optimized with the Yoast SEO Premium plugin v17.9 (Yoast SEO v18.4.1) - https:\/\/yoast.com\/wordpress\/plugins\/seo\/ -->\n<title>Crafting the perfect Java Docker build flow | Codefresh<\/title>\n<meta name=\"description\" content=\"How-to create a perfect Java Docker automation build CI\/CD pipeline (powered by Codefresh), containerizing Java application, build (Maven) and test tools.\" \/>\n<meta name=\"robots\" content=\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\" \/>\n<link rel=\"canonical\" href=\"https:\/\/codefresh.io\/docker-tutorial\/java_docker_pipeline\/\" \/>\n<meta property=\"og:locale\" content=\"en_US\" \/>\n<meta property=\"og:type\" content=\"article\" \/>\n<meta property=\"og:title\" content=\"Crafting the perfect Java Docker build flow\" \/>\n<meta property=\"og:description\" content=\"How-to create a perfect Java Docker automation build CI\/CD pipeline (powered by Codefresh), containerizing Java application, build (Maven) and test tools.\" \/>\n<meta property=\"og:url\" content=\"https:\/\/codefresh.io\/docker-tutorial\/java_docker_pipeline\/\" \/>\n<meta property=\"og:site_name\" content=\"Codefresh\" \/>\n<meta property=\"article:publisher\" content=\"https:\/\/www.facebook.com\/codefresh.io\" \/>\n<meta property=\"article:published_time\" content=\"2019-10-17T17:31:21+00:00\" \/>\n<meta property=\"article:modified_time\" content=\"2019-10-18T14:45:24+00:00\" \/>\n<meta property=\"og:image\" content=\"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/03\/duke_docker.png\" \/>\n\t<meta property=\"og:image:width\" content=\"765\" \/>\n\t<meta property=\"og:image:height\" content=\"340\" \/>\n\t<meta property=\"og:image:type\" content=\"image\/png\" \/>\n<meta name=\"twitter:card\" content=\"summary_large_image\" \/>\n<meta name=\"twitter:creator\" content=\"@alexeiled\" \/>\n<meta name=\"twitter:site\" content=\"@codefresh\" \/>\n<meta name=\"twitter:label1\" content=\"Written by\" \/>\n\t<meta name=\"twitter:data1\" content=\"Alexei Ledenev\" \/>\n\t<meta name=\"twitter:label2\" content=\"Est. reading time\" \/>\n\t<meta name=\"twitter:data2\" content=\"23 minutes\" \/>\n<script type=\"application\/ld+json\" class=\"yoast-schema-graph\">{\"@context\":\"https:\/\/schema.org\",\"@graph\":[{\"@type\":\"Organization\",\"@id\":\"https:\/\/codefresh.io\/#organization\",\"name\":\"Codefresh\",\"url\":\"https:\/\/codefresh.io\/\",\"sameAs\":[\"https:\/\/www.facebook.com\/codefresh.io\",\"https:\/\/www.linkedin.com\/company\/codefresh\",\"https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg\",\"https:\/\/twitter.com\/codefresh\"],\"logo\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#logo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"width\":800,\"height\":800,\"caption\":\"Codefresh\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/#logo\"}},{\"@type\":\"WebSite\",\"@id\":\"https:\/\/codefresh.io\/#website\",\"url\":\"https:\/\/codefresh.io\/\",\"name\":\"Codefresh\",\"description\":\"\",\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"potentialAction\":[{\"@type\":\"SearchAction\",\"target\":{\"@type\":\"EntryPoint\",\"urlTemplate\":\"https:\/\/codefresh.io\/?s={search_term_string}\"},\"query-input\":\"required name=search_term_string\"}],\"inLanguage\":\"en-US\"},{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/java_docker_pipeline\/#primaryimage\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/03\/duke_docker.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/03\/duke_docker.png\",\"width\":765,\"height\":340,\"caption\":\"Java in Docker\"},{\"@type\":\"WebPage\",\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/java_docker_pipeline\/#webpage\",\"url\":\"https:\/\/codefresh.io\/docker-tutorial\/java_docker_pipeline\/\",\"name\":\"Crafting the perfect Java Docker build flow | Codefresh\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/#website\"},\"primaryImageOfPage\":{\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/java_docker_pipeline\/#primaryimage\"},\"datePublished\":\"2019-10-17T17:31:21+00:00\",\"dateModified\":\"2019-10-18T14:45:24+00:00\",\"description\":\"How-to create a perfect Java Docker automation build CI\/CD pipeline (powered by Codefresh), containerizing Java application, build (Maven) and test tools.\",\"breadcrumb\":{\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/java_docker_pipeline\/#breadcrumb\"},\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"ReadAction\",\"target\":[\"https:\/\/codefresh.io\/docker-tutorial\/java_docker_pipeline\/\"]}]},{\"@type\":\"BreadcrumbList\",\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/java_docker_pipeline\/#breadcrumb\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"name\":\"Home\",\"item\":\"https:\/\/codefresh.io\/\"},{\"@type\":\"ListItem\",\"position\":2,\"name\":\"Crafting the perfect Java Docker build flow\"}]},{\"@type\":\"Article\",\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/java_docker_pipeline\/#article\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/java_docker_pipeline\/#webpage\"},\"author\":{\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/33798ced90c48c116c3a9a59ae74af50\"},\"headline\":\"Crafting the perfect Java Docker build flow\",\"datePublished\":\"2019-10-17T17:31:21+00:00\",\"dateModified\":\"2019-10-18T14:45:24+00:00\",\"mainEntityOfPage\":{\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/java_docker_pipeline\/#webpage\"},\"wordCount\":3674,\"commentCount\":43,\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/java_docker_pipeline\/#primaryimage\"},\"thumbnailUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/03\/duke_docker.png\",\"keywords\":[\"docker\",\"Containers\",\"CI\/CD\",\"codefresh\",\"microservices\",\"docker-compose\",\"java\",\"maven\"],\"articleSection\":[\"Docker Tutorials\"],\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"CommentAction\",\"name\":\"Comment\",\"target\":[\"https:\/\/codefresh.io\/docker-tutorial\/java_docker_pipeline\/#respond\"]}]},{\"@type\":\"Person\",\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/33798ced90c48c116c3a9a59ae74af50\",\"name\":\"Alexei Ledenev\",\"image\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#personlogo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/secure.gravatar.com\/avatar\/53d5ff05d62acd594ea97300543a62a5?s=96&d=blank&r=g\",\"contentUrl\":\"https:\/\/secure.gravatar.com\/avatar\/53d5ff05d62acd594ea97300543a62a5?s=96&d=blank&r=g\",\"caption\":\"Alexei Ledenev\"},\"description\":\"Alexei is an experienced software architect and HPE distinguished technologist. He currently works at Codefresh as the Chief Researcher, focusing lately on #docker, #golang and #aws. In his spare time, Alexei maintains a couple of Docker-centric open-source projects, writes tech blog posts, and enjoys traveling and playing with his kids. https:\/\/github.com\/gaia-adm\/pumba\",\"sameAs\":[\"https:\/\/medium.com\/@alexeiled\/\",\"https:\/\/twitter.com\/alexeiled\"],\"url\":\"https:\/\/codefresh.io\/author\/alexei\/\"}]}<\/script>\n<!-- \/ Yoast SEO Premium plugin. -->","yoast_head_json":{"title":"Crafting the perfect Java Docker build flow | Codefresh","description":"How-to create a perfect Java Docker automation build CI\/CD pipeline (powered by Codefresh), containerizing Java application, build (Maven) and test tools.","robots":{"index":"index","follow":"follow","max-snippet":"max-snippet:-1","max-image-preview":"max-image-preview:large","max-video-preview":"max-video-preview:-1"},"canonical":"https:\/\/codefresh.io\/docker-tutorial\/java_docker_pipeline\/","og_locale":"en_US","og_type":"article","og_title":"Crafting the perfect Java Docker build flow","og_description":"How-to create a perfect Java Docker automation build CI\/CD pipeline (powered by Codefresh), containerizing Java application, build (Maven) and test tools.","og_url":"https:\/\/codefresh.io\/docker-tutorial\/java_docker_pipeline\/","og_site_name":"Codefresh","article_publisher":"https:\/\/www.facebook.com\/codefresh.io","article_published_time":"2019-10-17T17:31:21+00:00","article_modified_time":"2019-10-18T14:45:24+00:00","og_image":[{"width":765,"height":340,"url":"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/03\/duke_docker.png","type":"image\/png"}],"twitter_card":"summary_large_image","twitter_creator":"@alexeiled","twitter_site":"@codefresh","twitter_misc":{"Written by":"Alexei Ledenev","Est. reading time":"23 minutes"},"schema":{"@context":"https:\/\/schema.org","@graph":[{"@type":"Organization","@id":"https:\/\/codefresh.io\/#organization","name":"Codefresh","url":"https:\/\/codefresh.io\/","sameAs":["https:\/\/www.facebook.com\/codefresh.io","https:\/\/www.linkedin.com\/company\/codefresh","https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg","https:\/\/twitter.com\/codefresh"],"logo":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#logo","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","width":800,"height":800,"caption":"Codefresh"},"image":{"@id":"https:\/\/codefresh.io\/#logo"}},{"@type":"WebSite","@id":"https:\/\/codefresh.io\/#website","url":"https:\/\/codefresh.io\/","name":"Codefresh","description":"","publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"potentialAction":[{"@type":"SearchAction","target":{"@type":"EntryPoint","urlTemplate":"https:\/\/codefresh.io\/?s={search_term_string}"},"query-input":"required name=search_term_string"}],"inLanguage":"en-US"},{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/docker-tutorial\/java_docker_pipeline\/#primaryimage","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/03\/duke_docker.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/03\/duke_docker.png","width":765,"height":340,"caption":"Java in Docker"},{"@type":"WebPage","@id":"https:\/\/codefresh.io\/docker-tutorial\/java_docker_pipeline\/#webpage","url":"https:\/\/codefresh.io\/docker-tutorial\/java_docker_pipeline\/","name":"Crafting the perfect Java Docker build flow | Codefresh","isPartOf":{"@id":"https:\/\/codefresh.io\/#website"},"primaryImageOfPage":{"@id":"https:\/\/codefresh.io\/docker-tutorial\/java_docker_pipeline\/#primaryimage"},"datePublished":"2019-10-17T17:31:21+00:00","dateModified":"2019-10-18T14:45:24+00:00","description":"How-to create a perfect Java Docker automation build CI\/CD pipeline (powered by Codefresh), containerizing Java application, build (Maven) and test tools.","breadcrumb":{"@id":"https:\/\/codefresh.io\/docker-tutorial\/java_docker_pipeline\/#breadcrumb"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https:\/\/codefresh.io\/docker-tutorial\/java_docker_pipeline\/"]}]},{"@type":"BreadcrumbList","@id":"https:\/\/codefresh.io\/docker-tutorial\/java_docker_pipeline\/#breadcrumb","itemListElement":[{"@type":"ListItem","position":1,"name":"Home","item":"https:\/\/codefresh.io\/"},{"@type":"ListItem","position":2,"name":"Crafting the perfect Java Docker build flow"}]},{"@type":"Article","@id":"https:\/\/codefresh.io\/docker-tutorial\/java_docker_pipeline\/#article","isPartOf":{"@id":"https:\/\/codefresh.io\/docker-tutorial\/java_docker_pipeline\/#webpage"},"author":{"@id":"https:\/\/codefresh.io\/#\/schema\/person\/33798ced90c48c116c3a9a59ae74af50"},"headline":"Crafting the perfect Java Docker build flow","datePublished":"2019-10-17T17:31:21+00:00","dateModified":"2019-10-18T14:45:24+00:00","mainEntityOfPage":{"@id":"https:\/\/codefresh.io\/docker-tutorial\/java_docker_pipeline\/#webpage"},"wordCount":3674,"commentCount":43,"publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"image":{"@id":"https:\/\/codefresh.io\/docker-tutorial\/java_docker_pipeline\/#primaryimage"},"thumbnailUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/03\/duke_docker.png","keywords":["docker","Containers","CI\/CD","codefresh","microservices","docker-compose","java","maven"],"articleSection":["Docker Tutorials"],"inLanguage":"en-US","potentialAction":[{"@type":"CommentAction","name":"Comment","target":["https:\/\/codefresh.io\/docker-tutorial\/java_docker_pipeline\/#respond"]}]},{"@type":"Person","@id":"https:\/\/codefresh.io\/#\/schema\/person\/33798ced90c48c116c3a9a59ae74af50","name":"Alexei Ledenev","image":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#personlogo","inLanguage":"en-US","url":"https:\/\/secure.gravatar.com\/avatar\/53d5ff05d62acd594ea97300543a62a5?s=96&d=blank&r=g","contentUrl":"https:\/\/secure.gravatar.com\/avatar\/53d5ff05d62acd594ea97300543a62a5?s=96&d=blank&r=g","caption":"Alexei Ledenev"},"description":"Alexei is an experienced software architect and HPE distinguished technologist. He currently works at Codefresh as the Chief Researcher, focusing lately on #docker, #golang and #aws. In his spare time, Alexei maintains a couple of Docker-centric open-source projects, writes tech blog posts, and enjoys traveling and playing with his kids. https:\/\/github.com\/gaia-adm\/pumba","sameAs":["https:\/\/medium.com\/@alexeiled\/","https:\/\/twitter.com\/alexeiled"],"url":"https:\/\/codefresh.io\/author\/alexei\/"}]}},"acf":[],"_links":{"self":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/2343"}],"collection":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/users\/28"}],"replies":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/comments?post=2343"}],"version-history":[{"count":0,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/2343\/revisions"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media\/2344"}],"wp:attachment":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media?parent=2343"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/categories?post=2343"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/tags?post=2343"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}