{"id":2845,"date":"2017-05-13T22:39:58","date_gmt":"2017-05-13T22:39:58","guid":{"rendered":"https:\/\/codefresh.io\/?p=2845"},"modified":"2022-02-09T14:50:39","modified_gmt":"2022-02-09T14:50:39","slug":"webinar-creating-efficient-docker-build-pipeline-java-apps","status":"publish","type":"post","link":"https:\/\/codefresh.io\/docker-tutorial\/webinar-creating-efficient-docker-build-pipeline-java-apps\/","title":{"rendered":"Webinar: Creating an Efficient Docker Build Pipeline for Java Apps"},"content":{"rendered":"<p>In our last webinar, we showed how to create an efficient\u00a0Docker build pipeline for Java apps. We found that a lot of \u201cDocker for Java developers\u201d tutorials out there unintentionally encourage some Docker bad practices. So we had our Cheif Researcher, Alexei Ledenev, demonstrate how to craft the perfect Java-Docker build flow to consistently produce small, efficient, and secure Docker images.<\/p>\n<p><strong>View the webinar on-demand to learn:<\/strong><\/p>\n<ul>\n<li>The Docker Builder Pattern<\/li>\n<li>How\u00a0to define all pipeline steps and Dockerize them<\/li>\n<li>How to pass build context between steps<\/li>\n<li>How to Automate your build pipeline<\/li>\n<li>Java tips\/ best practices for each step<\/li>\n<\/ul>\n<p><iframe width=\"560\" height=\"315\" src=\"https:\/\/www.youtube.com\/embed\/hk_4N8AZ3b0\" frameborder=\"0\" allowfullscreen=\"allowfullscreen\"><\/iframe><\/p>\n<p><a href=\"https:\/\/www.slideshare.net\/Codefresh\/webinar-creating-an-effective-docker-build-pipeline-for-java-apps\">Link to Alexei&#8217;s slides<\/a><\/p>\n<h2>Highlights of Alexei\u2019s Talk:<\/h2>\n<h3>Common Pitfalls<\/h3>\n<p>Most new Docker users start with a &#8220;<strong>Naive Approach<\/strong>&#8221; when Dockerizing their application and use a familiar<span class=\"s2\">\u00a0VM build and install flow.<\/span>\u00a0In fact, there are many blog posts and articles teach you to do this. They usually start with some kind of Linux image, and first install all required packages, Oracle JDK, etc. Then they copy all project files into this box, run maven install, and define the command line or how the\u00a0app should be executed. This is a straight forward process but what you&#8217;re actually left with is a huge image size. In this case, the image is 1.3 GB in size and took me 30 minutes to build on my laptop.<\/p>\n<div><\/div>\n<div><\/div>\n<div>\n<pre class=\"lang:default decode:true\"># start from ubuntu\nFROM ubuntu:14.04\n\n# add required packages and java repository\nRUN apt-get update &amp;&amp; apt-get install -y python-software-properties software-properties-common\nRUN add-apt-repository ppa:webupd8team\/java\n\n# install Oracle JDK 8 with auto-accept license agreement\nRUN echo \"oracle-java8-installer shared\/accepted-oracle-license-v1-1 boolean true\" | debconf-set-selections\nRUN apt-get update &amp;&amp; apt-get install -y oracle-java8-installer maven\n\n# add ALL project files\nADD . \/usr\/local\/app\n\n# build Java application with Maven (fetch packages, compile, test and deploy)\nRUN cd \/usr\/local\/app &amp;&amp; mvn install\n\n# define default command to run the application\nCMD [\"\/usr\/bin\/java\", \"-jar\", \"-Dspring.profiles.active=test\", \"\/usr\/local\/app\/target\/spring-boot-rest-example-0.3.0.war\"]Anther approach \u201cstandard\u201d most people use is take image library, prepared images, install maven, when do one trick -add own maven project file, and install all dependencies, for every build docker tries to recreate this layer, if file had not been changed it will use cache from the previous build, in this case if didn\u2019t download diff dependencies it will be<\/pre>\n<div><\/div>\n<div>Another approach many people use is the &#8220;<strong>Standard Approach<\/strong>.&#8221; Meaning they take an official Docker image provided (by a company or community), in this example, it&#8217;s an OpenJDK image, they install maven, do one little trick -add a pom.xml file, and then install all dependencies. This step is\u00a0important because each command in a Dockerfile creates an additional layer. Docker will try to re-create this layer with each build. But if you add the\u00a0<b>pom.xml file<\/b>\u00a0it will use the cache from the\u00a0previous build if nothing has changed. \u00a0This allows us to slightly reduce the image size to 1.2 GB. It&#8217;s still big but slightly smaller than the last and now our build time is around 15 minutes.<\/div>\n<\/div>\n<div>\n<pre class=\"lang:default decode:true\">FROM java:8 \n\n# Install maven\nRUN apt-get update\nRUN apt-get install -y maven\n\nWORKDIR \/code\n\n# Prepare by downloading dependencies\nADD pom.xml \/code\/pom.xml\nRUN [\"mvn\", \"dependency:resolve\"]\nRUN [\"mvn\", \"verify\"]\n\n# Adding source, compile and package into a fat jar\nADD src \/code\/src\nRUN [\"mvn\", \"package\"]\n\nEXPOSE 4567\nCMD [\"\/usr\/bin\/java\", \"-jar\", \"-Dspring.profiles.active=test\", \"target\/spring-boot-rest-example-0.3.0.war\"]<\/pre>\n<\/div>\n<div><\/div>\n<div><strong>It&#8217;s important to understand containers are not VMs.\u00a0<\/strong><\/div>\n<div>\n<blockquote>\n<p class=\"p1\"><span class=\"s1\">\u201cA Linux container is nothing more than a process that runs on Linux. It shares a host kernel with other containerized processes.\u201d &#8211;<\/span>Joe Fernandes, Senior Director, OpenShift Product Management, Red Hat<\/p>\n<\/blockquote>\n<\/div>\n<div><\/div>\n<div>Once you think of your\u00a0application as a process, you need to ask -what is the bare minimum that is required to run my application? Using Docker technology you can pack all the files and tools needed to create your application process (the resource files, configuration files, etc). You can isolate the entire process in a separate container so that your app feels like it&#8217;s running alone.<\/div>\n<div>\n<h3 class=\"p1\"><span class=\"s1\">What is the bare minimum\u00a0<\/span><span class=\"s1\">required to run Java App?<\/span><\/h3>\n<\/div>\n<div>In this example, we need to package the following in order to create the process to run our Java application:<\/div>\n<div><\/div>\n<div>\n<ol class=\"ol1\">\n<li class=\"li1\"><span class=\"s2\">Base Image with C Runtime and Posix shell (Alexei recommends\u00a0<\/span><span class=\"s3\"><b>Alpine<\/b><\/span><span class=\"s2\">)<\/span><\/li>\n<li class=\"li1\"><span class=\"s2\">Java Runtime Environment (<\/span><span class=\"s3\"><b>OpenJDK JRE<\/b><\/span><span class=\"s2\">)<\/span><\/li>\n<li class=\"li1\"><span class=\"s2\">Application byte-code and resources (<\/span><span class=\"s3\"><b>app.jar<\/b><\/span><span class=\"s2\">)<\/span><\/li>\n<li class=\"li1\"><span class=\"s2\">3rd Party Libraries (<\/span><span class=\"s3\"><b>lib\/*.jar<\/b><\/span><span class=\"s2\">)<\/span><\/li>\n<li class=\"li2\"><span class=\"s2\">Optionally HTTP server (Alexei recommends\u00a0<\/span><span class=\"s3\"><b>Tomcat, Jetty, or Netty, <\/b>not enterprise servers since their design wasn&#8217;t built for containers<\/span><span class=\"s2\">) <\/span><\/li>\n<\/ol>\n<\/div>\n<h3>Why is your Docker image size important?<\/h3>\n<div>\n<ul class=\"ul1\">\n<li class=\"li1\"><b><\/b><span class=\"s2\">Time to build<\/span><\/li>\n<li class=\"li1\"><span class=\"s2\">Network latency<\/span><\/li>\n<li class=\"li1\"><span class=\"s2\">Storage<\/span><\/li>\n<li class=\"li1\"><span class=\"s2\">Service availability and elasticity<\/span><\/li>\n<li class=\"li1\"><span class=\"s2\">Security<\/span><\/li>\n<li class=\"li2\"><span class=\"s2\">Development agility<\/span><\/li>\n<\/ul>\n<\/div>\n<h3>\u00a0Docker Builder Pattern<\/h3>\n<div>Alexei explained how to use the Docker builder pattern to separate our build tools and runtime.<\/div>\n<div><\/div>\n<div><img class=\"aligncenter wp-image-2850\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/05\/Effective-Java-Docker-Pipeline.009-1024x768.jpeg\" alt=\"\" width=\"533\" height=\"399\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/05\/Effective-Java-Docker-Pipeline.009.jpeg 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2017\/05\/Effective-Java-Docker-Pipeline.009-300x225.jpeg 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2017\/05\/Effective-Java-Docker-Pipeline.009-768x576.jpeg 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2017\/05\/Effective-Java-Docker-Pipeline.009-437x328.jpeg 437w\" sizes=\"(max-width: 533px) 100vw, 533px\" \/><\/div>\n<h3>Java Docker Builder<\/h3>\n<p>Our Java Docker builder should contain the following:<\/p>\n<div>\n<ol class=\"ol1\">\n<li class=\"li1\"><span class=\"s2\">Base Image with C Runtime and Posix shell (<\/span><span class=\"s3\"><b>Alpine<\/b><\/span><span class=\"s2\">)<\/span><\/li>\n<li class=\"li1\"><span class=\"s2\">Java Development Kit (<\/span><span class=\"s3\"><b>OpenJDK<\/b><\/span><span class=\"s2\">)<\/span><\/li>\n<li class=\"li1\"><span class=\"s2\">Javac or other JVM compiler (Scala, Kotlin, \u2026)<\/span><\/li>\n<li class=\"li1\"><span class=\"s2\">Build Management Tool (Maven, SBT, Gradle, \u2026)<\/span><\/li>\n<li class=\"li2\"><span class=\"s2\">Linters, code scanners, test frameworks, test tools, <\/span><\/li>\n<\/ol>\n<\/div>\n<div>\u00a0Once you Dockerize your build environment you can deploy it and use it and run your app on any machine without the need to install anything manually. This eliminates the &#8220;it works on my machine&#8221; problem.<\/div>\n<div><\/div>\n<div>\n<h3 class=\"p1\"><span class=\"s1\">Maven Builder Dockerfile<\/span><\/h3>\n<\/div>\n<div>Our builder Dockerfile looks like this:<\/div>\n<div>\n<pre class=\"lang:default decode:true\">FROM openjdk:8-jdk-alpine\n\nRUN apk add --no-cache curl tar bash\n\nARG MAVEN_VERSION=3.3.9\nARG USER_HOME_DIR=\"\/root\"\n\nRUN mkdir -p \/usr\/share\/maven &amp;&amp; \\\n  curl -fsSL http:\/\/apache.osuosl.org\/maven\/maven-3\/$MAVEN_VERSION\/binaries\/apache-maven-$MAVEN_VERSION-bin.tar.gz | tar -xzC \/usr\/share\/maven --strip-components=1 &amp;&amp; \\\n  ln -s \/usr\/share\/maven\/bin\/mvn \/usr\/bin\/mvn\n\nENV MAVEN_HOME \/usr\/share\/maven\nENV MAVEN_CONFIG \"$USER_HOME_DIR\/.m2\"\n# speed up Maven JVM a bit\nENV MAVEN_OPTS=\"-XX:+TieredCompilation -XX:TieredStopAtLevel=1\"\n\nENTRYPOINT [\"\/usr\/bin\/mvn\"]\n\n# make source folder\nRUN mkdir -p \/usr\/src\/app\nWORKDIR \/usr\/src\/app\n\n# install maven dependency packages (keep in image)\nCOPY pom.xml \/usr\/src\/app\nRUN mvn -T 1C install &amp;&amp; rm -rf target\n\n# copy other source files (keep in image)\nCOPY src \/usr\/src\/app\/src<\/pre>\n<\/div>\n<div>Once we capture our build process, we can consistently produce the results (it captures the source code at a specific point in time so we won&#8217;t be impacted by any changes).<\/div>\n<div>\n<h3 class=\"p1\"><span class=\"s1\">Java App Dockerfile<\/span><\/h3>\n<\/div>\n<div>Our Java application Dockerfile is pretty simple because we are only including the bare minimum we need to run it. In this example, we only need the following 3 lines of code.<\/div>\n<div>\n<pre class=\"lang:default decode:true \">FROM openjdk:8-jre-alpine\n\nCOPY spring-boot-*.war \/app.war\n\nCMD [\"\/usr\/bin\/java\", \"-jar\", \"-Dspring.profiles.active=test\", \"\/app.war\"]<\/pre>\n<\/div>\n<div>So now our builder image is only <strong>263 MB,<\/strong> and our runtime image is <strong>143 MB<\/strong>. This is almost 10x smaller the 1st image.<\/div>\n<div>\n<h3 class=\"p1\"><span class=\"s1\">Build Pipeline Orchestration<\/span><\/h3>\n<\/div>\n<div>Once you have both Dockerfiles ready, you can automate your build pipeline.<\/div>\n<div><\/div>\n<div>Alexei explains how to automate it with a Makefile like this:<\/div>\n<div>\n<pre class=\"lang:default decode:true\">\u2026\n\nbuilder:\n\u00a0\u00a0\u00a0\u00a0docker build -t $(NS)\/builder:mvn -f Dockerfile.build .\n\nmvn-package: builder\n\u00a0\u00a0\u00a0\u00a0docker run -it --rm -v $(shell pwd)\/target:\/usr\/src\/app\/target $(NS)\/builder:mvn package -T 1C -o -Dmaven.test.skip=true\n\nmvn-test: builder\n\u00a0\u00a0\u00a0\u00a0docker run -it --rm -v $(shell pwd)\/target:\/usr\/src\/app\/target $(NS)\/builder:mvn -T 1C -o test\n\ndocker: \n\u00a0\u00a0\u00a0\u00a0docker build -t $(NS)\/$(REPO):$(VERSION) target\n\nbuild: builder\n\u00a0\u00a0\u00a0\u00a0make docker\n\npush:\n\u00a0\u00a0\u00a0\u00a0docker push $(NS)\/$(REPO):$(VERSION)\n\nrelease: build\n\u00a0\u00a0\u00a0\u00a0make push -e VERSION=$(VERSION)\n\n\u2026\n\ndefault: build<\/pre>\n<article class=\"post-2515 post type-post status-publish format-standard has-post-thumbnail category-docker-tutorial category-webinars entry\">\n<div class=\"entry-content\">\n<h3>Demo<\/h3>\n<\/div>\n<\/article>\n<p>In the demo, Alexei shows how to easily automate your pipeline using a Docker-native CI\/CD like <a href=\"https:\/\/codefresh.io\/?utm_medium=blog&amp;utm_campaign=Jave-Webinar&amp;utm_source=wordpress\">Codefresh<\/a>\u00a0to consistently produce small, efficient, and secure Docker images.<\/p>\n<p><em>(See demo \u2013 32 minutes 25 seconds of the webinar)<\/em><\/p>\n<\/div>\n<div>He shows two ways to automate your pipeline in Codefresh.<\/div>\n<p>&nbsp;<\/p>\n<div><\/div>\n<ol>\n<li>Using a <a href=\"https:\/\/docs.codefresh.io\/docs\/what-is-the-codefresh-yaml\">Codefresh YAML file<\/a> like this:\n<pre class=\"lang:default decode:true\">version: '1.0'\n\nsteps:\n\n  mvn_builder:\n    type: build\n    description: create Maven builder\n    dockerfile: Dockerfile.build\n    image_name: alexeiled\/mvn-builder\n\n  mvn_test:\n    description: run unit tests \n    image: ${{mvn_builder}}\n    commands:\n      - mvn -T 1C -o test\n  \n  mvn_package:\n    description: package application WAR \n    image: ${{mvn_builder}}\n    commands:\n      - mvn package -T 1C -o -Dmaven.test.skip=true\n\n  build_image:\n    type: build\n    description: create Docker image with application WAR\n    dockerfile: Dockerfile\n    working_directory: ${{main_clone}}\/target\n    image_name: alexei-led\/sbdemo\n\n  image_push:\n    type: push\n    description: push to DockerHub\n    candidate: '${{build_image}}'\n    tag: \u2018${{CF_BRANCH}}'\n<\/pre>\n<\/li>\n<li>Using the <a href=\"https:\/\/docs.codefresh.io\/docs\/getting-started-create-a-basic-pipeline\">Codefresh UI<\/a><\/li>\n<\/ol>\n<div><\/div>\n<div><\/div>\n<div><img class=\"aligncenter wp-image-2855\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/05\/Screen-Shot-2017-05-13-at-1.46.58-PM-1.png\" alt=\"\" width=\"755\" height=\"482\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/05\/Screen-Shot-2017-05-13-at-1.46.58-PM-1.png 920w, https:\/\/codefresh.io\/wp-content\/uploads\/2017\/05\/Screen-Shot-2017-05-13-at-1.46.58-PM-1-300x191.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2017\/05\/Screen-Shot-2017-05-13-at-1.46.58-PM-1-768x490.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2017\/05\/Screen-Shot-2017-05-13-at-1.46.58-PM-1-514x328.png 514w\" sizes=\"(max-width: 755px) 100vw, 755px\" \/><\/div>\n<div>The Codefresh cache allows us to speed up the build process. After all\u00a0the tests have passed, Codefresh\u00a0takes the produced VAR files and packages them into a final Docker image. It then tags and labels the image with the git branch and commit info, and pushes it to Alexei&#8217;s private Codefresh registry (or any registry you choose).<\/div>\n<div>\n<h3>Additional Resources<\/h3>\n<\/div>\n<ul>\n<li>Check out Alexei&#8217;s blog post &#8211; <a href=\"https:\/\/codefresh.io\/blog\/java_docker_pipeline\/\">Crafting perfect Java Docker build flow<\/a><\/li>\n<li>Join our next <a href=\"https:\/\/codefresh.io\/events\/\">in-person or online event<\/a><\/li>\n<li><a href=\"https:\/\/codefresh.io\/request-free-setup\/?utm_medium=blog&amp;utm_campaign=Jave-Webinar&amp;utm_source=wordpress\">Request a one-on-one onboarding session<\/a>\u00a0with our support engineers to configure your automated pipeline in Codefresh.<\/li>\n<li>Email us with questions, feedback, or webinar topic requests at <a href=\"mailto:contact@codefresh.io\">contact@codefresh.io<\/a><\/li>\n<\/ul>\n<div><\/div>\n<input class=\"fooboxshare_post_id\" type=\"hidden\" value=\"2845\"\/>","protected":false},"excerpt":{"rendered":"<p>In our last webinar, we showed how to create an efficient\u00a0Docker build pipeline for Java apps. We found that a lot of \u201cDocker for Java developers\u201d tutorials out there unintentionally encourage some Docker bad practices. So we had our Cheif Researcher, Alexei Ledenev, demonstrate how to craft the perfect Java-Docker build flow to consistently produce &hellip; <a href=\"https:\/\/codefresh.io\/docker-tutorial\/webinar-creating-efficient-docker-build-pipeline-java-apps\/\">Read more<\/a><\/p>\n","protected":false},"author":27,"featured_media":2858,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[8],"tags":[86],"yoast_head":"<!-- This site is optimized with the Yoast SEO Premium plugin v17.9 (Yoast SEO v18.4.1) - https:\/\/yoast.com\/wordpress\/plugins\/seo\/ -->\n<title>Webinar: Creating an Efficient Docker Build Pipeline for Java Apps | Codefresh<\/title>\n<meta name=\"robots\" content=\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\" \/>\n<link rel=\"canonical\" href=\"https:\/\/codefresh.io\/docker-tutorial\/webinar-creating-efficient-docker-build-pipeline-java-apps\/\" \/>\n<meta property=\"og:locale\" content=\"en_US\" \/>\n<meta property=\"og:type\" content=\"article\" \/>\n<meta property=\"og:title\" content=\"Webinar: Creating an Efficient Docker Build Pipeline for Java Apps\" \/>\n<meta property=\"og:description\" content=\"In our last webinar, we showed how to create an efficient\u00a0Docker build pipeline for Java apps. We found that a lot of \u201cDocker for Java developers\u201d tutorials out there unintentionally encourage some Docker bad practices. So we had our Cheif Researcher, Alexei Ledenev, demonstrate how to craft the perfect Java-Docker build flow to consistently produce &hellip; Read more\" \/>\n<meta property=\"og:url\" content=\"https:\/\/codefresh.io\/docker-tutorial\/webinar-creating-efficient-docker-build-pipeline-java-apps\/\" \/>\n<meta property=\"og:site_name\" content=\"Codefresh\" \/>\n<meta property=\"article:publisher\" content=\"https:\/\/www.facebook.com\/codefresh.io\" \/>\n<meta property=\"article:published_time\" content=\"2017-05-13T22:39:58+00:00\" \/>\n<meta property=\"article:modified_time\" content=\"2022-02-09T14:50:39+00:00\" \/>\n<meta property=\"og:image\" content=\"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/05\/webinar-java.png\" \/>\n\t<meta property=\"og:image:width\" content=\"1534\" \/>\n\t<meta property=\"og:image:height\" content=\"401\" \/>\n\t<meta property=\"og:image:type\" content=\"image\/png\" \/>\n<meta name=\"twitter:card\" content=\"summary_large_image\" \/>\n<meta name=\"twitter:creator\" content=\"@todaywasawesome\" \/>\n<meta name=\"twitter:site\" content=\"@codefresh\" \/>\n<meta name=\"twitter:label1\" content=\"Written by\" \/>\n\t<meta name=\"twitter:data1\" content=\"Dan Garfield\" \/>\n\t<meta name=\"twitter:label2\" content=\"Est. reading time\" \/>\n\t<meta name=\"twitter:data2\" content=\"7 minutes\" \/>\n<script type=\"application\/ld+json\" class=\"yoast-schema-graph\">{\"@context\":\"https:\/\/schema.org\",\"@graph\":[{\"@type\":\"Organization\",\"@id\":\"https:\/\/codefresh.io\/#organization\",\"name\":\"Codefresh\",\"url\":\"https:\/\/codefresh.io\/\",\"sameAs\":[\"https:\/\/www.facebook.com\/codefresh.io\",\"https:\/\/www.linkedin.com\/company\/codefresh\",\"https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg\",\"https:\/\/twitter.com\/codefresh\"],\"logo\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#logo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"width\":800,\"height\":800,\"caption\":\"Codefresh\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/#logo\"}},{\"@type\":\"WebSite\",\"@id\":\"https:\/\/codefresh.io\/#website\",\"url\":\"https:\/\/codefresh.io\/\",\"name\":\"Codefresh\",\"description\":\"\",\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"potentialAction\":[{\"@type\":\"SearchAction\",\"target\":{\"@type\":\"EntryPoint\",\"urlTemplate\":\"https:\/\/codefresh.io\/?s={search_term_string}\"},\"query-input\":\"required name=search_term_string\"}],\"inLanguage\":\"en-US\"},{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/webinar-creating-efficient-docker-build-pipeline-java-apps\/#primaryimage\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/05\/webinar-java.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/05\/webinar-java.png\",\"width\":1534,\"height\":401},{\"@type\":\"WebPage\",\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/webinar-creating-efficient-docker-build-pipeline-java-apps\/#webpage\",\"url\":\"https:\/\/codefresh.io\/docker-tutorial\/webinar-creating-efficient-docker-build-pipeline-java-apps\/\",\"name\":\"Webinar: Creating an Efficient Docker Build Pipeline for Java Apps | Codefresh\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/#website\"},\"primaryImageOfPage\":{\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/webinar-creating-efficient-docker-build-pipeline-java-apps\/#primaryimage\"},\"datePublished\":\"2017-05-13T22:39:58+00:00\",\"dateModified\":\"2022-02-09T14:50:39+00:00\",\"breadcrumb\":{\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/webinar-creating-efficient-docker-build-pipeline-java-apps\/#breadcrumb\"},\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"ReadAction\",\"target\":[\"https:\/\/codefresh.io\/docker-tutorial\/webinar-creating-efficient-docker-build-pipeline-java-apps\/\"]}]},{\"@type\":\"BreadcrumbList\",\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/webinar-creating-efficient-docker-build-pipeline-java-apps\/#breadcrumb\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"name\":\"Home\",\"item\":\"https:\/\/codefresh.io\/\"},{\"@type\":\"ListItem\",\"position\":2,\"name\":\"Webinar: Creating an Efficient Docker Build Pipeline for Java Apps\"}]},{\"@type\":\"Article\",\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/webinar-creating-efficient-docker-build-pipeline-java-apps\/#article\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/webinar-creating-efficient-docker-build-pipeline-java-apps\/#webpage\"},\"author\":{\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/17aca6389be0f81b999f1b138a0b44a4\"},\"headline\":\"Webinar: Creating an Efficient Docker Build Pipeline for Java Apps\",\"datePublished\":\"2017-05-13T22:39:58+00:00\",\"dateModified\":\"2022-02-09T14:50:39+00:00\",\"mainEntityOfPage\":{\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/webinar-creating-efficient-docker-build-pipeline-java-apps\/#webpage\"},\"wordCount\":942,\"commentCount\":0,\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/webinar-creating-efficient-docker-build-pipeline-java-apps\/#primaryimage\"},\"thumbnailUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/05\/webinar-java.png\",\"keywords\":[\"java\"],\"articleSection\":[\"Docker Tutorials\"],\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"CommentAction\",\"name\":\"Comment\",\"target\":[\"https:\/\/codefresh.io\/docker-tutorial\/webinar-creating-efficient-docker-build-pipeline-java-apps\/#respond\"]}]},{\"@type\":\"Person\",\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/17aca6389be0f81b999f1b138a0b44a4\",\"name\":\"Dan Garfield\",\"image\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#personlogo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/secure.gravatar.com\/avatar\/d4a38809809980ed49dc7e696a8e3938?s=96&d=blank&r=g\",\"contentUrl\":\"https:\/\/secure.gravatar.com\/avatar\/d4a38809809980ed49dc7e696a8e3938?s=96&d=blank&r=g\",\"caption\":\"Dan Garfield\"},\"description\":\"Dan is the Co-Founder and Chief Open Source Officer at Codefresh. His work in open source includes being an Argo Maintainer, and co-chair of the GitOps Working Group. As a technology leader with a background in full-stack engineering, evangelism, and communications, he led Codefresh's go-to-market strategy and now leads open source strategy. You can follow him at twitter.com\/todaywasawesome\",\"sameAs\":[\"https:\/\/twitter.com\/todaywasawesome\"],\"url\":\"https:\/\/codefresh.io\/author\/dang\/\"}]}<\/script>\n<!-- \/ Yoast SEO Premium plugin. -->","yoast_head_json":{"title":"Webinar: Creating an Efficient Docker Build Pipeline for Java Apps | Codefresh","robots":{"index":"index","follow":"follow","max-snippet":"max-snippet:-1","max-image-preview":"max-image-preview:large","max-video-preview":"max-video-preview:-1"},"canonical":"https:\/\/codefresh.io\/docker-tutorial\/webinar-creating-efficient-docker-build-pipeline-java-apps\/","og_locale":"en_US","og_type":"article","og_title":"Webinar: Creating an Efficient Docker Build Pipeline for Java Apps","og_description":"In our last webinar, we showed how to create an efficient\u00a0Docker build pipeline for Java apps. We found that a lot of \u201cDocker for Java developers\u201d tutorials out there unintentionally encourage some Docker bad practices. So we had our Cheif Researcher, Alexei Ledenev, demonstrate how to craft the perfect Java-Docker build flow to consistently produce &hellip; Read more","og_url":"https:\/\/codefresh.io\/docker-tutorial\/webinar-creating-efficient-docker-build-pipeline-java-apps\/","og_site_name":"Codefresh","article_publisher":"https:\/\/www.facebook.com\/codefresh.io","article_published_time":"2017-05-13T22:39:58+00:00","article_modified_time":"2022-02-09T14:50:39+00:00","og_image":[{"width":1534,"height":401,"url":"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/05\/webinar-java.png","type":"image\/png"}],"twitter_card":"summary_large_image","twitter_creator":"@todaywasawesome","twitter_site":"@codefresh","twitter_misc":{"Written by":"Dan Garfield","Est. reading time":"7 minutes"},"schema":{"@context":"https:\/\/schema.org","@graph":[{"@type":"Organization","@id":"https:\/\/codefresh.io\/#organization","name":"Codefresh","url":"https:\/\/codefresh.io\/","sameAs":["https:\/\/www.facebook.com\/codefresh.io","https:\/\/www.linkedin.com\/company\/codefresh","https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg","https:\/\/twitter.com\/codefresh"],"logo":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#logo","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","width":800,"height":800,"caption":"Codefresh"},"image":{"@id":"https:\/\/codefresh.io\/#logo"}},{"@type":"WebSite","@id":"https:\/\/codefresh.io\/#website","url":"https:\/\/codefresh.io\/","name":"Codefresh","description":"","publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"potentialAction":[{"@type":"SearchAction","target":{"@type":"EntryPoint","urlTemplate":"https:\/\/codefresh.io\/?s={search_term_string}"},"query-input":"required name=search_term_string"}],"inLanguage":"en-US"},{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/docker-tutorial\/webinar-creating-efficient-docker-build-pipeline-java-apps\/#primaryimage","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/05\/webinar-java.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/05\/webinar-java.png","width":1534,"height":401},{"@type":"WebPage","@id":"https:\/\/codefresh.io\/docker-tutorial\/webinar-creating-efficient-docker-build-pipeline-java-apps\/#webpage","url":"https:\/\/codefresh.io\/docker-tutorial\/webinar-creating-efficient-docker-build-pipeline-java-apps\/","name":"Webinar: Creating an Efficient Docker Build Pipeline for Java Apps | Codefresh","isPartOf":{"@id":"https:\/\/codefresh.io\/#website"},"primaryImageOfPage":{"@id":"https:\/\/codefresh.io\/docker-tutorial\/webinar-creating-efficient-docker-build-pipeline-java-apps\/#primaryimage"},"datePublished":"2017-05-13T22:39:58+00:00","dateModified":"2022-02-09T14:50:39+00:00","breadcrumb":{"@id":"https:\/\/codefresh.io\/docker-tutorial\/webinar-creating-efficient-docker-build-pipeline-java-apps\/#breadcrumb"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https:\/\/codefresh.io\/docker-tutorial\/webinar-creating-efficient-docker-build-pipeline-java-apps\/"]}]},{"@type":"BreadcrumbList","@id":"https:\/\/codefresh.io\/docker-tutorial\/webinar-creating-efficient-docker-build-pipeline-java-apps\/#breadcrumb","itemListElement":[{"@type":"ListItem","position":1,"name":"Home","item":"https:\/\/codefresh.io\/"},{"@type":"ListItem","position":2,"name":"Webinar: Creating an Efficient Docker Build Pipeline for Java Apps"}]},{"@type":"Article","@id":"https:\/\/codefresh.io\/docker-tutorial\/webinar-creating-efficient-docker-build-pipeline-java-apps\/#article","isPartOf":{"@id":"https:\/\/codefresh.io\/docker-tutorial\/webinar-creating-efficient-docker-build-pipeline-java-apps\/#webpage"},"author":{"@id":"https:\/\/codefresh.io\/#\/schema\/person\/17aca6389be0f81b999f1b138a0b44a4"},"headline":"Webinar: Creating an Efficient Docker Build Pipeline for Java Apps","datePublished":"2017-05-13T22:39:58+00:00","dateModified":"2022-02-09T14:50:39+00:00","mainEntityOfPage":{"@id":"https:\/\/codefresh.io\/docker-tutorial\/webinar-creating-efficient-docker-build-pipeline-java-apps\/#webpage"},"wordCount":942,"commentCount":0,"publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"image":{"@id":"https:\/\/codefresh.io\/docker-tutorial\/webinar-creating-efficient-docker-build-pipeline-java-apps\/#primaryimage"},"thumbnailUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/05\/webinar-java.png","keywords":["java"],"articleSection":["Docker Tutorials"],"inLanguage":"en-US","potentialAction":[{"@type":"CommentAction","name":"Comment","target":["https:\/\/codefresh.io\/docker-tutorial\/webinar-creating-efficient-docker-build-pipeline-java-apps\/#respond"]}]},{"@type":"Person","@id":"https:\/\/codefresh.io\/#\/schema\/person\/17aca6389be0f81b999f1b138a0b44a4","name":"Dan Garfield","image":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#personlogo","inLanguage":"en-US","url":"https:\/\/secure.gravatar.com\/avatar\/d4a38809809980ed49dc7e696a8e3938?s=96&d=blank&r=g","contentUrl":"https:\/\/secure.gravatar.com\/avatar\/d4a38809809980ed49dc7e696a8e3938?s=96&d=blank&r=g","caption":"Dan Garfield"},"description":"Dan is the Co-Founder and Chief Open Source Officer at Codefresh. His work in open source includes being an Argo Maintainer, and co-chair of the GitOps Working Group. As a technology leader with a background in full-stack engineering, evangelism, and communications, he led Codefresh's go-to-market strategy and now leads open source strategy. You can follow him at twitter.com\/todaywasawesome","sameAs":["https:\/\/twitter.com\/todaywasawesome"],"url":"https:\/\/codefresh.io\/author\/dang\/"}]}},"acf":[],"_links":{"self":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/2845"}],"collection":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/users\/27"}],"replies":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/comments?post=2845"}],"version-history":[{"count":2,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/2845\/revisions"}],"predecessor-version":[{"id":21369,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/2845\/revisions\/21369"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media\/2858"}],"wp:attachment":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media?parent=2845"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/categories?post=2845"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/tags?post=2845"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}