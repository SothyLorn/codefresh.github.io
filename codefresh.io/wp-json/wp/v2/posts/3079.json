{"id":3079,"date":"2017-06-06T14:15:15","date_gmt":"2017-06-06T14:15:15","guid":{"rendered":"https:\/\/codefresh.io\/?p=3079"},"modified":"2022-02-11T19:00:39","modified_gmt":"2022-02-11T19:00:39","slug":"debug_node_in_docker","status":"publish","type":"post","link":"https:\/\/codefresh.io\/docker-tutorial\/debug_node_in_docker\/","title":{"rendered":"Debugging remote Node.js application running in a Docker container"},"content":{"rendered":"<h2>Teaser<\/h2>\n<p>Suppose you want to debug a\u00a0Node.js application already running on a remote machine inside Docker container. And would like to do it without modifying command arguments (enabling <code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">debug<\/code> mode) and opening remote Node.js debugger agent port to the whole world.<\/p>\n<p><strong>I bet you didn&#8217;t know that it&#8217;s possible and also have no idea how to do it.<\/strong><\/p>\n<p>I encourage you to continue reading this post\u00a0if you are eager to learn some new cool stuff.<\/p>\n<h2>The TdodoMVC demo application<\/h2>\n<p>Once you are done, please go ahead and <strong><a href=\"https:\/\/g.codefresh.io\/signup?utm_source=Blog&amp;utm_medium=Post&amp;utm_campaign=DebuggingT\">create a free Codefresh account<\/a><\/strong><span style=\"font-weight: 400;\"> to start building, testing and deploying Docker images faster than ever before.<\/span><\/p>\n<p>I&#8217;m going to use a\u00a0<a href=\"https:\/\/github.com\/alexei-led\/todomvc-express\">fork<\/a> of <strong>TodoMVC<\/strong> Node.js application (by Gleb Bahmutov) as a demo application for this blog post. Feel free to clone and play with this repository.<\/p>\n<p>Here is the <code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">Dockerfile<\/code>, I&#8217;ve added, for TodoMVC application. It allows to run TodoMVC application inside a Docker container.<\/p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">FROM alpine:3.5\r\n\r\n# install node\r\nRUN apk add --no-cache nodejs-current tini\r\n\r\nRUN mkdir -p \/usr\/src\/app\r\nWORKDIR \/usr\/src\/app\r\n\r\n# Build time argument to set NODE_ENV ('production'' by default)\r\nARG NODE_ENV\r\nENV NODE_ENV ${NODE_ENV:-production}\r\n\r\n# install npm packages: clean obsolete files\r\nCOPY package.json \/usr\/src\/app\/\r\nRUN npm config set depth 0 &amp;&amp; \\\r\nnpm install &amp;&amp; \\\r\nnpm cache clean &amp;&amp; \\\r\nrm -rf \/tmp\/*\r\n\r\n# copy source files\r\nCOPY . \/usr\/src\/app\r\n\r\nEXPOSE 3000\r\n\r\n# Set tini as entrypoint\r\nENTRYPOINT [\"\/sbin\/tini\", \"--\"]\r\n\r\nCMD [ \"npm\", \"start\" ]\r\n\r\n# add VCS labels for code sync and nice reports\r\nARG VCS_REF=\"local\"\r\nLABEL org.label-schema.vcs-ref=$VCS_REF \\\r\norg.label-schema.vcs-url=\"https:\/\/github.com\/alexei-led\/todomvc-express.git\"<\/pre>\n<h4>Building and Running TodoMVC in a Docker container:<\/h4>\n<p>To build a new Docker image for TodoMVC application, run the <code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">docker build<\/code> command.<\/p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">$ # build Docker image; set VCS_REF to current HEAD commit (short)\r\n$ docker build -t local\/todomvc --build-arg VCS_REF=`git rev-parse --short HEAD` .\r\n$ # run TodoMVC in a Docker container\r\n$ docker run -d -p 3000:3000 --name todomvc local\/todomvc node src\/start.js<\/pre>\n<h2>The Plan<\/h2>\n<p><strong>Final Goal<\/strong> &#8211; I would like to be able to attach a Node.js debugger to a Node.js application already up and running inside a Docker container, running on remote host machine in AWS cloud, without modifying the application, container, container configuration, or restarting it with additional <code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">debug<\/code> flags. Imagine that the application is running and there is some problem happening right now &#8211; I want to connect to it with debugger and start looking at the problem.<\/p>\n<p>So, I need a plan &#8211; a step-by-step flow that will help me to achieve the final goal.<\/p>\n<p>Let&#8217;s start with exploring the inventory.<\/p>\n<p>On the server (AWS EC2 VM) machine, I have a Node.js application running inside a Docker container. On the client (my laptop), I have an IDE (Visual Studio Code, in my case), Node.js application code (<code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">git pull\/clone<\/code>), and a Node.js debugger.<\/p>\n<p>So, here is my plan:<\/p>\n<ol>\n<li>Set already running application to <code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">debug<\/code> mode<\/li>\n<li>Expose a new Node.js debugger agent port to enable remote debugging in a secure way<\/li>\n<li>Syncronize client-server code: both should be on the same commit in a <code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">git<\/code> tree<\/li>\n<li>Attach a local Node.js debugger to the\u00a0Node.js debugger agent port on remote server and do it in a secure way<\/li>\n<li>And, if everything works, I should be able to perform regular debugging tasks, like setting breakpoints, inspecting variables, pausing execution and others.<\/li>\n<\/ol>\n<p><img class=\"size-full wp-image-3084 aligncenter\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/06\/debug_docker_node.png\" alt=\"\" width=\"880\" height=\"778\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/06\/debug_docker_node.png 880w, https:\/\/codefresh.io\/wp-content\/uploads\/2017\/06\/debug_docker_node-300x265.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2017\/06\/debug_docker_node-768x679.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2017\/06\/debug_docker_node-371x328.png 371w\" sizes=\"(max-width: 880px) 100vw, 880px\" \/><\/p>\n<h3>Step 1: set already running Node.js application to the <code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">debug<\/code> mode<\/h3>\n<blockquote><p>\n  The V8 debugger can be enabled and accessed either by starting Node with the <code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">--debug<\/code> command-line flag or by signaling an existing Node process with <code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">SIGUSR1<\/code>. (Node API documentation)\n<\/p><\/blockquote>\n<p>Cool! So, in order to switch on Node debugger agent, I just need to send the <code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">SIGUSR1<\/code> signal to the Node.js process of TodoMVC application. Remember, it&#8217;s running inside a Docker container. What command can I use to send process signals to an application running in a Docker container?<\/p>\n<p>The <code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">docker kill<\/code>command &#8211; is my choice! This command does not actually &#8220;kill&#8221; the <code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">PID 1<\/code> process, running in a Docker container, but sends a\u00a0<a href=\"https:\/\/en.wikipedia.org\/wiki\/Unix_signal\">Unix signal<\/a> to it (by default it sends <code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">SIGKILL<\/code>).<\/p>\n<h4>Setting TodoMVC into <code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">debug<\/code> mode<\/h4>\n<p>So, all I need to do is to send <code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">SIGUSR1<\/code> to my TodoMVC application running inside <code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">todomvc<\/code> Docker container.<\/p>\n<p>There are two ways to do this:<\/p>\n<ol>\n<li>Use <code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">docker kill --signal<\/code> command to send <code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">SIGUSR1<\/code> to <code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">PID 1<\/code> process running inside Docker container, and if it&#8217;s a &#8220;proper&#8221; (signal forwarding done right) init application (like <code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">tini<\/code>), than this will work<\/li>\n<li>Or, execute <code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">kill -s SIGUSR1<\/code> inside already running Docker container, sending <code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">SIGUSR1<\/code> signal to the main Node.js process.<\/li>\n<\/ol>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">$ # send SIGUSR1 with docker kill (if using proper init process)\r\n$ docker kill --signal SIGUSR1 todomvc\r\n$ # OR run kill command for node process inside todomvc container\r\n$ docker exec -it todomvc sh -c 'kill -s SIGUSR1 $(pidof -s node)'\r\n<\/pre>\n<p>Let&#8217;s verify that Node application is set into <code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">debug<\/code> mode.<\/p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">$ docker logs todomvc\r\n\r\nTodoMVC server listening at http:\/\/:::3000\r\nemitting 2 todos\r\nserver has new 2 todos\r\nGET \/ 200 31.439 ms - 3241\r\nGET \/app.css 304 4.907 ms - -\r\nStarting debugger agent.\r\nDebugger listening on 127.0.0.1:5858\r\n<\/pre>\n<p>As you can see the Node.js debugger agent was started, but it can accept connections only from the <code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">localhost<\/code>,\u00a0 see the last output line: <code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">Debugger listening on 127.0.0.1:5858<\/code><\/p>\n<h3>Step 2: expose Node debug port<\/h3>\n<p>In order to attach a remote Node.js debugger to a Node application, running in the <code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">debug<\/code> mode, I need:<\/p>\n<ol>\n<li>Allow connection to debugger agent from any (or specific) IP (or IP range)<\/li>\n<li>Open port of Node.js debugger agent outside of Docker container<\/li>\n<\/ol>\n<p>How to do it when an application is already running in a\u00a0Docker container and a Node.js debugger agent is ready to talk only with a Node.js debugger running on the same machine, plus a Node.js debugger agent port is not accessible from outside of the Docker container?<\/p>\n<p>Of course\u00a0it&#8217;s possible to start every Node.js Docker container with exposed debugger port and allow connection from any IP (using <code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">--debug-port<\/code> and <code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">--debug<\/code> Node.js flags), but we are not looking for easy ways :).<\/p>\n<p>It&#8217;s not a good idea from a security point of view (allowing unprotected access to a Node.js debugger). Also, if I restart an already running application with debug flags, I&#8217;m going to loose the current execution context and may not be able to reproduce the problem I wanted to debug.<\/p>\n<p>I need a better solution!<\/p>\n<p>Unfortunately, Docker does not allow to expose an additional port for already running Docker container. So, I need somehow to connect to a running container network and expose a new port for Node.js debugger agent.<\/p>\n<p>Also, it is not possible to tell a Node.js debugger agent to accept connections from different IP addresses, when Node.js process was already started.<\/p>\n<p>Both of above problems can be solved with help of small the Linux utility called <code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">socat<\/code> (SOcket CAT). This is just like the <code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">netcat<\/code> but with security in mind (e.g., it support chrooting) and works over various protocols and through files, pipes, devices, TCP sockets, Unix sockets, a client for SOCKS4, proxy CONNECT, or SSL etc.<\/p>\n<p>From <code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">socat<\/code> man page:<\/p>\n<blockquote><p>\n  <code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">socat<\/code> is a command line based utility that establishes two bidirectional byte streams and transfers data between them. Because the streams can be constructed from a large set of different types of data sinks and sources (see address types), and because lots of address options may be applied to the streams, <code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">socat<\/code> can be used for many different purposes.\n<\/p><\/blockquote>\n<p>Exactly, what I need!<\/p>\n<p>So, here is the plan: I will run a new Docker container with the <code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">socat<\/code> utility onboard, and configure Node.js debugger port forwarding for TodoMVC container.<\/p>\n<p><code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">socat.Dockerfile<\/code>:<\/p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">Dockerfile\r\nFROM alpine:3.5\r\nRUN apk add --no-cache socat\r\nCMD socat -h<\/pre>\n<h4>Building socat Docker container<\/h4>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">$ docker build -t local\/socat - &lt; socat.Dockerfile<\/pre>\n<h4>Allow connection to Node debugger agent from any IP<\/h4>\n<p>I\u00a0need to run a &#8220;sidecar&#8221; <code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">socat<\/code> container in the same network namespace as the <code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">todomvc<\/code> container and define a port forwarding.<\/p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">$ # define local port forwarding\r\n$ docker run -d --name socat-nid --network=container:todomvc local\/socat socat TCP-LISTEN:4848,fork TCP:127.0.0.1:5858\r\n<\/pre>\n<p>Now any traffic that arrives at <code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">4848<\/code> port will be routed to the Node.js debugger agent listening on <code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">127.0.0.1:5858<\/code>. The <code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">4848<\/code> port can accept traffic from any IP.<br \/>\nIt&#8217;s also possible to use an IP range to restrict connection to the <code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">socat<\/code> listening port, adding <code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">range=&amp;lt;ANY IP RANGE&amp;gt;<\/code> option.<\/p>\n<h4>Exposing Node.js debugger port from Docker container<\/h4>\n<p>First, we will get IP of <code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">todomvc<\/code> Docker container.<\/p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">$ # get IP of todomvc container\r\n$ TODOMVC_IP=$(docker inspect -f \"{{.NetworkSettings.IPAddress}}\" todomvc)\r\n<\/pre>\n<p>Then, configure port forwarding to the &#8220;sidecar&#8221; <code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">socat<\/code> port, we define previously, running on the same network as the <code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">todomvc<\/code> container.<\/p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">$ # run socat container to expose Node.js debugger agent port forwarder\r\n$ docker run -d -p 5858:5858 --name socat local\/socat socat TCP-LISTEN:5858,fork TCP:${TODOMVC_IP}:4848\r\n<\/pre>\n<p>Any traffic that will arrive at the<span style=\"font-family: monospace;\">\u00a0<code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">5858<\/code><\/span>\u00a0port on the Docker host will be forwarded, first, to the <code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">4848<\/code> socat port and then to the Node.js debugger agent running inside the <code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">todomvc<\/code> Docker container.<\/p>\n<h4>Exposing Node.js debugger port for remote access<\/h4>\n<p>In most cases, I would like to debug an application running on a remote machine (AWS EC2 instance, for example). I also do not want to expose a Node.js debugger agent port unprotected to the whole world.<\/p>\n<p>One possible and working solution is to use SSH tunneling to access this port.<\/p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">$ # Open SSH Tunnel to gain access to servers port 5858. Set `SSH_KEY_FILE` to ssh key location or add it to ssh-agent\r\n$ #\r\n$ # open an ssh tunnel, send it to the bg, and wait 20 seconds for connections\r\n$ # once all connections are closed after 20 seconds then close the tunnel\r\n$ ssh -i ${SSH_KEY_FILE} -f -o ExitOnForwardFailure=yes -L 5858:127.0.0.1:5858 ec2_user@some.ec2.host.com sleep 20\r\n<\/pre>\n<p>Now all traffic to the <code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">localhost:5858<\/code> will be tunneled over <code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">SSH<\/code> to the remote Docker host machine and after some <code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">socat<\/code> forwarding to the Node.js debugger agent running inside the <code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">todomvc<\/code> container.<\/p>\n<h3>Step 3: Synchronizing on the same code commit<\/h3>\n<p>In order to be able to debug a remote application, you need to make sure that you are using the same code in your IDE as one that is running on remote server.<\/p>\n<p>I will try to automate this step too. Remember the <code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">LABEL<\/code> command, I&#8217;ve used in TodoMVC <code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">Dockerfile<\/code>?<\/p>\n<p>These labels help me to identify git repository and commit for the application Docker image:<\/p>\n<ol>\n<li><code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">org.label-schema.vcs-ref<\/code> &#8211; contains short SHA for a\u00a0<code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">HEAD<\/code> commit<\/li>\n<li><code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">org.label-schema.vcs-url<\/code> &#8211; contains an application git repository URL (I can use in <code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">clone\/pull<\/code>)<\/li>\n<\/ol>\n<p>I&#8217;m using (Label Schema Convention)[http:\/\/label-schema.org\/rc1\/], since I really like it and find it useful, but you can select any other convention too.<\/p>\n<p>This approach allows me, for each, properly labeled, Docker image, to identify the application code repository and the commit it was created from.<\/p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">$ # get git repository url form Docker image\r\n$ GIT_URL=$(docker inspect local\/todomvc | jq -r '.[].ContainerConfig.Labels.\"org.label-schema.vcs-url\"')\r\n$ # get git commit from Docker image\r\n$ GIT_COMMIT=$(docker inspect local\/todomvc | jq -r '.[].ContainerConfig.Labels.\"org.label-schema.vcs-ref\"')\r\n$\r\n$ # clone git repository, if needed\r\n$ git clone $GIT_URL\r\n$ # set HEAD to same commit as server\r\n$ git checkout $GIT_COMMIT\r\n<\/pre>\n<p>Now, both my local development environment and remote application are on the same git commit. And I can start to debug my code, finally!<\/p>\n<h3>Step 4: Attaching local Node.js debugger to debugger agent port<\/h3>\n<p>To start debugging, I need to configure my IDE. In my case, it&#8217;s <a href=\"https:\/\/code.visualstudio.com\/\">Visual Studio Code<\/a> and I need to add a new <code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">Launch<\/code> configuration.<\/p>\n<p>This launch configuration specifies remote debugger server and port to attach and remote location for application source files, which should be in sync with local files (see the previous step).<\/p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"json\">{\r\n\/\/ For more information about Node.js debug attributes, visit: https:\/\/go.microsoft.com\/fwlink\/?linkid=830387\r\n\"version\": \"0.2.0\",\r\n\"configurations\": [\r\n{\r\n\"type\": \"node\",\r\n\"request\": \"attach\",\r\n\"name\": \"Debug Remote Docker\",\r\n\"address\": \"127.0.0.1\",\r\n\"port\": 5858,\r\n\"localRoot\": \"${workspaceRoot}\/\",\r\n\"remoteRoot\": \"\/usr\/src\/app\/\"\r\n}\r\n]\r\n}\r\n<\/pre>\n<h2>Summary<\/h2>\n<p>And finally, I&#8217;ve met my goal: I&#8217;m able to attach a Node.js debugger to a Node.js application, that is already up and running in a Docker container on a remote machine. It was a long journey to find the proper solution, but after I found it, the process does not look complex at all.<\/p>\n<p>Now, once I meet a new problem in our environment I can easily attach the Node.js debugger to the running application and start exploring the problem. Nice, isn&#8217;t it?<\/p>\n<p>I&#8217;ve recorded a short movie, just to demonstrate all steps and prove that things are working fluently, exactly as I&#8217;ve described in this post.<\/p>\n<p><a href=\"http:\/\/www.youtube.com\/watch?v=WYOfNTJmE_4\"><img src=\"http:\/\/img.youtube.com\/vi\/WYOfNTJmE_4\/0.jpg\" alt=\"demo\" \/><\/a><\/p>\n<hr \/>\n<p>Hope, you find this post useful. I look forward to your comments and any questions you have.\u00a0Before you go, don\u2019t forget to <a href=\"https:\/\/g.codefresh.io\/signup?utm_source=Blog&amp;utm_medium=Post&amp;utm_campaign=DebuggingB\"><span style=\"font-weight: 400;\"><strong>create a free Codefresh account<\/strong><\/span><\/a><span style=\"font-weight: 400;\"> to start building, testing and deploying Docker images faster than ever before.<\/span><\/p>\n<p>&nbsp;<\/p>\n<p><a href=\"https:\/\/g.codefresh.io\/signup?utm_source=Blog&amp;utm_medium=Post&amp;utm_campaign=BannerB\"><img class=\"size-full wp-image-5645 aligncenter\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2016\/09\/Pasted-image-at-2017_11_23-04_46-PM.png\" alt=\"\" width=\"728\" height=\"90\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2016\/09\/Pasted-image-at-2017_11_23-04_46-PM.png 728w, https:\/\/codefresh.io\/wp-content\/uploads\/2016\/09\/Pasted-image-at-2017_11_23-04_46-PM-300x37.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2016\/09\/Pasted-image-at-2017_11_23-04_46-PM-628x78.png 628w\" sizes=\"(max-width: 728px) 100vw, 728px\" \/><\/a><\/p>\n<p>&nbsp;<\/p>\n<p>&nbsp;<\/p>\n<input class=\"fooboxshare_post_id\" type=\"hidden\" value=\"3079\"\/>","protected":false},"excerpt":{"rendered":"<p>Teaser Suppose you want to debug a\u00a0Node.js application already running on a remote machine inside Docker container. And would like to do it without modifying command arguments (enabling debug mode) and opening remote Node.js debugger agent port to the whole world. I bet you didn&#8217;t know that it&#8217;s possible and also have no idea how &hellip; <a href=\"https:\/\/codefresh.io\/docker-tutorial\/debug_node_in_docker\/\">Read more<\/a><\/p>\n","protected":false},"author":28,"featured_media":1170,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[8],"tags":[14,19,99,112,113],"yoast_head":"<!-- This site is optimized with the Yoast SEO Premium plugin v17.9 (Yoast SEO v18.4.1) - https:\/\/yoast.com\/wordpress\/plugins\/seo\/ -->\n<title>Debugging remote Node.js application running in a Docker container | Codefresh<\/title>\n<meta name=\"description\" content=\"How to debug running Docker container with Node application in it, without running it in debug mode and pre-opening remote debug port to the whole world?\" \/>\n<meta name=\"robots\" content=\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\" \/>\n<link rel=\"canonical\" href=\"https:\/\/codefresh.io\/docker-tutorial\/debug_node_in_docker\/\" \/>\n<meta property=\"og:locale\" content=\"en_US\" \/>\n<meta property=\"og:type\" content=\"article\" \/>\n<meta property=\"og:title\" content=\"Debugging remote Node.js application running in a Docker container\" \/>\n<meta property=\"og:description\" content=\"How to debug running Docker container with Node application in it, without running it in debug mode and pre-opening remote debug port to the whole world?\" \/>\n<meta property=\"og:url\" content=\"https:\/\/codefresh.io\/docker-tutorial\/debug_node_in_docker\/\" \/>\n<meta property=\"og:site_name\" content=\"Codefresh\" \/>\n<meta property=\"article:publisher\" content=\"https:\/\/www.facebook.com\/codefresh.io\" \/>\n<meta property=\"article:published_time\" content=\"2017-06-06T14:15:15+00:00\" \/>\n<meta property=\"article:modified_time\" content=\"2022-02-11T19:00:39+00:00\" \/>\n<meta property=\"og:image\" content=\"https:\/\/codefresh.io\/wp-content\/uploads\/2016\/10\/continuous-unit-e1477003449568.png\" \/>\n\t<meta property=\"og:image:width\" content=\"434\" \/>\n\t<meta property=\"og:image:height\" content=\"140\" \/>\n\t<meta property=\"og:image:type\" content=\"image\/png\" \/>\n<meta name=\"twitter:card\" content=\"summary_large_image\" \/>\n<meta name=\"twitter:creator\" content=\"@alexeiled\" \/>\n<meta name=\"twitter:site\" content=\"@codefresh\" \/>\n<meta name=\"twitter:label1\" content=\"Written by\" \/>\n\t<meta name=\"twitter:data1\" content=\"Alexei Ledenev\" \/>\n\t<meta name=\"twitter:label2\" content=\"Est. reading time\" \/>\n\t<meta name=\"twitter:data2\" content=\"11 minutes\" \/>\n<script type=\"application\/ld+json\" class=\"yoast-schema-graph\">{\"@context\":\"https:\/\/schema.org\",\"@graph\":[{\"@type\":\"Organization\",\"@id\":\"https:\/\/codefresh.io\/#organization\",\"name\":\"Codefresh\",\"url\":\"https:\/\/codefresh.io\/\",\"sameAs\":[\"https:\/\/www.facebook.com\/codefresh.io\",\"https:\/\/www.linkedin.com\/company\/codefresh\",\"https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg\",\"https:\/\/twitter.com\/codefresh\"],\"logo\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#logo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"width\":800,\"height\":800,\"caption\":\"Codefresh\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/#logo\"}},{\"@type\":\"WebSite\",\"@id\":\"https:\/\/codefresh.io\/#website\",\"url\":\"https:\/\/codefresh.io\/\",\"name\":\"Codefresh\",\"description\":\"\",\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"potentialAction\":[{\"@type\":\"SearchAction\",\"target\":{\"@type\":\"EntryPoint\",\"urlTemplate\":\"https:\/\/codefresh.io\/?s={search_term_string}\"},\"query-input\":\"required name=search_term_string\"}],\"inLanguage\":\"en-US\"},{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/debug_node_in_docker\/#primaryimage\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2016\/10\/continuous-unit-e1477003449568.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2016\/10\/continuous-unit-e1477003449568.png\",\"width\":434,\"height\":140},{\"@type\":\"WebPage\",\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/debug_node_in_docker\/#webpage\",\"url\":\"https:\/\/codefresh.io\/docker-tutorial\/debug_node_in_docker\/\",\"name\":\"Debugging remote Node.js application running in a Docker container | Codefresh\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/#website\"},\"primaryImageOfPage\":{\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/debug_node_in_docker\/#primaryimage\"},\"datePublished\":\"2017-06-06T14:15:15+00:00\",\"dateModified\":\"2022-02-11T19:00:39+00:00\",\"description\":\"How to debug running Docker container with Node application in it, without running it in debug mode and pre-opening remote debug port to the whole world?\",\"breadcrumb\":{\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/debug_node_in_docker\/#breadcrumb\"},\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"ReadAction\",\"target\":[\"https:\/\/codefresh.io\/docker-tutorial\/debug_node_in_docker\/\"]}]},{\"@type\":\"BreadcrumbList\",\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/debug_node_in_docker\/#breadcrumb\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"name\":\"Home\",\"item\":\"https:\/\/codefresh.io\/\"},{\"@type\":\"ListItem\",\"position\":2,\"name\":\"Debugging remote Node.js application running in a Docker container\"}]},{\"@type\":\"Article\",\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/debug_node_in_docker\/#article\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/debug_node_in_docker\/#webpage\"},\"author\":{\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/33798ced90c48c116c3a9a59ae74af50\"},\"headline\":\"Debugging remote Node.js application running in a Docker container\",\"datePublished\":\"2017-06-06T14:15:15+00:00\",\"dateModified\":\"2022-02-11T19:00:39+00:00\",\"mainEntityOfPage\":{\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/debug_node_in_docker\/#webpage\"},\"wordCount\":1644,\"commentCount\":7,\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/debug_node_in_docker\/#primaryimage\"},\"thumbnailUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2016\/10\/continuous-unit-e1477003449568.png\",\"keywords\":[\"docker\",\"node.js\",\"docker build\",\"debug\",\"ssh\"],\"articleSection\":[\"Docker Tutorials\"],\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"CommentAction\",\"name\":\"Comment\",\"target\":[\"https:\/\/codefresh.io\/docker-tutorial\/debug_node_in_docker\/#respond\"]}]},{\"@type\":\"Person\",\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/33798ced90c48c116c3a9a59ae74af50\",\"name\":\"Alexei Ledenev\",\"image\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#personlogo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/secure.gravatar.com\/avatar\/53d5ff05d62acd594ea97300543a62a5?s=96&d=blank&r=g\",\"contentUrl\":\"https:\/\/secure.gravatar.com\/avatar\/53d5ff05d62acd594ea97300543a62a5?s=96&d=blank&r=g\",\"caption\":\"Alexei Ledenev\"},\"description\":\"Alexei is an experienced software architect and HPE distinguished technologist. He currently works at Codefresh as the Chief Researcher, focusing lately on #docker, #golang and #aws. In his spare time, Alexei maintains a couple of Docker-centric open-source projects, writes tech blog posts, and enjoys traveling and playing with his kids. https:\/\/github.com\/gaia-adm\/pumba\",\"sameAs\":[\"https:\/\/medium.com\/@alexeiled\/\",\"https:\/\/twitter.com\/alexeiled\"],\"url\":\"https:\/\/codefresh.io\/author\/alexei\/\"}]}<\/script>\n<!-- \/ Yoast SEO Premium plugin. -->","yoast_head_json":{"title":"Debugging remote Node.js application running in a Docker container | Codefresh","description":"How to debug running Docker container with Node application in it, without running it in debug mode and pre-opening remote debug port to the whole world?","robots":{"index":"index","follow":"follow","max-snippet":"max-snippet:-1","max-image-preview":"max-image-preview:large","max-video-preview":"max-video-preview:-1"},"canonical":"https:\/\/codefresh.io\/docker-tutorial\/debug_node_in_docker\/","og_locale":"en_US","og_type":"article","og_title":"Debugging remote Node.js application running in a Docker container","og_description":"How to debug running Docker container with Node application in it, without running it in debug mode and pre-opening remote debug port to the whole world?","og_url":"https:\/\/codefresh.io\/docker-tutorial\/debug_node_in_docker\/","og_site_name":"Codefresh","article_publisher":"https:\/\/www.facebook.com\/codefresh.io","article_published_time":"2017-06-06T14:15:15+00:00","article_modified_time":"2022-02-11T19:00:39+00:00","og_image":[{"width":434,"height":140,"url":"https:\/\/codefresh.io\/wp-content\/uploads\/2016\/10\/continuous-unit-e1477003449568.png","type":"image\/png"}],"twitter_card":"summary_large_image","twitter_creator":"@alexeiled","twitter_site":"@codefresh","twitter_misc":{"Written by":"Alexei Ledenev","Est. reading time":"11 minutes"},"schema":{"@context":"https:\/\/schema.org","@graph":[{"@type":"Organization","@id":"https:\/\/codefresh.io\/#organization","name":"Codefresh","url":"https:\/\/codefresh.io\/","sameAs":["https:\/\/www.facebook.com\/codefresh.io","https:\/\/www.linkedin.com\/company\/codefresh","https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg","https:\/\/twitter.com\/codefresh"],"logo":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#logo","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","width":800,"height":800,"caption":"Codefresh"},"image":{"@id":"https:\/\/codefresh.io\/#logo"}},{"@type":"WebSite","@id":"https:\/\/codefresh.io\/#website","url":"https:\/\/codefresh.io\/","name":"Codefresh","description":"","publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"potentialAction":[{"@type":"SearchAction","target":{"@type":"EntryPoint","urlTemplate":"https:\/\/codefresh.io\/?s={search_term_string}"},"query-input":"required name=search_term_string"}],"inLanguage":"en-US"},{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/docker-tutorial\/debug_node_in_docker\/#primaryimage","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2016\/10\/continuous-unit-e1477003449568.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2016\/10\/continuous-unit-e1477003449568.png","width":434,"height":140},{"@type":"WebPage","@id":"https:\/\/codefresh.io\/docker-tutorial\/debug_node_in_docker\/#webpage","url":"https:\/\/codefresh.io\/docker-tutorial\/debug_node_in_docker\/","name":"Debugging remote Node.js application running in a Docker container | Codefresh","isPartOf":{"@id":"https:\/\/codefresh.io\/#website"},"primaryImageOfPage":{"@id":"https:\/\/codefresh.io\/docker-tutorial\/debug_node_in_docker\/#primaryimage"},"datePublished":"2017-06-06T14:15:15+00:00","dateModified":"2022-02-11T19:00:39+00:00","description":"How to debug running Docker container with Node application in it, without running it in debug mode and pre-opening remote debug port to the whole world?","breadcrumb":{"@id":"https:\/\/codefresh.io\/docker-tutorial\/debug_node_in_docker\/#breadcrumb"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https:\/\/codefresh.io\/docker-tutorial\/debug_node_in_docker\/"]}]},{"@type":"BreadcrumbList","@id":"https:\/\/codefresh.io\/docker-tutorial\/debug_node_in_docker\/#breadcrumb","itemListElement":[{"@type":"ListItem","position":1,"name":"Home","item":"https:\/\/codefresh.io\/"},{"@type":"ListItem","position":2,"name":"Debugging remote Node.js application running in a Docker container"}]},{"@type":"Article","@id":"https:\/\/codefresh.io\/docker-tutorial\/debug_node_in_docker\/#article","isPartOf":{"@id":"https:\/\/codefresh.io\/docker-tutorial\/debug_node_in_docker\/#webpage"},"author":{"@id":"https:\/\/codefresh.io\/#\/schema\/person\/33798ced90c48c116c3a9a59ae74af50"},"headline":"Debugging remote Node.js application running in a Docker container","datePublished":"2017-06-06T14:15:15+00:00","dateModified":"2022-02-11T19:00:39+00:00","mainEntityOfPage":{"@id":"https:\/\/codefresh.io\/docker-tutorial\/debug_node_in_docker\/#webpage"},"wordCount":1644,"commentCount":7,"publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"image":{"@id":"https:\/\/codefresh.io\/docker-tutorial\/debug_node_in_docker\/#primaryimage"},"thumbnailUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2016\/10\/continuous-unit-e1477003449568.png","keywords":["docker","node.js","docker build","debug","ssh"],"articleSection":["Docker Tutorials"],"inLanguage":"en-US","potentialAction":[{"@type":"CommentAction","name":"Comment","target":["https:\/\/codefresh.io\/docker-tutorial\/debug_node_in_docker\/#respond"]}]},{"@type":"Person","@id":"https:\/\/codefresh.io\/#\/schema\/person\/33798ced90c48c116c3a9a59ae74af50","name":"Alexei Ledenev","image":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#personlogo","inLanguage":"en-US","url":"https:\/\/secure.gravatar.com\/avatar\/53d5ff05d62acd594ea97300543a62a5?s=96&d=blank&r=g","contentUrl":"https:\/\/secure.gravatar.com\/avatar\/53d5ff05d62acd594ea97300543a62a5?s=96&d=blank&r=g","caption":"Alexei Ledenev"},"description":"Alexei is an experienced software architect and HPE distinguished technologist. He currently works at Codefresh as the Chief Researcher, focusing lately on #docker, #golang and #aws. In his spare time, Alexei maintains a couple of Docker-centric open-source projects, writes tech blog posts, and enjoys traveling and playing with his kids. https:\/\/github.com\/gaia-adm\/pumba","sameAs":["https:\/\/medium.com\/@alexeiled\/","https:\/\/twitter.com\/alexeiled"],"url":"https:\/\/codefresh.io\/author\/alexei\/"}]}},"acf":[],"_links":{"self":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/3079"}],"collection":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/users\/28"}],"replies":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/comments?post=3079"}],"version-history":[{"count":1,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/3079\/revisions"}],"predecessor-version":[{"id":21480,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/3079\/revisions\/21480"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media\/1170"}],"wp:attachment":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media?parent=3079"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/categories?post=3079"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/tags?post=3079"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}