{"id":3691,"date":"2017-06-29T21:19:11","date_gmt":"2017-06-29T21:19:11","guid":{"rendered":"https:\/\/codefresh.io\/?post_type=dockerguides&#038;p=3691"},"modified":"2022-01-18T16:36:35","modified_gmt":"2022-01-18T16:36:35","slug":"docker-multi-stage-builds","status":"publish","type":"post","link":"https:\/\/codefresh.io\/docker-tutorial\/docker-multi-stage-builds\/","title":{"rendered":"Docker Multi-Stage Builds"},"content":{"rendered":"<p>One of the most anticipated features of Docker&#8217;s recent 17.05 release is <strong>multi-stage builds<\/strong>. Even those familiar with Docker may find themselves asking what a multi-stage Docker build is. Before we learn about <a href=\"https:\/\/codefresh.io\/docker-guides\/build-docker-image-dockerfiles\/\">multi-stage Docker builds<\/a>, lets examine a single-stage build and the process by which Docker uses Dockerfile instructions to create an image.<!--more--><\/p>\n<blockquote style=\"background: rgba(50,200,50,.2); padding-top: 25px; padding-bottom: 1px;\"><p>Codefresh supports multi-stage builds as part of the pipeline. Add a Dockerfile and <a href=\"https:\/\/g.codefresh.io\/signup\">try it out<\/a>.<\/p><\/blockquote>\n<h2>Dockerfiles<\/h2>\n<p>Docker uses a special text file <a href=\"https:\/\/codefresh.io\/docker-guides\/build-docker-image-dockerfiles\/\">called a Dockerfile<\/a>. Dockerfiles use a DSL to describe how to build a Docker image. This DSL is actually a series of commands that, when executed, assemble a Docker image. Users can issue the <code>docker build<\/code> command against the Dockerfile to perform an automated build that executes these command-line instructions in succession.<\/p>\n<p>These special Dockerfile instructions direct the Docker builder to create a Docker image exactly as you specify. They determine exactly which file system, application, files, and ultimately what running processes will make up the eventual running container spawned from the Docker image.<\/p>\n<pre class=\"lang:default decode:true\">FROM golang:1.8\nMAINTAINER CodeFresh.io\n\nWORKDIR \/go\/src\/myapp\nCOPY app.go .\n\n# build\nRUN go build -o app .\n\nCMD [\".\/app\"]<\/pre>\n<p>Dockerfiles always begin with the <code>FROM<\/code> instruction, which sets the base image on which to run all subsequent commands. The base image can be any valid Docker image that has been custom created or pulled from public repositories. Subsequent commands like <code>COPY<\/code> and <code>RUN<\/code> define not only what the image is to contain, but more frequently command line steps to derive your final application run state.<\/p>\n<p>For example, by using the Golang &#8220;SDK&#8221; image, a user may copy in their source code and perform a build all inside the Dockerfile, resulting in a convenient single image. Unfortunately, the size of the resulting image frequently ends up ballooning to over 700MB. If your application is deployed using several or more Docker images, this can be a serious problem.<\/p>\n<h2>Image Construction<\/h2>\n<p>Docker images are made up of a series of union file system layers, the technical storage underpinnings of which is determined by the <a href=\"https:\/\/docs.docker.com\/engine\/userguide\/storagedriver\/\">storage driver<\/a>. Each executed instruction within a Dockerfile resides in its own layer of the final Docker image. The first layer will always be the inherited base image, as defined by the <code>FROM<\/code> instruction. Each subsequent layer will store your application, files, etc.<\/p>\n<p><img class=\"size-medium wp-image-20984 aligncenter\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/06\/docker-layers-300x221.png\" alt=\"docker-layers\" width=\"300\" height=\"221\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/06\/docker-layers-300x221.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2017\/06\/docker-layers-768x565.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2017\/06\/docker-layers-20x15.png 20w, https:\/\/codefresh.io\/wp-content\/uploads\/2017\/06\/docker-layers.png 779w\" sizes=\"(max-width: 300px) 100vw, 300px\" \/><\/p>\n<p>Understanding Docker image layers is not a necessity to getting started with building and running Docker images and containers. However, it is essential for any Docker user who wishes to become proficient in the Docker tool set. How layers are constructed affects the build time, storage, and overall performance of your application. The more instructions in the Dockerfile, the more layers in the image, and the larger the image becomes.<\/p>\n<p>As shown in our previous Golang &#8220;SDK&#8221; example, images can become quite large if it contains both the build tools, or SDKs, and the compiled application. However, we no longer need the base build tools, only the final application binary.<\/p>\n<h2>Life without Multi-Stage Builds<\/h2>\n<p>Working off our Dockerfile example above, we see golang source code being copied in (line 5) then built (line 8). The <code>CMD<\/code>\u00a0instruction (line 10) defines what the container will run as its primary process. In this case, the application that we just built.\u00a0We&#8217;re able to write such a concise Dockerfile because we are inheriting from the golang official image which contains the golang SDK and necessary build tools for us to compile our application binary.<\/p>\n<p>However, we now have these unnecessary tools in our production Docker image that are not required for running our application. Wouldn&#8217;t it be great if we could use a single Dockerfile to <strong>build<\/strong> our source code, throw away the unnecessary build tools, and then\u00a0<strong>execute<\/strong> our golang application? This would make the built Docker image extremely small.<\/p>\n<h2>Docker Multi-Stage Builds<\/h2>\n<p>The new multi-stage build feature in Docker 17.05 does just that. \u00a0We are now able to define a base image for performing tasks such as building from source, while then defining a second (or even third!) base image to run our application or perform other steps as necessary. Let&#8217;s take a look at our previous Dockerfile but now with multi-stage builds:<\/p>\n<pre class=\"lang:default decode:true\">FROM golang:1.8\nMAINTAINER CodeFresh.io\n\nWORKDIR \/go\/src\/myapp\nCOPY app.go .\n\n# build\nRUN go build -o app .\n\nFROM alpine:latest \nRUN apk --no-cache add ca-certificates\n\nWORKDIR \/root\/\n\nCOPY --from=0 \/go\/src\/myapp\/app .\n\nCMD [\".\/app\"]<\/pre>\n<p>The final image that this Dockerfile will build starts with the last <code>FROM<\/code> instruction, <code>FROM alpine:latest<\/code>. We now have a single Dockerfile that builds our application from an official golang SDK image, and runs our application in the secure and lightweight Alpine image. Not only have we significantly saved on space, but we created a more secure runtime without defining any more Dockerfiles or custom scripts!<\/p>\n<p>Depending on your app size, this image could be just a\u00a0<em>few MBs<\/em> versus hundreds with build tools included.<\/p>\n<h2>Less is More<\/h2>\n<p>Outside of Codefresh, manually scripting multi-stage builds as was previously done was time consuming and overly complicated. With the new multi-stage build feature, we can concisely define multiple build steps and arrive at a final Docker image that meets best practices for production. With Docker 17.06 now GA, this is now a best practice moving forward.<\/p>\n<p>Multi-stage build Dockerfiles are fully supported in Codefresh and have always been available inside of <a href=\"https:\/\/docs.codefresh.io\/v1.0\/docs\/what-is-the-codefresh-yaml\">Codefresh.yml<\/a>.<\/p>\n<input class=\"fooboxshare_post_id\" type=\"hidden\" value=\"3691\"\/>","protected":false},"excerpt":{"rendered":"<p>One of the most anticipated features of Docker&#8217;s recent 17.05 release is multi-stage builds. Even those familiar with Docker may find themselves asking what a multi-stage Docker build is. Before we learn about multi-stage Docker builds, lets examine a single-stage build and the process by which Docker uses Dockerfile instructions to create an image.<\/p>\n","protected":false},"author":45,"featured_media":824,"comment_status":"closed","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[8],"tags":[],"yoast_head":"<!-- This site is optimized with the Yoast SEO Premium plugin v17.9 (Yoast SEO v18.4.1) - https:\/\/yoast.com\/wordpress\/plugins\/seo\/ -->\n<title>Docker Multi-Stage Builds | Codefresh<\/title>\n<meta name=\"description\" content=\"Docker Multi-Stage builds give you the granularity to both efficiently describe your applications and minimize their size on disk. Find out more.\" \/>\n<meta name=\"robots\" content=\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\" \/>\n<link rel=\"canonical\" href=\"https:\/\/codefresh.io\/docker-tutorial\/docker-multi-stage-builds\/\" \/>\n<meta property=\"og:locale\" content=\"en_US\" \/>\n<meta property=\"og:type\" content=\"article\" \/>\n<meta property=\"og:title\" content=\"Docker Multi-Stage Builds\" \/>\n<meta property=\"og:description\" content=\"Docker Multi-Stage builds give you the granularity to both efficiently describe your applications and minimize their size on disk. Find out more.\" \/>\n<meta property=\"og:url\" content=\"https:\/\/codefresh.io\/docker-tutorial\/docker-multi-stage-builds\/\" \/>\n<meta property=\"og:site_name\" content=\"Codefresh\" \/>\n<meta property=\"article:publisher\" content=\"https:\/\/www.facebook.com\/codefresh.io\" \/>\n<meta property=\"article:published_time\" content=\"2017-06-29T21:19:11+00:00\" \/>\n<meta property=\"article:modified_time\" content=\"2022-01-18T16:36:35+00:00\" \/>\n<meta property=\"og:image\" content=\"https:\/\/codefresh.io\/wp-content\/uploads\/2016\/03\/fast-build-docker-images.jpg\" \/>\n\t<meta property=\"og:image:width\" content=\"277\" \/>\n\t<meta property=\"og:image:height\" content=\"327\" \/>\n\t<meta property=\"og:image:type\" content=\"image\/jpeg\" \/>\n<meta name=\"twitter:card\" content=\"summary_large_image\" \/>\n<meta name=\"twitter:creator\" content=\"@codefresh\" \/>\n<meta name=\"twitter:site\" content=\"@codefresh\" \/>\n<meta name=\"twitter:label1\" content=\"Written by\" \/>\n\t<meta name=\"twitter:data1\" content=\"Will Kinard\" \/>\n\t<meta name=\"twitter:label2\" content=\"Est. reading time\" \/>\n\t<meta name=\"twitter:data2\" content=\"4 minutes\" \/>\n<script type=\"application\/ld+json\" class=\"yoast-schema-graph\">{\"@context\":\"https:\/\/schema.org\",\"@graph\":[{\"@type\":\"Organization\",\"@id\":\"https:\/\/codefresh.io\/#organization\",\"name\":\"Codefresh\",\"url\":\"https:\/\/codefresh.io\/\",\"sameAs\":[\"https:\/\/www.facebook.com\/codefresh.io\",\"https:\/\/www.linkedin.com\/company\/codefresh\",\"https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg\",\"https:\/\/twitter.com\/codefresh\"],\"logo\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#logo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"width\":800,\"height\":800,\"caption\":\"Codefresh\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/#logo\"}},{\"@type\":\"WebSite\",\"@id\":\"https:\/\/codefresh.io\/#website\",\"url\":\"https:\/\/codefresh.io\/\",\"name\":\"Codefresh\",\"description\":\"\",\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"potentialAction\":[{\"@type\":\"SearchAction\",\"target\":{\"@type\":\"EntryPoint\",\"urlTemplate\":\"https:\/\/codefresh.io\/?s={search_term_string}\"},\"query-input\":\"required name=search_term_string\"}],\"inLanguage\":\"en-US\"},{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/docker-multi-stage-builds\/#primaryimage\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2016\/03\/fast-build-docker-images.jpg\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2016\/03\/fast-build-docker-images.jpg\",\"width\":277,\"height\":327,\"caption\":\"fast build docker images\"},{\"@type\":\"WebPage\",\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/docker-multi-stage-builds\/#webpage\",\"url\":\"https:\/\/codefresh.io\/docker-tutorial\/docker-multi-stage-builds\/\",\"name\":\"Docker Multi-Stage Builds | Codefresh\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/#website\"},\"primaryImageOfPage\":{\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/docker-multi-stage-builds\/#primaryimage\"},\"datePublished\":\"2017-06-29T21:19:11+00:00\",\"dateModified\":\"2022-01-18T16:36:35+00:00\",\"description\":\"Docker Multi-Stage builds give you the granularity to both efficiently describe your applications and minimize their size on disk. Find out more.\",\"breadcrumb\":{\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/docker-multi-stage-builds\/#breadcrumb\"},\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"ReadAction\",\"target\":[\"https:\/\/codefresh.io\/docker-tutorial\/docker-multi-stage-builds\/\"]}]},{\"@type\":\"BreadcrumbList\",\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/docker-multi-stage-builds\/#breadcrumb\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"name\":\"Home\",\"item\":\"https:\/\/codefresh.io\/\"},{\"@type\":\"ListItem\",\"position\":2,\"name\":\"Docker Multi-Stage Builds\"}]},{\"@type\":\"Article\",\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/docker-multi-stage-builds\/#article\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/docker-multi-stage-builds\/#webpage\"},\"author\":{\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/630ad2ec55912f079a7ab80869765b87\"},\"headline\":\"Docker Multi-Stage Builds\",\"datePublished\":\"2017-06-29T21:19:11+00:00\",\"dateModified\":\"2022-01-18T16:36:35+00:00\",\"mainEntityOfPage\":{\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/docker-multi-stage-builds\/#webpage\"},\"wordCount\":826,\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/docker-multi-stage-builds\/#primaryimage\"},\"thumbnailUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2016\/03\/fast-build-docker-images.jpg\",\"articleSection\":[\"Docker Tutorials\"],\"inLanguage\":\"en-US\"},{\"@type\":\"Person\",\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/630ad2ec55912f079a7ab80869765b87\",\"name\":\"Will Kinard\",\"image\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#personlogo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/secure.gravatar.com\/avatar\/ef7c4570c14408e7e42d931970f0c62b?s=96&d=blank&r=g\",\"contentUrl\":\"https:\/\/secure.gravatar.com\/avatar\/ef7c4570c14408e7e42d931970f0c62b?s=96&d=blank&r=g\",\"caption\":\"Will Kinard\"},\"sameAs\":[\"http:\/\/boxboat.com\"],\"url\":\"https:\/\/codefresh.io\/author\/willkinard\/\"}]}<\/script>\n<!-- \/ Yoast SEO Premium plugin. -->","yoast_head_json":{"title":"Docker Multi-Stage Builds | Codefresh","description":"Docker Multi-Stage builds give you the granularity to both efficiently describe your applications and minimize their size on disk. Find out more.","robots":{"index":"index","follow":"follow","max-snippet":"max-snippet:-1","max-image-preview":"max-image-preview:large","max-video-preview":"max-video-preview:-1"},"canonical":"https:\/\/codefresh.io\/docker-tutorial\/docker-multi-stage-builds\/","og_locale":"en_US","og_type":"article","og_title":"Docker Multi-Stage Builds","og_description":"Docker Multi-Stage builds give you the granularity to both efficiently describe your applications and minimize their size on disk. Find out more.","og_url":"https:\/\/codefresh.io\/docker-tutorial\/docker-multi-stage-builds\/","og_site_name":"Codefresh","article_publisher":"https:\/\/www.facebook.com\/codefresh.io","article_published_time":"2017-06-29T21:19:11+00:00","article_modified_time":"2022-01-18T16:36:35+00:00","og_image":[{"width":277,"height":327,"url":"https:\/\/codefresh.io\/wp-content\/uploads\/2016\/03\/fast-build-docker-images.jpg","type":"image\/jpeg"}],"twitter_card":"summary_large_image","twitter_creator":"@codefresh","twitter_site":"@codefresh","twitter_misc":{"Written by":"Will Kinard","Est. reading time":"4 minutes"},"schema":{"@context":"https:\/\/schema.org","@graph":[{"@type":"Organization","@id":"https:\/\/codefresh.io\/#organization","name":"Codefresh","url":"https:\/\/codefresh.io\/","sameAs":["https:\/\/www.facebook.com\/codefresh.io","https:\/\/www.linkedin.com\/company\/codefresh","https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg","https:\/\/twitter.com\/codefresh"],"logo":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#logo","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","width":800,"height":800,"caption":"Codefresh"},"image":{"@id":"https:\/\/codefresh.io\/#logo"}},{"@type":"WebSite","@id":"https:\/\/codefresh.io\/#website","url":"https:\/\/codefresh.io\/","name":"Codefresh","description":"","publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"potentialAction":[{"@type":"SearchAction","target":{"@type":"EntryPoint","urlTemplate":"https:\/\/codefresh.io\/?s={search_term_string}"},"query-input":"required name=search_term_string"}],"inLanguage":"en-US"},{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/docker-tutorial\/docker-multi-stage-builds\/#primaryimage","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2016\/03\/fast-build-docker-images.jpg","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2016\/03\/fast-build-docker-images.jpg","width":277,"height":327,"caption":"fast build docker images"},{"@type":"WebPage","@id":"https:\/\/codefresh.io\/docker-tutorial\/docker-multi-stage-builds\/#webpage","url":"https:\/\/codefresh.io\/docker-tutorial\/docker-multi-stage-builds\/","name":"Docker Multi-Stage Builds | Codefresh","isPartOf":{"@id":"https:\/\/codefresh.io\/#website"},"primaryImageOfPage":{"@id":"https:\/\/codefresh.io\/docker-tutorial\/docker-multi-stage-builds\/#primaryimage"},"datePublished":"2017-06-29T21:19:11+00:00","dateModified":"2022-01-18T16:36:35+00:00","description":"Docker Multi-Stage builds give you the granularity to both efficiently describe your applications and minimize their size on disk. Find out more.","breadcrumb":{"@id":"https:\/\/codefresh.io\/docker-tutorial\/docker-multi-stage-builds\/#breadcrumb"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https:\/\/codefresh.io\/docker-tutorial\/docker-multi-stage-builds\/"]}]},{"@type":"BreadcrumbList","@id":"https:\/\/codefresh.io\/docker-tutorial\/docker-multi-stage-builds\/#breadcrumb","itemListElement":[{"@type":"ListItem","position":1,"name":"Home","item":"https:\/\/codefresh.io\/"},{"@type":"ListItem","position":2,"name":"Docker Multi-Stage Builds"}]},{"@type":"Article","@id":"https:\/\/codefresh.io\/docker-tutorial\/docker-multi-stage-builds\/#article","isPartOf":{"@id":"https:\/\/codefresh.io\/docker-tutorial\/docker-multi-stage-builds\/#webpage"},"author":{"@id":"https:\/\/codefresh.io\/#\/schema\/person\/630ad2ec55912f079a7ab80869765b87"},"headline":"Docker Multi-Stage Builds","datePublished":"2017-06-29T21:19:11+00:00","dateModified":"2022-01-18T16:36:35+00:00","mainEntityOfPage":{"@id":"https:\/\/codefresh.io\/docker-tutorial\/docker-multi-stage-builds\/#webpage"},"wordCount":826,"publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"image":{"@id":"https:\/\/codefresh.io\/docker-tutorial\/docker-multi-stage-builds\/#primaryimage"},"thumbnailUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2016\/03\/fast-build-docker-images.jpg","articleSection":["Docker Tutorials"],"inLanguage":"en-US"},{"@type":"Person","@id":"https:\/\/codefresh.io\/#\/schema\/person\/630ad2ec55912f079a7ab80869765b87","name":"Will Kinard","image":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#personlogo","inLanguage":"en-US","url":"https:\/\/secure.gravatar.com\/avatar\/ef7c4570c14408e7e42d931970f0c62b?s=96&d=blank&r=g","contentUrl":"https:\/\/secure.gravatar.com\/avatar\/ef7c4570c14408e7e42d931970f0c62b?s=96&d=blank&r=g","caption":"Will Kinard"},"sameAs":["http:\/\/boxboat.com"],"url":"https:\/\/codefresh.io\/author\/willkinard\/"}]}},"acf":[],"_links":{"self":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/3691"}],"collection":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/users\/45"}],"replies":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/comments?post=3691"}],"version-history":[{"count":1,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/3691\/revisions"}],"predecessor-version":[{"id":20985,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/3691\/revisions\/20985"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media\/824"}],"wp:attachment":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media?parent=3691"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/categories?post=3691"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/tags?post=3691"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}