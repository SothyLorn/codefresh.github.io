{"id":5588,"date":"2017-12-07T09:29:28","date_gmt":"2017-12-07T09:29:28","guid":{"rendered":"https:\/\/codefresh.io\/?p=5588"},"modified":"2022-02-09T15:22:03","modified_gmt":"2022-02-09T15:22:03","slug":"cd_helm_kubernetes_microservices_1","status":"publish","type":"post","link":"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_1\/","title":{"rendered":"Continuous Delivery and Continuous Deployment for Kubernetes (part 1)"},"content":{"rendered":"<h2>Starting Point<\/h2>\n<p><span style=\"font-weight: 400;\">Over the last years, we&#8217;ve been adopting several concepts for our project, struggling to make them work together. Let&#8217;s look at some of the concepts:<\/span><\/p>\n<h3>Microservice Architecture<\/h3>\n<p>The first one is the <em>Microservice Architecture<\/em>. <span style=\"font-weight: 400;\">We did not start it clean and by the book, rather applied it to an already existing project by splitting big services into smaller ones and breaking excessive coupling. The refactoring work is not yet finished. We are starting to build new services which look like &#8220;microservices&#8221;, however, I would call them&#8221;micro-monoliths&#8221;.<\/span><\/p>\n<p><span style=\"font-weight: 400;\">I have a feeling that this is a typical situation for an already existing project, that tries to adapt into this new architecture pattern, which sounds more like<\/span>: <em>You are almost there, but there is always a work to be done<\/em>.<\/p>\n<h3>Docker<\/h3>\n<p><span style=\"font-weight: 400;\">The second concept is using Docker for building, packaging, and deploying application services. We bet on Docker from the beginning and used it for most of our services which happen to be a good bet.<\/span><br \/>\nThere are still few pure cloud services, that we are using when running our application on public cloud, thing like Databases, Error Analytics, Push Notifications and some others.<\/p>\n<h3>Kubernetes<\/h3>\n<p>And one of the latest bet we made was Kubernetes.<\/p>\n<p><span style=\"font-weight: 400;\">Kubernetes became the main runtime platform for our application. Adopting Kubernetes, not only allowed us to hide away lots of operational complexity, achieving better availability and scalability, but also enabling us to run our application on any public cloud and on-premise deployment.<\/span><\/p>\n<p><span style=\"font-weight: 400;\">With great flexibility, Kubernetes, however, brings an additional deployment complexity.<\/span><\/p>\n<p><span style=\"font-weight: 400;\">Suddenly your services are not just plain Docker containers, but there are a lot of new (and useful) Kubernetes resources that you need to take care for such as:\u00a0<\/span><em>ConfigMsaps<\/em>, <em>Secrets<\/em>, <em>Services<\/em>, <em>Deployments<\/em>, <em>StatefulSets<\/em>, <em>PVs<\/em>, <em>PVCs<\/em>, <em>Ingress<\/em>, <em>Jobs<\/em>, and others. <span style=\"font-weight: 400;\">And it&#8217;s not always obvious where to keep all these resources and how they are related to Docker images built by CI tool.<\/span><\/p>\n<h2>Continuous Delivery vs Continuous Deployment<\/h2>\n<p>The ambiguity of <strong>CD<\/strong> term annoys me a lot. Different people mean different things when using this term. And it&#8217;s not only about the <strong>CD<\/strong> abbreviation meaning: <em>Continuous Deployment vs Continuous Delivery<\/em>, but also <em>what do people mean<\/em>, when using this abbreviation.<\/p>\n<p>Still, it looks like there is a common agreement that <em>Continuous Deployment (CD)<\/em> is a super-set of <em>Continuous Delivery (CD)<\/em>. And the main difference, so far, is that <em>Continuous Deployment<\/em> is 100% automated, while in <em>Continuous Delivery<\/em> there are still some steps that should be done manually.<\/p>\n<p><a href=\"https:\/\/www.gocd.org\/2017\/10\/17\/difference-between-continuous-delivery-continuous-deployment-infographic.html\" target=\"_blank\" rel=\"noopener\"><img class=\"alignnone wp-image-5671\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/continuous-delivery-vs-continuous-deployment-infographic-305dd620.png\" alt=\"What's the difference between Continuous Delivery and Continuous Deployment?\" width=\"501\" height=\"564\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/continuous-delivery-vs-continuous-deployment-infographic-305dd620.png 800w, https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/continuous-delivery-vs-continuous-deployment-infographic-305dd620-267x300.png 267w, https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/continuous-delivery-vs-continuous-deployment-infographic-305dd620-768x864.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/continuous-delivery-vs-continuous-deployment-infographic-305dd620-292x328.png 292w\" sizes=\"(max-width: 501px) 100vw, 501px\" \/><\/a><\/p>\n<p>In our project, for example, we succeeded to achieve <em>Continuous Delivery<\/em>, that serves us well, both for SaaS and on-premise versions of our product.\u00a0<span style=\"font-weight: 400;\">Our next goal is to achieve the following things:<\/span><\/p>\n<ul>\n<li>Create fluent *Continuous Deployment* for SaaS version<\/li>\n<li>Release a change automatically to production, without human intervention, and be able to rollback to the previous version if something went wrong<\/li>\n<\/ul>\n<h2>Kubernetes Application and Release Content<\/h2>\n<p>Now let&#8217;s talk about <em>Release<\/em> and try to understand the definition <strong>Release Content<\/strong>.<\/p>\n<p>When we are releasing a <em>change<\/em> to some runtime environment such as <code>development<\/code>, <code>staging<\/code> or <code>production<\/code>, it&#8217;s not always a <em>code change<\/em>, that is packaged into a new\u00a0Docker image with some tag.<\/p>\n<p>Change can be done to application configurations, secrets, ingress rules, jobs we are running, volumes and other resources. It would be nice to be able to release all these changes in the same way as we release a <em>code change<\/em>. Actually, a change can be a mixture of both and in practice, it&#8217;s not a rare use case.<\/p>\n<p>So, we need to find a good methodology and supporting technology, that will allow us to release a new version of our Kubernetes application, that might be composed of multiple changes and these changes are not only new Docker image tags. This methodology should allow us to do it repeatedly on any runtime environment (Kubernetes cluster in our case) and be able to rollback <em>ALL<\/em> changes to the previous version if something went wrong.<\/p>\n<p>That&#8217;s why we adopted <a href=\"https:\/\/www.helm.sh\">Helm<\/a> as our main release management tool for Kubernetes.<\/p>\n<h2>Helm recap<\/h2>\n<p>This post is not about Helm, so Helm recap will be very short. I encourage you to read <a href=\"https:\/\/www.helm.sh\">Helm<\/a> documentation, it&#8217;s complete and well written.<\/p>\n<p><span style=\"font-weight: 400;\">Helm is a flexible release management system and can be extended with plugins and hooks.<\/span><\/p>\n<p>The core Helm concepts are as follows:<\/p>\n<ul>\n<li><strong>(Helm) Chart<\/strong> &#8211; is a package (<code>tar<\/code> archive) with Kubernetes <code>YAML<\/code> templates (for different Kubernetes resources) and default values (also stored in <code>YAML<\/code> files). Helm uses <em>chart<\/em> to install a new or update an existing <em>(Helm) release<\/em>.<\/li>\n<li><strong>(Helm) Release<\/strong> &#8211; is a Kubernetes application instance, installed with Helm. It is possible to create multiple <em>releases<\/em> from the same <em>chart<\/em> version.<\/li>\n<li><strong>(Release) Revision<\/strong> &#8211; when updating an existing <em>release<\/em>, a new <em>revision<\/em> is created. Helm can rollback a <em>release<\/em> to the previous <em>revision<\/em>. Helm stores all <em>revisions<\/em> in <em>ConfigMap<\/em> and it&#8217;s possible to list previous <em>releases<\/em> with <code>helm history<\/code> command.<\/li>\n<li><strong>Chart Repository<\/strong> &#8211; is a location where packaged <em>charts<\/em> can be stored and shared. Any web server that can store and serve static files can be used as <em>Chart Repository<\/em> (Nginx, GitHub, AWS S3 and others).<\/li>\n<\/ul>\n<p>Helm consists of the server, called <em>Tiller<\/em> and the command line client, called <code>helm<\/code>.<\/p>\n<ol>\n<li>When releasing a new version (or updating an existing) `helm` client sends *chart* (template files and values) to the Helm server.<\/li>\n<li>*Tiller* server generates valid Kubernetes `yaml` files from templates and values and deploys them to Kubernetes, using Kubernetes API.<\/li>\n<li>*Tiller* also saves generated `yaml` files as a new revision inside `ConfigMaps` and can use previously saved revision for rollback operation.<\/li>\n<\/ol>\n<h2>Helm Chart Management<\/h2>\n<p>Typical Helm <em>chart<\/em> contains a list of template files (<code>yaml<\/code> files with <code>go templates<\/code> commands) and values files (with configurations and secrets).<\/p>\n<p>We use <em>Git<\/em> to store all our Helm <em>chart<\/em> files and Amazon S3 for <em>chart repository<\/em>.<\/p>\n<p>Our guide to Helm Chart Management with <code>git<\/code>:<\/p>\n<ol>\n<li>Adopt some Git management methodology. We use something very close to the <a href=\"http:\/\/www.nicoespeon.com\/en\/2013\/08\/which-git-workflow-for-my-project\/#the-github-flow\">GitHub Flow model<\/a><br \/>\n<img class=\"size-full wp-image-5594 alignnone\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/github-flow-branching-model.jpg\" alt=\"\" width=\"500\" height=\"488\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/github-flow-branching-model.jpg 500w, https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/github-flow-branching-model-300x293.jpg 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/github-flow-branching-model-336x328.jpg 336w\" sizes=\"(max-width: 500px) 100vw, 500px\" \/><\/li>\n<li>Have a <code>git<\/code> repository for each microservice. Our typical project structure is shown bellow:<\/li>\n<\/ol>\n<pre><code class=\"sh\"># chart files\nchart\/\n# chart templates\ntemplates\/\n# external dependency\nrequirements.yaml\n# default values\nvalues.yaml\n# chart definition\nChart.yaml\n# source code\nscr\/\n# test code\ntest\/\n# build scripts\nhack\/\n# multi-stage Docker build file\nDockerfile\n# Codefresh CI\/CD pipeline\ncodefresh.yaml\n<\/code><\/pre>\n<ol>\n<li>We keep our application <em>chart<\/em> in a separate <code>git<\/code> repository. The application <em>chart<\/em> does not contain templates, but only\u00a0a list of third-party charts it requires (<code>requirements.yaml<\/code> file) and values files for different runtime environments (<code>testing<\/code>, <code>staging<\/code> and <code>production<\/code>)<\/li>\n<li>All <em>secrets<\/em> in values files are encrypted with <a href=\"https:\/\/github.com\/mozilla\/sops\">sops<\/a> tool and we defined a <code>.gitignore<\/code> file and setup a <code>git pre-commit hook<\/code> to avoid unintentional commit of decrypted secrets.<\/li>\n<\/ol>\n<h2>Docker CI (Continuous Integration)<\/h2>\n<p>Building and testing code on <code>git push\/tag<\/code> event and packaging it into some build artifact is a common knowledge and there are multiple tools, services, and tutorials how to do it.<\/p>\n<p>And if you choose our Codefresh service, you will get a built-in support for highly effective Docker CI. Codefresh also manages traceability links between Docker images, git commits, CI builds, Docker Registries, Kubernetes Services and Deployments and Helm Releases running on Kubernetes clusters.<\/p>\n<h3>Typical Docker CI flow<\/h3>\n<figure id=\"attachment_5593\" aria-describedby=\"caption-attachment-5593\" style=\"width: 800px\" class=\"wp-caption alignnone\"><img class=\"wp-image-5593 size-full\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/docker_ci.png\" alt=\"\" width=\"800\" height=\"380\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/docker_ci.png 800w, https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/docker_ci-300x143.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/docker_ci-768x365.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/docker_ci-628x298.png 628w\" sizes=\"(max-width: 800px) 100vw, 800px\" \/><figcaption id=\"caption-attachment-5593\" class=\"wp-caption-text\">Docker Continuous Integration<\/figcaption><\/figure>\n<ol>\n<li>Trigger CI pipeline on <code>push<\/code> event<\/li>\n<li>Build and test service code. <em>Tip:<\/em> give a try to a Docker multi-stage build.<\/li>\n<li><em>Tip:<\/em> Embed the <code>git commit<\/code> details into the Docker image (using Docker labels). I suggest following <a href=\"http:\/\/label-schema.org\">Label Schema convention<\/a>.<\/li>\n<li>Tag Docker image with <code>{branch}-{short SHA}<\/code><\/li>\n<li>Push newly created Docker image into preferred Docker Registry<\/li>\n<\/ol>\n<h3>Docker Multi-stage build<\/h3>\n<p>With a Docker <a href=\"https:\/\/codefresh.io\/blog\/node_docker_multistage\/\">multi-stage build<\/a>, you can even remove a need to learn a custom CI DSL syntax, like Jenkins Job\/Pipeline, or other <code>YAML<\/code> based DSL. Just use a familiar <code>Dockerfile<\/code> imperative syntax to describe all required CI stages (<code>build<\/code>, <code>lint<\/code>, <code>test<\/code>, <code>package<\/code>) and create a <em>thin and secure<\/em> final Docker image, that contains only bare minimum, required to run the service.<\/p>\n<p>Using multi-stage Docker build, also has other benefits:<\/p>\n<ol>\n<li>It allows you to use the same CI flow both on the developer machine and the CI server<\/li>\n<li>It can help you to switch easily between different CI services, using the same `Dockerfile`<\/li>\n<\/ol>\n<p>The only thing you need is a right Docker daemon version (&#8216;&gt; 17.05&#8217;). So, select CI service that supports latest Docker daemon versions.<\/p>\n<h4>Example: Node.js multi-stage Dockerfile<\/h4>\n<pre><code class=\"dockerfile\">#\n# ---- Base Node ----\nFROM alpine:3.5 AS base\n# install node\nRUN apk add --no-cache nodejs-npm tini\n# set working directory\nWORKDIR \/root\/chat\n# Set tini as entrypoint\nENTRYPOINT [\"\/sbin\/tini\", \"--\"]\n# copy project file\nCOPY package.json .\n\n#\n# ---- Dependencies ----\nFROM base AS dependencies\n# install node packages\nRUN npm set progress=false &amp;&amp; npm config set depth 0\nRUN npm install --only=production\n# copy production node_modules aside\nRUN cp -R node_modules prod_node_modules\n# install ALL node_modules, including 'devDependencies'\nRUN npm install\n\n#\n# ---- Test ----\n# run linters, setup and tests\nFROM dependencies AS test\nCOPY . .\nRUN npm run lint &amp;&amp; npm run setup &amp;&amp; npm run test\n\n#\n# ---- Release ----\nFROM base AS release\n# copy production node_modules\nCOPY --from=dependencies \/root\/chat\/prod_node_modules .\/node_modules\n# copy app sources\nCOPY . .\n# expose port and define CMD\nEXPOSE 5000\nCMD npm run start\n<\/code><\/pre>\n<p>&nbsp;<\/p>\n<h2>Summary<\/h2>\n<p>This was the first post in series. In the next <a href=\"https:\/\/codefresh.io\/blog\/cd_helm_kubernetes_microservices_2\/\">part<\/a>, I will cover out POV for Kubernetes <em>Continuous Deployment<\/em> and <em>Continuous Delivery<\/em>.<\/p>\n<p>We constantly change Codefresh to be the product that helps us and our customers to build and maintain effective Kubernetes CD pipelines. Give it a try and let us know how can we improve it.<\/p>\n<hr \/>\n<p>Hope, you find this post useful. I look forward to your comments and any questions you have.<\/p>\n<div class=\"grammarly-disable-indicator\"><\/div>\n<div class=\"grammarly-disable-indicator\"><\/div>\n<div class=\"grammarly-disable-indicator\"><\/div>\n<div class=\"grammarly-disable-indicator\"><\/div>\n<div class=\"grammarly-disable-indicator\"><\/div>\n<div class=\"grammarly-disable-indicator\"><\/div>\n<div class=\"grammarly-disable-indicator\"><\/div>\n<div class=\"grammarly-disable-indicator\"><\/div>\n<div class=\"grammarly-disable-indicator\"><\/div>\n<div class=\"grammarly-disable-indicator\"><\/div>\n<div class=\"grammarly-disable-indicator\"><\/div>\n<div class=\"grammarly-disable-indicator\"><\/div>\n<div class=\"grammarly-disable-indicator\"><\/div>\n<div class=\"grammarly-disable-indicator\"><\/div>\n<div class=\"grammarly-disable-indicator\"><\/div>\n<div class=\"grammarly-disable-indicator\"><\/div>\n<div class=\"grammarly-disable-indicator\"><\/div>\n<div class=\"grammarly-disable-indicator\"><\/div>\n<div class=\"grammarly-disable-indicator\"><\/div>\n<div class=\"grammarly-disable-indicator\"><\/div>\n<p>New to Codefresh? <a href=\"https:\/\/codefresh.io\/codefresh-signup\/?utm_source=Blog&amp;utm_medium=Post&amp;utm_campaign=EKsB\">Create Your Free Account Today! <\/a><\/p>\n<input class=\"fooboxshare_post_id\" type=\"hidden\" value=\"5588\"\/>","protected":false},"excerpt":{"rendered":"<p>Starting Point Over the last years, we&#8217;ve been adopting several concepts for our project, struggling to make them work together. Let&#8217;s look at some of the concepts: Microservice Architecture The first one is the Microservice Architecture. We did not start it clean and by the book, rather applied it to an already existing project by &hellip; <a href=\"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_1\/\">Read more<\/a><\/p>\n","protected":false},"author":28,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[1657],"tags":[14,15,44,52,53,64,68,78,94,98,980,981,994],"yoast_head":"<!-- This site is optimized with the Yoast SEO Premium plugin v17.9 (Yoast SEO v18.4.1) - https:\/\/yoast.com\/wordpress\/plugins\/seo\/ -->\n<title>Continuous Delivery and Continuous Deployment for Kubernetes (part 1) | Codefresh<\/title>\n<meta name=\"description\" content=\"A practical guide to Continuous Delivery and Continuous Deployment for Kubernetes with Helm - Part 1\" \/>\n<meta name=\"robots\" content=\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\" \/>\n<link rel=\"canonical\" href=\"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_1\/\" \/>\n<meta property=\"og:locale\" content=\"en_US\" \/>\n<meta property=\"og:type\" content=\"article\" \/>\n<meta property=\"og:title\" content=\"Continuous Delivery and Continuous Deployment for Kubernetes (part 1)\" \/>\n<meta property=\"og:description\" content=\"A practical guide to Continuous Delivery and Continuous Deployment for Kubernetes with Helm - Part 1\" \/>\n<meta property=\"og:url\" content=\"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_1\/\" \/>\n<meta property=\"og:site_name\" content=\"Codefresh\" \/>\n<meta property=\"article:publisher\" content=\"https:\/\/www.facebook.com\/codefresh.io\" \/>\n<meta property=\"article:published_time\" content=\"2017-12-07T09:29:28+00:00\" \/>\n<meta property=\"article:modified_time\" content=\"2022-02-09T15:22:03+00:00\" \/>\n<meta property=\"og:image\" content=\"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/continuous-delivery-vs-continuous-deployment-infographic-305dd620.png\" \/>\n<meta name=\"twitter:card\" content=\"summary_large_image\" \/>\n<meta name=\"twitter:creator\" content=\"@alexeiled\" \/>\n<meta name=\"twitter:site\" content=\"@codefresh\" \/>\n<meta name=\"twitter:label1\" content=\"Written by\" \/>\n\t<meta name=\"twitter:data1\" content=\"Alexei Ledenev\" \/>\n\t<meta name=\"twitter:label2\" content=\"Est. reading time\" \/>\n\t<meta name=\"twitter:data2\" content=\"8 minutes\" \/>\n<script type=\"application\/ld+json\" class=\"yoast-schema-graph\">{\"@context\":\"https:\/\/schema.org\",\"@graph\":[{\"@type\":\"Organization\",\"@id\":\"https:\/\/codefresh.io\/#organization\",\"name\":\"Codefresh\",\"url\":\"https:\/\/codefresh.io\/\",\"sameAs\":[\"https:\/\/www.facebook.com\/codefresh.io\",\"https:\/\/www.linkedin.com\/company\/codefresh\",\"https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg\",\"https:\/\/twitter.com\/codefresh\"],\"logo\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#logo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"width\":800,\"height\":800,\"caption\":\"Codefresh\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/#logo\"}},{\"@type\":\"WebSite\",\"@id\":\"https:\/\/codefresh.io\/#website\",\"url\":\"https:\/\/codefresh.io\/\",\"name\":\"Codefresh\",\"description\":\"\",\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"potentialAction\":[{\"@type\":\"SearchAction\",\"target\":{\"@type\":\"EntryPoint\",\"urlTemplate\":\"https:\/\/codefresh.io\/?s={search_term_string}\"},\"query-input\":\"required name=search_term_string\"}],\"inLanguage\":\"en-US\"},{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_1\/#primaryimage\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/continuous-delivery-vs-continuous-deployment-infographic-305dd620.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/continuous-delivery-vs-continuous-deployment-infographic-305dd620.png\",\"width\":800,\"height\":900},{\"@type\":\"WebPage\",\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_1\/#webpage\",\"url\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_1\/\",\"name\":\"Continuous Delivery and Continuous Deployment for Kubernetes (part 1) | Codefresh\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/#website\"},\"primaryImageOfPage\":{\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_1\/#primaryimage\"},\"datePublished\":\"2017-12-07T09:29:28+00:00\",\"dateModified\":\"2022-02-09T15:22:03+00:00\",\"description\":\"A practical guide to Continuous Delivery and Continuous Deployment for Kubernetes with Helm - Part 1\",\"breadcrumb\":{\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_1\/#breadcrumb\"},\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"ReadAction\",\"target\":[\"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_1\/\"]}]},{\"@type\":\"BreadcrumbList\",\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_1\/#breadcrumb\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"name\":\"Home\",\"item\":\"https:\/\/codefresh.io\/\"},{\"@type\":\"ListItem\",\"position\":2,\"name\":\"Continuous Delivery and Continuous Deployment for Kubernetes (part 1)\"}]},{\"@type\":\"Article\",\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_1\/#article\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_1\/#webpage\"},\"author\":{\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/33798ced90c48c116c3a9a59ae74af50\"},\"headline\":\"Continuous Delivery and Continuous Deployment for Kubernetes (part 1)\",\"datePublished\":\"2017-12-07T09:29:28+00:00\",\"dateModified\":\"2022-02-09T15:22:03+00:00\",\"mainEntityOfPage\":{\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_1\/#webpage\"},\"wordCount\":1415,\"commentCount\":2,\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_1\/#primaryimage\"},\"thumbnailUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/continuous-delivery-vs-continuous-deployment-infographic-305dd620.png\",\"keywords\":[\"docker\",\"continuous integration\",\"Kubernetes\",\"devops\",\"CI\/CD\",\"microservices\",\"continuous delivery\",\"ci\",\"docker ci\",\"multi-stage\",\"continuous deployment\",\"kubernetes cd\",\"helm\"],\"articleSection\":[\"Kubernetes Tutorials\"],\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"CommentAction\",\"name\":\"Comment\",\"target\":[\"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_1\/#respond\"]}]},{\"@type\":\"Person\",\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/33798ced90c48c116c3a9a59ae74af50\",\"name\":\"Alexei Ledenev\",\"image\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#personlogo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/secure.gravatar.com\/avatar\/53d5ff05d62acd594ea97300543a62a5?s=96&d=blank&r=g\",\"contentUrl\":\"https:\/\/secure.gravatar.com\/avatar\/53d5ff05d62acd594ea97300543a62a5?s=96&d=blank&r=g\",\"caption\":\"Alexei Ledenev\"},\"description\":\"Alexei is an experienced software architect and HPE distinguished technologist. He currently works at Codefresh as the Chief Researcher, focusing lately on #docker, #golang and #aws. In his spare time, Alexei maintains a couple of Docker-centric open-source projects, writes tech blog posts, and enjoys traveling and playing with his kids. https:\/\/github.com\/gaia-adm\/pumba\",\"sameAs\":[\"https:\/\/medium.com\/@alexeiled\/\",\"https:\/\/twitter.com\/alexeiled\"],\"url\":\"https:\/\/codefresh.io\/author\/alexei\/\"}]}<\/script>\n<!-- \/ Yoast SEO Premium plugin. -->","yoast_head_json":{"title":"Continuous Delivery and Continuous Deployment for Kubernetes (part 1) | Codefresh","description":"A practical guide to Continuous Delivery and Continuous Deployment for Kubernetes with Helm - Part 1","robots":{"index":"index","follow":"follow","max-snippet":"max-snippet:-1","max-image-preview":"max-image-preview:large","max-video-preview":"max-video-preview:-1"},"canonical":"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_1\/","og_locale":"en_US","og_type":"article","og_title":"Continuous Delivery and Continuous Deployment for Kubernetes (part 1)","og_description":"A practical guide to Continuous Delivery and Continuous Deployment for Kubernetes with Helm - Part 1","og_url":"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_1\/","og_site_name":"Codefresh","article_publisher":"https:\/\/www.facebook.com\/codefresh.io","article_published_time":"2017-12-07T09:29:28+00:00","article_modified_time":"2022-02-09T15:22:03+00:00","og_image":[{"url":"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/continuous-delivery-vs-continuous-deployment-infographic-305dd620.png"}],"twitter_card":"summary_large_image","twitter_creator":"@alexeiled","twitter_site":"@codefresh","twitter_misc":{"Written by":"Alexei Ledenev","Est. reading time":"8 minutes"},"schema":{"@context":"https:\/\/schema.org","@graph":[{"@type":"Organization","@id":"https:\/\/codefresh.io\/#organization","name":"Codefresh","url":"https:\/\/codefresh.io\/","sameAs":["https:\/\/www.facebook.com\/codefresh.io","https:\/\/www.linkedin.com\/company\/codefresh","https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg","https:\/\/twitter.com\/codefresh"],"logo":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#logo","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","width":800,"height":800,"caption":"Codefresh"},"image":{"@id":"https:\/\/codefresh.io\/#logo"}},{"@type":"WebSite","@id":"https:\/\/codefresh.io\/#website","url":"https:\/\/codefresh.io\/","name":"Codefresh","description":"","publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"potentialAction":[{"@type":"SearchAction","target":{"@type":"EntryPoint","urlTemplate":"https:\/\/codefresh.io\/?s={search_term_string}"},"query-input":"required name=search_term_string"}],"inLanguage":"en-US"},{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_1\/#primaryimage","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/continuous-delivery-vs-continuous-deployment-infographic-305dd620.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/continuous-delivery-vs-continuous-deployment-infographic-305dd620.png","width":800,"height":900},{"@type":"WebPage","@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_1\/#webpage","url":"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_1\/","name":"Continuous Delivery and Continuous Deployment for Kubernetes (part 1) | Codefresh","isPartOf":{"@id":"https:\/\/codefresh.io\/#website"},"primaryImageOfPage":{"@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_1\/#primaryimage"},"datePublished":"2017-12-07T09:29:28+00:00","dateModified":"2022-02-09T15:22:03+00:00","description":"A practical guide to Continuous Delivery and Continuous Deployment for Kubernetes with Helm - Part 1","breadcrumb":{"@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_1\/#breadcrumb"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_1\/"]}]},{"@type":"BreadcrumbList","@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_1\/#breadcrumb","itemListElement":[{"@type":"ListItem","position":1,"name":"Home","item":"https:\/\/codefresh.io\/"},{"@type":"ListItem","position":2,"name":"Continuous Delivery and Continuous Deployment for Kubernetes (part 1)"}]},{"@type":"Article","@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_1\/#article","isPartOf":{"@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_1\/#webpage"},"author":{"@id":"https:\/\/codefresh.io\/#\/schema\/person\/33798ced90c48c116c3a9a59ae74af50"},"headline":"Continuous Delivery and Continuous Deployment for Kubernetes (part 1)","datePublished":"2017-12-07T09:29:28+00:00","dateModified":"2022-02-09T15:22:03+00:00","mainEntityOfPage":{"@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_1\/#webpage"},"wordCount":1415,"commentCount":2,"publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"image":{"@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_1\/#primaryimage"},"thumbnailUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/continuous-delivery-vs-continuous-deployment-infographic-305dd620.png","keywords":["docker","continuous integration","Kubernetes","devops","CI\/CD","microservices","continuous delivery","ci","docker ci","multi-stage","continuous deployment","kubernetes cd","helm"],"articleSection":["Kubernetes Tutorials"],"inLanguage":"en-US","potentialAction":[{"@type":"CommentAction","name":"Comment","target":["https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_1\/#respond"]}]},{"@type":"Person","@id":"https:\/\/codefresh.io\/#\/schema\/person\/33798ced90c48c116c3a9a59ae74af50","name":"Alexei Ledenev","image":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#personlogo","inLanguage":"en-US","url":"https:\/\/secure.gravatar.com\/avatar\/53d5ff05d62acd594ea97300543a62a5?s=96&d=blank&r=g","contentUrl":"https:\/\/secure.gravatar.com\/avatar\/53d5ff05d62acd594ea97300543a62a5?s=96&d=blank&r=g","caption":"Alexei Ledenev"},"description":"Alexei is an experienced software architect and HPE distinguished technologist. He currently works at Codefresh as the Chief Researcher, focusing lately on #docker, #golang and #aws. In his spare time, Alexei maintains a couple of Docker-centric open-source projects, writes tech blog posts, and enjoys traveling and playing with his kids. https:\/\/github.com\/gaia-adm\/pumba","sameAs":["https:\/\/medium.com\/@alexeiled\/","https:\/\/twitter.com\/alexeiled"],"url":"https:\/\/codefresh.io\/author\/alexei\/"}]}},"acf":[],"_links":{"self":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/5588"}],"collection":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/users\/28"}],"replies":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/comments?post=5588"}],"version-history":[{"count":1,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/5588\/revisions"}],"predecessor-version":[{"id":21393,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/5588\/revisions\/21393"}],"wp:attachment":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media?parent=5588"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/categories?post=5588"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/tags?post=5588"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}