{"id":5677,"date":"2017-12-07T09:29:50","date_gmt":"2017-12-07T09:29:50","guid":{"rendered":"https:\/\/codefresh.io\/?p=5677"},"modified":"2022-02-09T15:22:29","modified_gmt":"2022-02-09T15:22:29","slug":"cd_helm_kubernetes_microservices_2","status":"publish","type":"post","link":"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_2\/","title":{"rendered":"Continuous Delivery and Continuous Deployment for Kubernetes (part 2)"},"content":{"rendered":"<h2>Part 2<\/h2>\n<p>In the previous <a href=\"https:\/\/codefresh.io\/blog\/cd_helm_kubernetes_microservices_1\/\">post<\/a>, I&#8217;ve covered <em>Docker CI<\/em>, and talked about <em>Continuous Deployment<\/em> and <em>Continuous Delivery<\/em>.<\/p>\n<p>This time, I&#8217;m going to share our POV for building effective <em>CD<\/em> (both CD types) for a microservice based application, running on a Kubernetes cluster.<\/p>\n<h2>Kubernetes Continuous Delivery (CD)<\/h2>\n<p>Building Docker image on <code>git push<\/code> is a very first step you need to automate, but &#8230;<\/p>\n<blockquote><p><em>Docker Continuous Integration<\/em> is not a <em>Kubernetes Continuous Deployment\/Delivery<\/em><\/p><\/blockquote>\n<p>After CI completes, you just have a new build artifact &#8211; a Docker image file.<\/p>\n<p>Now, somehow you need to deploy it to the desired environment (Kubernetes cluster) and maybe also need to modify other Kubernetes resources, like configurations, secrets, volumes, policies, and others. Or maybe you do not have a <em>&#8220;pure&#8221;<\/em> microservice architecture and some of your services still have some kind of inter-dependency and have to be released together. I know, this is not <em>&#8220;by the book&#8221;<\/em>, but this is a very common use case: people are not perfect and not all architectures out there are perfect either. Usually, you start from an already existing project and try to move it to a new <em>ideal<\/em> architecture step by step.<\/p>\n<p>So, on one side, you have one or more freshly backed Docker images.<\/p>\n<p>On the other side, there are one or more environments where you want to deploy these images with related configuration changes. And most likely, you would like to reduce required manual effort to the bare minimum or dismiss it completely, if possible.<\/p>\n<p><em>Continuous Delivery<\/em> is the next step we are taking.<\/p>\n<p>Most of the CD tasks should be automated, while there still may be a few tasks that should be done manually. The reason for having manual tasks can be different: either you cannot achieve full automation or you want to have a feeling of control (deciding when to release by pressing some &#8220;Release&#8221; button), or there is some manual effort required (bring the new server and switch it on)<\/p>\n<p>For our <em>Kubernetes Continuous Delivery<\/em> pipeline, we manually update Codefresh application Helm <em>chart<\/em> with appropriate image tags and sometimes we also update different Kubernetes <code>YAML<\/code> template files too (defining a new <em>PVC<\/em> or environment variable). Once changes to our application <em>chart<\/em> are pushed into the git repository, an automated <em>Continuous Delivery<\/em> pipeline execution is triggered.<\/p>\n<p>Codefresh includes some helper steps that make building <strong>Kubernetes CD<\/strong> pipeline easier. First, we have a built-in <code>helm update<\/code> step that can install or update a Helm chart on specified Kubernetes cluster or namespace, using Kubernetes context, defined in Codefresh account.<\/p>\n<p>Codefresh also provides a nice view of what is running in your Kubernetes cluster, where it comes from (release, build) and what does it contain: images, image metadata (quality, security, etc.), code commits.<\/p>\n<p>We use our own service (Codefresh) to build an effective Kubernetes <em>Continuous Delivery<\/em> pipeline for deploying Codefresh itself. We also constantly add new features and useful functionality that simplify our life (as developers) and hopefully help our customers too.<\/p>\n<p><img class=\"aligncenter size-full wp-image-5596\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/cf_helm_rel.png\" alt=\"\" width=\"1800\" height=\"1125\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/cf_helm_rel.png 1800w, https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/cf_helm_rel-300x188.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/cf_helm_rel-768x480.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/cf_helm_rel-1024x640.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/cf_helm_rel-525x328.png 525w\" sizes=\"(max-width: 1800px) 100vw, 1800px\" \/><\/p>\n<h3>Typical Kubernetes Continuous Delivery flow<\/h3>\n<figure id=\"attachment_5592\" aria-describedby=\"caption-attachment-5592\" style=\"width: 2020px\" class=\"wp-caption alignleft\"><img class=\"wp-image-5592 size-full\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/k8s_cd.png\" alt=\"\" width=\"2020\" height=\"442\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/k8s_cd.png 2020w, https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/k8s_cd-300x66.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/k8s_cd-768x168.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/k8s_cd-1024x224.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/k8s_cd-628x137.png 628w\" sizes=\"(max-width: 2020px) 100vw, 2020px\" \/><figcaption id=\"caption-attachment-5592\" class=\"wp-caption-text\">Kubernetes Continuous Delivery<\/figcaption><\/figure>\n<ol>\n<li>Setup a Docker CI for the application microservices<\/li>\n<li>Update microservice\/s code and <em>chart<\/em> template files, if needed (adding ports, env variables, volumes, etc.)<\/li>\n<li>Wait till Docker CI completes and you have a new Docker image for updated microservice\/s<\/li>\n<li>Manage the application Helm chart code in separate <code>git<\/code> repository; use the same git branch methodology as for microservices<\/li>\n<li>Manually update <code>imageTag<\/code>s for updated microservice\/s<\/li>\n<li>Manually update the application Helm <em>chart<\/em> version<\/li>\n<li>Trigger CD pipeline on <code>git push<\/code> event for the application Helm <em>chart<\/em> git repository<\/li>\n<\/ol>\n<ul>\n<li>validate Helm chart syntax using <code>helm lint<\/code> command<\/li>\n<li>convert Helm chart to Kubernetes template files (with <code>helm template<\/code> plugin) and use <a href=\"https:\/\/github.com\/garethr\/kubeval\"><code>kubeval<\/code><\/a> tool to validate these files<\/li>\n<li>package the application Helm <code>chart<\/code> and push it to the Helm <em>chart repository<\/em><\/li>\n<li><em>Tip:<\/em> create few chart repositories; I suggest having a <em>chart repository<\/em> per environment: <code>production<\/code>, <code>staging<\/code>, <code>develop<\/code><\/li>\n<\/ul>\n<ol>\n<li>Manually (or automatically) execute <code>helm upgrade --install<\/code> from corresponding <em>chart repository<\/em><\/li>\n<\/ol>\n<p>After CD completes, we have a new <strong>artifact<\/strong> &#8211; an updated Helm <em>chart package<\/em> (<code>tar<\/code> archive) of our Kubernetes application with a new version number.<\/p>\n<p>Now, we can run <code>help upgrade --install<\/code> command creating a new <em>revision<\/em> for the application <em>release<\/em>. If something goes wrong, we can always rollback failed release to the previous <em>revision<\/em>. For the sake of safety, I suggest first to run <code>helm diff<\/code> (using <code>helm diff<\/code> plugin) or at least use a <code>--dry-run<\/code> flag for the first run, inspect the difference between a new <em>release<\/em> version and already installed <em>revision<\/em>. If you are ok with upcoming changes, accept them and run the <code>helm upgrade --install<\/code> command without <code>--dry-run<\/code> flag.<\/p>\n<h2>Kubernetes Continuous Deployment (CD)<\/h2>\n<p>Based on above definition, to achieve <em>Continuous Deployment<\/em> we should try to avoid all manual steps, besides <code>git push<\/code> for code and configuration changes. All actions, running after <code>git push<\/code>, should be 100% automated and deliver all changes to a corresponding runtime environment.<\/p>\n<p>Let&#8217;s take a look at manual steps from &#8220;Continuous Delivery&#8221; pipeline and think about <em>how can we automate them?<\/em><\/p>\n<figure id=\"attachment_5591\" aria-describedby=\"caption-attachment-5591\" style=\"width: 2000px\" class=\"wp-caption alignleft\"><img class=\"wp-image-5591 size-full\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/k8s_cdd.png\" alt=\"\" width=\"2000\" height=\"474\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/k8s_cdd.png 2000w, https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/k8s_cdd-300x71.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/k8s_cdd-768x182.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/k8s_cdd-1024x243.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/k8s_cdd-628x149.png 628w\" sizes=\"(max-width: 2000px) 100vw, 2000px\" \/><figcaption id=\"caption-attachment-5591\" class=\"wp-caption-text\">Kubernetes Continuous Deployment<\/figcaption><\/figure>\n<h3>Automate: Update microservice imageTag after successful <code>docker push<\/code><\/h3>\n<p>After a new Docker image for some microservice pushed to a Docker Registry, we would like to update the microservice Helm <em>chart<\/em> with the new Docker image tag. There are two (at least) options to do this.<\/p>\n<ol>\n<li>Add a Docker Registry <em>WebHook<\/em> handler (for example, using AWS Lambda). Take the new image tag from the DockerHub <code>push<\/code> event payload and update corresponding <code>imageTag<\/code> in the Application Helm <em>chart<\/em>. For GitHub, we can use GitHub API to update a single file or bash scripting with mixture of <code>sed<\/code> and <code>git<\/code> commands.<\/li>\n<li>Add an additional step to every microservice CI pipeline, after <code>docker push<\/code> step, to update a corresponding <code>imageTag<\/code> for the microservice Helm <em>chart<\/em><\/li>\n<\/ol>\n<h3>Automate: Deploy Application Helm chart<\/h3>\n<p>After a new <em>chart<\/em> version uploaded to a <em>chart repository<\/em>, we would like to deploy it automatically to &#8220;linked&#8221; runtime environment and rollback on failure.<\/p>\n<p>Helm <em>chart repository<\/em> is not a real server that aware of deployed <em>charts<\/em>. It is possible to use any Web server that can serve static files as a Helm <em>chart repository<\/em>. In general, I like simplicity, but sometimes it leads to naive design and lack of basic functionality. With Helm <em>chart repository<\/em> it is the case.<br \/>\nTherefore, I recommend using a web server that supports nice API and allows to get notifications about content change without <em>pull loop<\/em>. Amazon S3 can be a good choice for Helm <em>chart repository<\/em><\/p>\n<p>Once you have a <em>chart repository<\/em> up and running and can get notifications about a content update (as <code>WebHook<\/code> or with <code>pool loop<\/code>), and make next steps towards Kubernetes <em>Continuous Deployment<\/em>.<\/p>\n<ol>\n<li>Get updates from Helm <em>chart repository<\/em>: new <em>chart<\/em> version<\/li>\n<li>Run <code>helm update --install<\/code> command to update\/install a new application version on &#8220;linked&#8221; runtime environment<\/li>\n<li>Run post-install and in-cluster integration tests<\/li>\n<li>Rollback to the previous application revision on any &#8220;failure&#8221;<\/li>\n<\/ol>\n<h2>Summary<\/h2>\n<p>This post describes our current Kubernetes <em>Continuous Delivery<\/em>&#8221; pipeline we succeeded to setup. There are still things we need to improve and change in order to achieve fully automated <em>Continuous Deployment<\/em>.<\/p>\n<p>We constantly change Codefresh to be the product that helps us and our customers to build and maintain effective Kubernetes CD pipelines. Give it a try and let us know how can we improve it.<\/p>\n<hr \/>\n<p>Hope, you find this post useful. I look forward to your comments and any questions you have.<\/p>\n<div class=\"grammarly-disable-indicator\"><\/div>\n<div class=\"grammarly-disable-indicator\"><\/div>\n<div class=\"grammarly-disable-indicator\"><\/div>\n<div class=\"grammarly-disable-indicator\"><\/div>\n<div class=\"grammarly-disable-indicator\"><\/div>\n<div class=\"grammarly-disable-indicator\"><\/div>\n<div class=\"grammarly-disable-indicator\"><\/div>\n<div class=\"grammarly-disable-indicator\"><\/div>\n<div class=\"grammarly-disable-indicator\"><\/div>\n<div class=\"grammarly-disable-indicator\"><\/div>\n<div class=\"grammarly-disable-indicator\"><\/div>\n<div class=\"grammarly-disable-indicator\"><\/div>\n<div class=\"grammarly-disable-indicator\"><\/div>\n<div class=\"grammarly-disable-indicator\"><\/div>\n<div class=\"grammarly-disable-indicator\"><\/div>\n<div class=\"grammarly-disable-indicator\"><\/div>\n<div class=\"grammarly-disable-indicator\"><\/div>\n<div class=\"grammarly-disable-indicator\"><\/div>\n<p>New to Codefresh? <a href=\"https:\/\/codefresh.io\/codefresh-signup\/?utm_source=Blog&amp;utm_medium=Post&amp;utm_campaign=EKsB\">Create Your Free Account Today! <\/a><\/p>\n<input class=\"fooboxshare_post_id\" type=\"hidden\" value=\"5677\"\/>","protected":false},"excerpt":{"rendered":"<p>Part 2 In the previous post, I&#8217;ve covered Docker CI, and talked about Continuous Deployment and Continuous Delivery. This time, I&#8217;m going to share our POV for building effective CD (both CD types) for a microservice based application, running on a Kubernetes cluster. Kubernetes Continuous Delivery (CD) Building Docker image on git push is a &hellip; <a href=\"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_2\/\">Read more<\/a><\/p>\n","protected":false},"author":28,"featured_media":5591,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[1657],"tags":[14,15,44,52,53,64,68,78,94,980,981,994],"yoast_head":"<!-- This site is optimized with the Yoast SEO Premium plugin v17.9 (Yoast SEO v18.4.1) - https:\/\/yoast.com\/wordpress\/plugins\/seo\/ -->\n<title>Continuous Delivery and Continuous Deployment for Kubernetes (part 2) | Codefresh<\/title>\n<meta name=\"description\" content=\"A practical guide to Continuous Delivery and Continuous Deployment for Kubernetes with Helm - Part 2\" \/>\n<meta name=\"robots\" content=\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\" \/>\n<link rel=\"canonical\" href=\"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_2\/\" \/>\n<meta property=\"og:locale\" content=\"en_US\" \/>\n<meta property=\"og:type\" content=\"article\" \/>\n<meta property=\"og:title\" content=\"Continuous Delivery and Continuous Deployment for Kubernetes (part 2)\" \/>\n<meta property=\"og:description\" content=\"A practical guide to Continuous Delivery and Continuous Deployment for Kubernetes with Helm - Part 2\" \/>\n<meta property=\"og:url\" content=\"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_2\/\" \/>\n<meta property=\"og:site_name\" content=\"Codefresh\" \/>\n<meta property=\"article:publisher\" content=\"https:\/\/www.facebook.com\/codefresh.io\" \/>\n<meta property=\"article:published_time\" content=\"2017-12-07T09:29:50+00:00\" \/>\n<meta property=\"article:modified_time\" content=\"2022-02-09T15:22:29+00:00\" \/>\n<meta property=\"og:image\" content=\"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/k8s_cdd.png\" \/>\n\t<meta property=\"og:image:width\" content=\"2000\" \/>\n\t<meta property=\"og:image:height\" content=\"474\" \/>\n\t<meta property=\"og:image:type\" content=\"image\/png\" \/>\n<meta name=\"twitter:card\" content=\"summary_large_image\" \/>\n<meta name=\"twitter:creator\" content=\"@alexeiled\" \/>\n<meta name=\"twitter:site\" content=\"@codefresh\" \/>\n<meta name=\"twitter:label1\" content=\"Written by\" \/>\n\t<meta name=\"twitter:data1\" content=\"Alexei Ledenev\" \/>\n\t<meta name=\"twitter:label2\" content=\"Est. reading time\" \/>\n\t<meta name=\"twitter:data2\" content=\"6 minutes\" \/>\n<script type=\"application\/ld+json\" class=\"yoast-schema-graph\">{\"@context\":\"https:\/\/schema.org\",\"@graph\":[{\"@type\":\"Organization\",\"@id\":\"https:\/\/codefresh.io\/#organization\",\"name\":\"Codefresh\",\"url\":\"https:\/\/codefresh.io\/\",\"sameAs\":[\"https:\/\/www.facebook.com\/codefresh.io\",\"https:\/\/www.linkedin.com\/company\/codefresh\",\"https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg\",\"https:\/\/twitter.com\/codefresh\"],\"logo\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#logo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"width\":800,\"height\":800,\"caption\":\"Codefresh\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/#logo\"}},{\"@type\":\"WebSite\",\"@id\":\"https:\/\/codefresh.io\/#website\",\"url\":\"https:\/\/codefresh.io\/\",\"name\":\"Codefresh\",\"description\":\"\",\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"potentialAction\":[{\"@type\":\"SearchAction\",\"target\":{\"@type\":\"EntryPoint\",\"urlTemplate\":\"https:\/\/codefresh.io\/?s={search_term_string}\"},\"query-input\":\"required name=search_term_string\"}],\"inLanguage\":\"en-US\"},{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_2\/#primaryimage\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/k8s_cdd.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/k8s_cdd.png\",\"width\":2000,\"height\":474},{\"@type\":\"WebPage\",\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_2\/#webpage\",\"url\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_2\/\",\"name\":\"Continuous Delivery and Continuous Deployment for Kubernetes (part 2) | Codefresh\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/#website\"},\"primaryImageOfPage\":{\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_2\/#primaryimage\"},\"datePublished\":\"2017-12-07T09:29:50+00:00\",\"dateModified\":\"2022-02-09T15:22:29+00:00\",\"description\":\"A practical guide to Continuous Delivery and Continuous Deployment for Kubernetes with Helm - Part 2\",\"breadcrumb\":{\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_2\/#breadcrumb\"},\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"ReadAction\",\"target\":[\"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_2\/\"]}]},{\"@type\":\"BreadcrumbList\",\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_2\/#breadcrumb\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"name\":\"Home\",\"item\":\"https:\/\/codefresh.io\/\"},{\"@type\":\"ListItem\",\"position\":2,\"name\":\"Continuous Delivery and Continuous Deployment for Kubernetes (part 2)\"}]},{\"@type\":\"Article\",\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_2\/#article\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_2\/#webpage\"},\"author\":{\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/33798ced90c48c116c3a9a59ae74af50\"},\"headline\":\"Continuous Delivery and Continuous Deployment for Kubernetes (part 2)\",\"datePublished\":\"2017-12-07T09:29:50+00:00\",\"dateModified\":\"2022-02-09T15:22:29+00:00\",\"mainEntityOfPage\":{\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_2\/#webpage\"},\"wordCount\":1210,\"commentCount\":5,\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_2\/#primaryimage\"},\"thumbnailUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/k8s_cdd.png\",\"keywords\":[\"docker\",\"continuous integration\",\"Kubernetes\",\"devops\",\"CI\/CD\",\"microservices\",\"continuous delivery\",\"ci\",\"docker ci\",\"continuous deployment\",\"kubernetes cd\",\"helm\"],\"articleSection\":[\"Kubernetes Tutorials\"],\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"CommentAction\",\"name\":\"Comment\",\"target\":[\"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_2\/#respond\"]}]},{\"@type\":\"Person\",\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/33798ced90c48c116c3a9a59ae74af50\",\"name\":\"Alexei Ledenev\",\"image\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#personlogo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/secure.gravatar.com\/avatar\/53d5ff05d62acd594ea97300543a62a5?s=96&d=blank&r=g\",\"contentUrl\":\"https:\/\/secure.gravatar.com\/avatar\/53d5ff05d62acd594ea97300543a62a5?s=96&d=blank&r=g\",\"caption\":\"Alexei Ledenev\"},\"description\":\"Alexei is an experienced software architect and HPE distinguished technologist. He currently works at Codefresh as the Chief Researcher, focusing lately on #docker, #golang and #aws. In his spare time, Alexei maintains a couple of Docker-centric open-source projects, writes tech blog posts, and enjoys traveling and playing with his kids. https:\/\/github.com\/gaia-adm\/pumba\",\"sameAs\":[\"https:\/\/medium.com\/@alexeiled\/\",\"https:\/\/twitter.com\/alexeiled\"],\"url\":\"https:\/\/codefresh.io\/author\/alexei\/\"}]}<\/script>\n<!-- \/ Yoast SEO Premium plugin. -->","yoast_head_json":{"title":"Continuous Delivery and Continuous Deployment for Kubernetes (part 2) | Codefresh","description":"A practical guide to Continuous Delivery and Continuous Deployment for Kubernetes with Helm - Part 2","robots":{"index":"index","follow":"follow","max-snippet":"max-snippet:-1","max-image-preview":"max-image-preview:large","max-video-preview":"max-video-preview:-1"},"canonical":"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_2\/","og_locale":"en_US","og_type":"article","og_title":"Continuous Delivery and Continuous Deployment for Kubernetes (part 2)","og_description":"A practical guide to Continuous Delivery and Continuous Deployment for Kubernetes with Helm - Part 2","og_url":"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_2\/","og_site_name":"Codefresh","article_publisher":"https:\/\/www.facebook.com\/codefresh.io","article_published_time":"2017-12-07T09:29:50+00:00","article_modified_time":"2022-02-09T15:22:29+00:00","og_image":[{"width":2000,"height":474,"url":"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/k8s_cdd.png","type":"image\/png"}],"twitter_card":"summary_large_image","twitter_creator":"@alexeiled","twitter_site":"@codefresh","twitter_misc":{"Written by":"Alexei Ledenev","Est. reading time":"6 minutes"},"schema":{"@context":"https:\/\/schema.org","@graph":[{"@type":"Organization","@id":"https:\/\/codefresh.io\/#organization","name":"Codefresh","url":"https:\/\/codefresh.io\/","sameAs":["https:\/\/www.facebook.com\/codefresh.io","https:\/\/www.linkedin.com\/company\/codefresh","https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg","https:\/\/twitter.com\/codefresh"],"logo":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#logo","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","width":800,"height":800,"caption":"Codefresh"},"image":{"@id":"https:\/\/codefresh.io\/#logo"}},{"@type":"WebSite","@id":"https:\/\/codefresh.io\/#website","url":"https:\/\/codefresh.io\/","name":"Codefresh","description":"","publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"potentialAction":[{"@type":"SearchAction","target":{"@type":"EntryPoint","urlTemplate":"https:\/\/codefresh.io\/?s={search_term_string}"},"query-input":"required name=search_term_string"}],"inLanguage":"en-US"},{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_2\/#primaryimage","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/k8s_cdd.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/k8s_cdd.png","width":2000,"height":474},{"@type":"WebPage","@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_2\/#webpage","url":"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_2\/","name":"Continuous Delivery and Continuous Deployment for Kubernetes (part 2) | Codefresh","isPartOf":{"@id":"https:\/\/codefresh.io\/#website"},"primaryImageOfPage":{"@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_2\/#primaryimage"},"datePublished":"2017-12-07T09:29:50+00:00","dateModified":"2022-02-09T15:22:29+00:00","description":"A practical guide to Continuous Delivery and Continuous Deployment for Kubernetes with Helm - Part 2","breadcrumb":{"@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_2\/#breadcrumb"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_2\/"]}]},{"@type":"BreadcrumbList","@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_2\/#breadcrumb","itemListElement":[{"@type":"ListItem","position":1,"name":"Home","item":"https:\/\/codefresh.io\/"},{"@type":"ListItem","position":2,"name":"Continuous Delivery and Continuous Deployment for Kubernetes (part 2)"}]},{"@type":"Article","@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_2\/#article","isPartOf":{"@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_2\/#webpage"},"author":{"@id":"https:\/\/codefresh.io\/#\/schema\/person\/33798ced90c48c116c3a9a59ae74af50"},"headline":"Continuous Delivery and Continuous Deployment for Kubernetes (part 2)","datePublished":"2017-12-07T09:29:50+00:00","dateModified":"2022-02-09T15:22:29+00:00","mainEntityOfPage":{"@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_2\/#webpage"},"wordCount":1210,"commentCount":5,"publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"image":{"@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_2\/#primaryimage"},"thumbnailUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/k8s_cdd.png","keywords":["docker","continuous integration","Kubernetes","devops","CI\/CD","microservices","continuous delivery","ci","docker ci","continuous deployment","kubernetes cd","helm"],"articleSection":["Kubernetes Tutorials"],"inLanguage":"en-US","potentialAction":[{"@type":"CommentAction","name":"Comment","target":["https:\/\/codefresh.io\/kubernetes-tutorial\/cd_helm_kubernetes_microservices_2\/#respond"]}]},{"@type":"Person","@id":"https:\/\/codefresh.io\/#\/schema\/person\/33798ced90c48c116c3a9a59ae74af50","name":"Alexei Ledenev","image":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#personlogo","inLanguage":"en-US","url":"https:\/\/secure.gravatar.com\/avatar\/53d5ff05d62acd594ea97300543a62a5?s=96&d=blank&r=g","contentUrl":"https:\/\/secure.gravatar.com\/avatar\/53d5ff05d62acd594ea97300543a62a5?s=96&d=blank&r=g","caption":"Alexei Ledenev"},"description":"Alexei is an experienced software architect and HPE distinguished technologist. He currently works at Codefresh as the Chief Researcher, focusing lately on #docker, #golang and #aws. In his spare time, Alexei maintains a couple of Docker-centric open-source projects, writes tech blog posts, and enjoys traveling and playing with his kids. https:\/\/github.com\/gaia-adm\/pumba","sameAs":["https:\/\/medium.com\/@alexeiled\/","https:\/\/twitter.com\/alexeiled"],"url":"https:\/\/codefresh.io\/author\/alexei\/"}]}},"acf":[],"_links":{"self":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/5677"}],"collection":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/users\/28"}],"replies":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/comments?post=5677"}],"version-history":[{"count":1,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/5677\/revisions"}],"predecessor-version":[{"id":21394,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/5677\/revisions\/21394"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media\/5591"}],"wp:attachment":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media?parent=5677"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/categories?post=5677"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/tags?post=5677"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}