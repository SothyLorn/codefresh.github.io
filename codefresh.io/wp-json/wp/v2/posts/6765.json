{"id":6765,"date":"2017-06-05T20:57:35","date_gmt":"2017-06-05T20:57:35","guid":{"rendered":"https:\/\/codefresh.io\/?post_type=dockerguides&#038;p=6765"},"modified":"2022-02-11T22:14:22","modified_gmt":"2022-02-11T22:14:22","slug":"continuous-integration-docker-compose","status":"publish","type":"post","link":"https:\/\/codefresh.io\/docker-tutorial\/continuous-integration-docker-compose\/","title":{"rendered":"Continuous Integration with Docker Compose"},"content":{"rendered":"<h2><b>Introduction<\/b><\/h2>\n<p><span style=\"font-weight: 400;\">If you aren\u2019t familiar with <\/span><a href=\"https:\/\/docs.docker.com\/compose\/\"><span style=\"font-weight: 400;\">Compose<\/span><\/a><span style=\"font-weight: 400;\">, it is one of many components in the <\/span><a href=\"https:\/\/www.docker.com\/products\/docker-toolbox\"><span style=\"font-weight: 400;\">Docker Toolbox<\/span><\/a><span style=\"font-weight: 400;\">. It provides developers with the ability to launch multiple Docker containers using a single command-line tool. It especially comes in handy for rapid development iterations and continuous integration. Basically, compose provides a manifest for a deployment environment.<\/span><\/p>\n<p><span style=\"font-weight: 400;\">If you take a step back to consider that a container is a single process and that most applications aren\u2019t self-contained and require access to a networked service, Compose alleviates a lot of deployment concerns. Within a single Compose manifest, you can configure multiple containers, link them together, and bring an entire distributed deployment online with a single command.\u00a0Which is an extremely powerful and a welcome capability. Additionally, Compose is available on most, if not all, continuous integration platforms including <\/span><a href=\"https:\/\/codefresh.io\"><span style=\"font-weight: 400;\">Codefresh<\/span><\/a><span style=\"font-weight: 400;\">. The purpose of this post is to help you become familiar with Compose and how it can be leveraged in a continuous integration pipeline. So I won\u2019t focus on a specific continuous integration platform in this article.<\/span><\/p>\n<h2><b>Getting Started<\/b><\/h2>\n<p><span style=\"font-weight: 400;\">If you don\u2019t already have a copy of Compose installed, head over to the Docker website for the correct <\/span><a href=\"https:\/\/docs.docker.com\/compose\/install\/\"><span style=\"font-weight: 400;\">installer<\/span><\/a><span style=\"font-weight: 400;\">. Once installed, verify that the version is at least 1.9.0.<\/span><\/p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">$ docker-compose -version<\/pre>\n<p><span style=\"font-weight: 400;\">Once verified, clone the example repository to follow along and switch to the <\/span><span style=\"font-weight: 400;\">compose<\/span><span style=\"font-weight: 400;\"> branch.<\/span><\/p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">$ git clone https:\/\/github.com\/n3integration\/dockerize-java\r\n$ cd dockerize-java &amp;&amp; git co compose\r\n<\/pre>\n<h2><b>Configuration<\/b><\/h2>\n<p><span style=\"font-weight: 400;\">At this point, you should have a clean slate. Run <\/span><span style=\"font-weight: 400;\"><code class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">docker-compose ps<\/code><\/span><span style=\"font-weight: 400;\">. You shouldn\u2019t see any running containers, but Compose will reference the local <\/span><span style=\"font-weight: 400;\">docker-compose.yml<\/span><span style=\"font-weight: 400;\"> file to determine which containers are associated with the current project. Within the <\/span><span style=\"font-weight: 400;\">docker-compose.yml <\/span><span style=\"font-weight: 400;\">file, the Compose file format version is specified, followed by a list of containers and their associated configuration. Configuration settings are available through the Docker command line client and also through Compose as volumes, environment variables, networking, etc. For the complete reference on the Compose file format, refer to the official Docker <\/span><a href=\"https:\/\/docs.docker.com\/compose\/compose-file\/\"><span style=\"font-weight: 400;\">documentation<\/span><\/a><span style=\"font-weight: 400;\">.<\/span><\/p>\n<h2><b>Services<\/b><\/h2>\n<p><span style=\"font-weight: 400;\">Within our <\/span><span style=\"font-weight: 400;\">docker-compose.yml <\/span><span style=\"font-weight: 400;\">file, we have two defined services: <\/span><span style=\"font-weight: 400;\">www<\/span><span style=\"font-weight: 400;\"> and <\/span><span style=\"font-weight: 400;\">db<\/span><span style=\"font-weight: 400;\">.<\/span><\/p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">db:\r\n  image: postgres:9.6.3\r\n  ports:\r\n  - \"5432:5432\"\r\n  environment:\r\n  - \"POSTGRES_DB=dockerize\"<\/pre>\n<p><span style=\"font-weight: 400;\">Here, we\u2019ve declared our <\/span><span style=\"font-weight: 400;\">db<\/span><span style=\"font-weight: 400;\"> service to use the standard Postgres image. We\u2019ve also exposed Postgres over the standard service port. Finally, we\u2019ve declared a database name, which in this case will auto create the supplied database for us on startup. Although it may not necessarily be useful in the case of continuous integration, it\u2019s worth pointing out that the standard Postgres image also exposes a volume that can provide persistence.<\/span><\/p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">www:\r\n   build: .\r\n   ports:\r\n   - \"4567:4567\"\r\n   environment:\r\n   - \"DB_URL=jdbc:postgresql:\/\/db:5432\/dockerize\"\r\n   links:\r\n   - db<\/pre>\n<p><span style=\"font-weight: 400;\">Next, we\u2019ve declared our <\/span><span style=\"font-weight: 400;\">www<\/span><span style=\"font-weight: 400;\"> service, which in this case is a simple Java web server that communicates with our database. One immediate difference to point out is that rather than an image, the service under test is supplied using the build command and the path to the <\/span><span style=\"font-weight: 400;\">Dockerfile<\/span><span style=\"font-weight: 400;\">. Another difference is the <\/span><span style=\"font-weight: 400;\">links<\/span><span style=\"font-weight: 400;\"> command, which allows the web container to resolve the db container by its hostname. Other than that, the two services are fairly the same.<\/span><\/p>\n<h2><b>Integration Testing<\/b><\/h2>\n<p><span style=\"font-weight: 400;\">Now that we\u2019ve established a basic understanding of the <\/span><span style=\"font-weight: 400;\">docker-compose.yml<\/span><span style=\"font-weight: 400;\"> file, we can begin establishing our integration pipeline. First, we\u2019ll need to bring the database online.<\/span><\/p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">$ docker-compose up -d db\r\nCreating java_db_1<\/pre>\n<p><span style=\"font-weight: 400;\">Once the database is online, we\u2019ll need to perform a database migration to create the necessary tables and populate the tables with appropriate data.<\/span><\/p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">$ .\/gradlew flywayMigrate\r\n:flywayMigrate\r\n\r\n\r\nBUILD SUCCESSFUL\r\n\r\nTotal time: 1.625 secs<\/pre>\n<p><span style=\"font-weight: 400;\">If completed successfully, you should see output similar to the following when verifying the migration status.<\/span><\/p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">.\/gradlew flywayInfo\r\n:flywayInfo\r\n\r\n+---------+-------------------+---------------------+---------+\r\n| Version | Description       | Installed on        | State   |\r\n+---------+-------------------+---------------------+---------+\r\n| 1       | create user table | 2017-05-23 22:13:10 | Success |\r\n| 2       | insert users      | 2017-05-23 22:13:10 | Success |\r\n+---------+-------------------+---------------------+---------+\r\n\r\n\r\nBUILD SUCCESSFUL\r\n\r\nTotal time: 1.406 secs<\/pre>\n<p><span style=\"font-weight: 400;\">Now that our database is in the correct state, we can bring the web application online. We need to make sure that we compile our application first.<\/span><\/p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">$ .\/gradlew clean build\r\n$ docker-compose up -d --build\r\n\r\nBuilding www\r\nStep 1 : FROM openjdk:8-jdk\r\n---&gt; 9766c638ae8e\r\nStep 2 : MAINTAINER &lt;n3integration@gmail.com&gt;\r\n---&gt; Using cache\r\n---&gt; e59cb5ec39c3\r\nStep 3 : EXPOSE 4567\r\n---&gt; Using cache\r\n---&gt; f693d4acfa5c\r\nStep 4 : COPY build\/libs\/*.jar \/app\/service.jar\r\n---&gt; Using cache\r\n---&gt; 84fb01a8fe02\r\nStep 5 : CMD java -jar \/app\/service.jar\r\n---&gt; Using cache\r\n---&gt; 563396222815\r\nSuccessfully built 563396222815\r\njava_db_1 is up-to-date\r\nCreating java_www_1<\/pre>\n<p><span style=\"font-weight: 400;\">With our database initialized and our web application online, we\u2019re now ready to complete our integration testing.<\/span><\/p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">$ .\/gradlew integrationTest\r\n\r\n:compileJava UP-TO-DATE\r\n\r\n:processResources UP-TO-DATE\r\n\r\n:classes UP-TO-DATE\r\n\r\n:compileTestJava NO-SOURCE\r\n\r\n:processTestResources NO-SOURCE\r\n\r\n:testClasses UP-TO-DATE\r\n\r\n:compileIntegrationTestJava UP-TO-DATE\r\n\r\n:processIntegrationTestResources NO-SOURCE\r\n\r\n:integrationTestClasses UP-TO-DATE\r\n\r\n:integrationTest\r\n\r\n\r\n\r\nBUILD SUCCESSFUL\r\n\r\n\r\n\r\nTotal time: 4.421 secs<\/pre>\n<p>&nbsp;<\/p>\n<p><span style=\"font-weight: 400;\">The test results are available in the <\/span><em><span style=\"font-weight: 400;\">build\/reports\/tests\/integrationTest\/index.html<\/span><\/em><span style=\"font-weight: 400;\"> file, once the test(s) have completed. Finally, to tear down the environment you can issue the following command.<\/span><\/p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">$ docker-compose down<\/pre>\n<p><span style=\"font-weight: 400;\">If incorporated into a continuous integration platform, such as <\/span><a href=\"https:\/\/codefresh.io\"><span style=\"font-weight: 400;\">Codefresh<\/span><\/a><span style=\"font-weight: 400;\">, each of the steps above can be broken out into a separate build step and triggered via a commit or pull request to ensure the highest integrity of the project.<\/span><\/p>\n<p>&nbsp;<\/p>\n<p><span style=\"font-weight: 400;\">With Codefresh, users can use our composition step to run unit\/integration tests, as well as spin-up pre-staging environments to preview features to share with your team (allowing you to implement feedback earlier, and eliminate bottlenecks at staging ). You can <a href=\"https:\/\/codefresh.io\/\">use Codefresh for free today<\/a>, and see for yourself how easy it is to create compositions with our UI!<\/span><\/p>\n<input class=\"fooboxshare_post_id\" type=\"hidden\" value=\"6765\"\/>","protected":false},"excerpt":{"rendered":"<p>Introduction If you aren\u2019t familiar with Compose, it is one of many components in the Docker Toolbox. It provides developers with the ability to launch multiple Docker containers using a single command-line tool. It especially comes in handy for rapid development iterations and continuous integration. Basically, compose provides a manifest for a deployment environment. If &hellip; <a href=\"https:\/\/codefresh.io\/docker-tutorial\/continuous-integration-docker-compose\/\">Read more<\/a><\/p>\n","protected":false},"author":27,"featured_media":3764,"comment_status":"closed","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[8],"tags":[],"yoast_head":"<!-- This site is optimized with the Yoast SEO Premium plugin v17.9 (Yoast SEO v18.4.1) - https:\/\/yoast.com\/wordpress\/plugins\/seo\/ -->\n<title>Continuous Integration with Docker Compose | Codefresh<\/title>\n<meta name=\"description\" content=\"This post will familiarize you with Docker Compose and how it can be leveraged in a continuous integration pipeline.\" \/>\n<meta name=\"robots\" content=\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\" \/>\n<link rel=\"canonical\" href=\"https:\/\/codefresh.io\/docker-tutorial\/continuous-integration-docker-compose\/\" \/>\n<meta property=\"og:locale\" content=\"en_US\" \/>\n<meta property=\"og:type\" content=\"article\" \/>\n<meta property=\"og:title\" content=\"Continuous Integration with Docker Compose\" \/>\n<meta property=\"og:description\" content=\"This post will familiarize you with Docker Compose and how it can be leveraged in a continuous integration pipeline.\" \/>\n<meta property=\"og:url\" content=\"https:\/\/codefresh.io\/docker-tutorial\/continuous-integration-docker-compose\/\" \/>\n<meta property=\"og:site_name\" content=\"Codefresh\" \/>\n<meta property=\"article:publisher\" content=\"https:\/\/www.facebook.com\/codefresh.io\" \/>\n<meta property=\"article:published_time\" content=\"2017-06-05T20:57:35+00:00\" \/>\n<meta property=\"article:modified_time\" content=\"2022-02-11T22:14:22+00:00\" \/>\n<meta property=\"og:image\" content=\"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/07\/docker-compose.png\" \/>\n\t<meta property=\"og:image:width\" content=\"1440\" \/>\n\t<meta property=\"og:image:height\" content=\"826\" \/>\n\t<meta property=\"og:image:type\" content=\"image\/png\" \/>\n<meta name=\"twitter:card\" content=\"summary_large_image\" \/>\n<meta name=\"twitter:creator\" content=\"@todaywasawesome\" \/>\n<meta name=\"twitter:site\" content=\"@codefresh\" \/>\n<meta name=\"twitter:label1\" content=\"Written by\" \/>\n\t<meta name=\"twitter:data1\" content=\"Dan Garfield\" \/>\n\t<meta name=\"twitter:label2\" content=\"Est. reading time\" \/>\n\t<meta name=\"twitter:data2\" content=\"5 minutes\" \/>\n<script type=\"application\/ld+json\" class=\"yoast-schema-graph\">{\"@context\":\"https:\/\/schema.org\",\"@graph\":[{\"@type\":\"Organization\",\"@id\":\"https:\/\/codefresh.io\/#organization\",\"name\":\"Codefresh\",\"url\":\"https:\/\/codefresh.io\/\",\"sameAs\":[\"https:\/\/www.facebook.com\/codefresh.io\",\"https:\/\/www.linkedin.com\/company\/codefresh\",\"https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg\",\"https:\/\/twitter.com\/codefresh\"],\"logo\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#logo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"width\":800,\"height\":800,\"caption\":\"Codefresh\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/#logo\"}},{\"@type\":\"WebSite\",\"@id\":\"https:\/\/codefresh.io\/#website\",\"url\":\"https:\/\/codefresh.io\/\",\"name\":\"Codefresh\",\"description\":\"\",\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"potentialAction\":[{\"@type\":\"SearchAction\",\"target\":{\"@type\":\"EntryPoint\",\"urlTemplate\":\"https:\/\/codefresh.io\/?s={search_term_string}\"},\"query-input\":\"required name=search_term_string\"}],\"inLanguage\":\"en-US\"},{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/continuous-integration-docker-compose\/#primaryimage\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/07\/docker-compose.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/07\/docker-compose.png\",\"width\":1440,\"height\":826},{\"@type\":\"WebPage\",\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/continuous-integration-docker-compose\/#webpage\",\"url\":\"https:\/\/codefresh.io\/docker-tutorial\/continuous-integration-docker-compose\/\",\"name\":\"Continuous Integration with Docker Compose | Codefresh\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/#website\"},\"primaryImageOfPage\":{\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/continuous-integration-docker-compose\/#primaryimage\"},\"datePublished\":\"2017-06-05T20:57:35+00:00\",\"dateModified\":\"2022-02-11T22:14:22+00:00\",\"description\":\"This post will familiarize you with Docker Compose and how it can be leveraged in a continuous integration pipeline.\",\"breadcrumb\":{\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/continuous-integration-docker-compose\/#breadcrumb\"},\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"ReadAction\",\"target\":[\"https:\/\/codefresh.io\/docker-tutorial\/continuous-integration-docker-compose\/\"]}]},{\"@type\":\"BreadcrumbList\",\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/continuous-integration-docker-compose\/#breadcrumb\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"name\":\"Home\",\"item\":\"https:\/\/codefresh.io\/\"},{\"@type\":\"ListItem\",\"position\":2,\"name\":\"Continuous Integration with Docker Compose\"}]},{\"@type\":\"Article\",\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/continuous-integration-docker-compose\/#article\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/continuous-integration-docker-compose\/#webpage\"},\"author\":{\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/17aca6389be0f81b999f1b138a0b44a4\"},\"headline\":\"Continuous Integration with Docker Compose\",\"datePublished\":\"2017-06-05T20:57:35+00:00\",\"dateModified\":\"2022-02-11T22:14:22+00:00\",\"mainEntityOfPage\":{\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/continuous-integration-docker-compose\/#webpage\"},\"wordCount\":740,\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/continuous-integration-docker-compose\/#primaryimage\"},\"thumbnailUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/07\/docker-compose.png\",\"articleSection\":[\"Docker Tutorials\"],\"inLanguage\":\"en-US\"},{\"@type\":\"Person\",\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/17aca6389be0f81b999f1b138a0b44a4\",\"name\":\"Dan Garfield\",\"image\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#personlogo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/secure.gravatar.com\/avatar\/d4a38809809980ed49dc7e696a8e3938?s=96&d=blank&r=g\",\"contentUrl\":\"https:\/\/secure.gravatar.com\/avatar\/d4a38809809980ed49dc7e696a8e3938?s=96&d=blank&r=g\",\"caption\":\"Dan Garfield\"},\"description\":\"Dan is the Co-Founder and Chief Open Source Officer at Codefresh. His work in open source includes being an Argo Maintainer, and co-chair of the GitOps Working Group. As a technology leader with a background in full-stack engineering, evangelism, and communications, he led Codefresh's go-to-market strategy and now leads open source strategy. You can follow him at twitter.com\/todaywasawesome\",\"sameAs\":[\"https:\/\/twitter.com\/todaywasawesome\"],\"url\":\"https:\/\/codefresh.io\/author\/dang\/\"}]}<\/script>\n<!-- \/ Yoast SEO Premium plugin. -->","yoast_head_json":{"title":"Continuous Integration with Docker Compose | Codefresh","description":"This post will familiarize you with Docker Compose and how it can be leveraged in a continuous integration pipeline.","robots":{"index":"index","follow":"follow","max-snippet":"max-snippet:-1","max-image-preview":"max-image-preview:large","max-video-preview":"max-video-preview:-1"},"canonical":"https:\/\/codefresh.io\/docker-tutorial\/continuous-integration-docker-compose\/","og_locale":"en_US","og_type":"article","og_title":"Continuous Integration with Docker Compose","og_description":"This post will familiarize you with Docker Compose and how it can be leveraged in a continuous integration pipeline.","og_url":"https:\/\/codefresh.io\/docker-tutorial\/continuous-integration-docker-compose\/","og_site_name":"Codefresh","article_publisher":"https:\/\/www.facebook.com\/codefresh.io","article_published_time":"2017-06-05T20:57:35+00:00","article_modified_time":"2022-02-11T22:14:22+00:00","og_image":[{"width":1440,"height":826,"url":"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/07\/docker-compose.png","type":"image\/png"}],"twitter_card":"summary_large_image","twitter_creator":"@todaywasawesome","twitter_site":"@codefresh","twitter_misc":{"Written by":"Dan Garfield","Est. reading time":"5 minutes"},"schema":{"@context":"https:\/\/schema.org","@graph":[{"@type":"Organization","@id":"https:\/\/codefresh.io\/#organization","name":"Codefresh","url":"https:\/\/codefresh.io\/","sameAs":["https:\/\/www.facebook.com\/codefresh.io","https:\/\/www.linkedin.com\/company\/codefresh","https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg","https:\/\/twitter.com\/codefresh"],"logo":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#logo","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","width":800,"height":800,"caption":"Codefresh"},"image":{"@id":"https:\/\/codefresh.io\/#logo"}},{"@type":"WebSite","@id":"https:\/\/codefresh.io\/#website","url":"https:\/\/codefresh.io\/","name":"Codefresh","description":"","publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"potentialAction":[{"@type":"SearchAction","target":{"@type":"EntryPoint","urlTemplate":"https:\/\/codefresh.io\/?s={search_term_string}"},"query-input":"required name=search_term_string"}],"inLanguage":"en-US"},{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/docker-tutorial\/continuous-integration-docker-compose\/#primaryimage","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/07\/docker-compose.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/07\/docker-compose.png","width":1440,"height":826},{"@type":"WebPage","@id":"https:\/\/codefresh.io\/docker-tutorial\/continuous-integration-docker-compose\/#webpage","url":"https:\/\/codefresh.io\/docker-tutorial\/continuous-integration-docker-compose\/","name":"Continuous Integration with Docker Compose | Codefresh","isPartOf":{"@id":"https:\/\/codefresh.io\/#website"},"primaryImageOfPage":{"@id":"https:\/\/codefresh.io\/docker-tutorial\/continuous-integration-docker-compose\/#primaryimage"},"datePublished":"2017-06-05T20:57:35+00:00","dateModified":"2022-02-11T22:14:22+00:00","description":"This post will familiarize you with Docker Compose and how it can be leveraged in a continuous integration pipeline.","breadcrumb":{"@id":"https:\/\/codefresh.io\/docker-tutorial\/continuous-integration-docker-compose\/#breadcrumb"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https:\/\/codefresh.io\/docker-tutorial\/continuous-integration-docker-compose\/"]}]},{"@type":"BreadcrumbList","@id":"https:\/\/codefresh.io\/docker-tutorial\/continuous-integration-docker-compose\/#breadcrumb","itemListElement":[{"@type":"ListItem","position":1,"name":"Home","item":"https:\/\/codefresh.io\/"},{"@type":"ListItem","position":2,"name":"Continuous Integration with Docker Compose"}]},{"@type":"Article","@id":"https:\/\/codefresh.io\/docker-tutorial\/continuous-integration-docker-compose\/#article","isPartOf":{"@id":"https:\/\/codefresh.io\/docker-tutorial\/continuous-integration-docker-compose\/#webpage"},"author":{"@id":"https:\/\/codefresh.io\/#\/schema\/person\/17aca6389be0f81b999f1b138a0b44a4"},"headline":"Continuous Integration with Docker Compose","datePublished":"2017-06-05T20:57:35+00:00","dateModified":"2022-02-11T22:14:22+00:00","mainEntityOfPage":{"@id":"https:\/\/codefresh.io\/docker-tutorial\/continuous-integration-docker-compose\/#webpage"},"wordCount":740,"publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"image":{"@id":"https:\/\/codefresh.io\/docker-tutorial\/continuous-integration-docker-compose\/#primaryimage"},"thumbnailUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/07\/docker-compose.png","articleSection":["Docker Tutorials"],"inLanguage":"en-US"},{"@type":"Person","@id":"https:\/\/codefresh.io\/#\/schema\/person\/17aca6389be0f81b999f1b138a0b44a4","name":"Dan Garfield","image":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#personlogo","inLanguage":"en-US","url":"https:\/\/secure.gravatar.com\/avatar\/d4a38809809980ed49dc7e696a8e3938?s=96&d=blank&r=g","contentUrl":"https:\/\/secure.gravatar.com\/avatar\/d4a38809809980ed49dc7e696a8e3938?s=96&d=blank&r=g","caption":"Dan Garfield"},"description":"Dan is the Co-Founder and Chief Open Source Officer at Codefresh. His work in open source includes being an Argo Maintainer, and co-chair of the GitOps Working Group. As a technology leader with a background in full-stack engineering, evangelism, and communications, he led Codefresh's go-to-market strategy and now leads open source strategy. You can follow him at twitter.com\/todaywasawesome","sameAs":["https:\/\/twitter.com\/todaywasawesome"],"url":"https:\/\/codefresh.io\/author\/dang\/"}]}},"acf":[],"_links":{"self":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/6765"}],"collection":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/users\/27"}],"replies":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/comments?post=6765"}],"version-history":[{"count":2,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/6765\/revisions"}],"predecessor-version":[{"id":21496,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/6765\/revisions\/21496"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media\/3764"}],"wp:attachment":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media?parent=6765"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/categories?post=6765"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/tags?post=6765"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}