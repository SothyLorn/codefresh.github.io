{"id":6803,"date":"2017-06-06T18:06:40","date_gmt":"2017-06-06T18:06:40","guid":{"rendered":"https:\/\/codefresh.io\/docker-guides\/docker-chaos-testing-2\/"},"modified":"2022-02-10T22:13:49","modified_gmt":"2022-02-10T22:13:49","slug":"docker-chaos-testing","status":"publish","type":"post","link":"https:\/\/codefresh.io\/docker-tutorial\/docker-chaos-testing\/","title":{"rendered":"Docker Chaos Testing"},"content":{"rendered":"<p><span style=\"font-weight: 400;\">Okay so you\u2019ve successfully deployed your new or legacy application to a Docker container. You have also wired up dependencies and are ready for deployment to an integration environment, so now what? Building through continuous integration for your application is a great idea to ensure the success of a project, but how does your application deal with failure? If chaos engineering is an unfamiliar concept, be sure to read up on the <\/span><a href=\"http:\/\/principlesofchaos.org\/\" target=\"_blank\" rel=\"noopener noreferrer\"><span style=\"font-weight: 400;\">Principles of Chaos Engineering<\/span><\/a><span style=\"font-weight: 400;\">. The idea is to ensure that weaknesses within a distributed system are uncovered and that the system behaves predictably in a controlled environment.<\/span><\/p>\n<p>&nbsp;<\/p>\n<p><span style=\"font-weight: 400;\">There are a few tools available specifically for Chaos Testing including <\/span><a href=\"https:\/\/github.com\/netflix\/chaosmonkey\" target=\"_blank\" rel=\"noopener noreferrer\"><span style=\"font-weight: 400;\">Chaos Monkey<\/span><\/a><span style=\"font-weight: 400;\">, <\/span><a href=\"https:\/\/github.com\/gaia-adm\/pumba\" target=\"_blank\" rel=\"noopener noreferrer\"><span style=\"font-weight: 400;\">Pumba<\/span><\/a><span style=\"font-weight: 400;\">, and <\/span><a href=\"https:\/\/github.com\/toddlipcon\/gremlins\" target=\"_blank\" rel=\"noopener noreferrer\"><span style=\"font-weight: 400;\">Gremlins<\/span><\/a><span style=\"font-weight: 400;\">. Due to the project\u2019s focus on containers, this post discusses Pumba for Chaos Testing. In their own words, \u201cPumba is a resilience testing tool, that helps applications tolerate random Docker container failures: process, network and performance.\u201d <\/span><\/p>\n<h3><b>Getting Started<\/b><\/h3>\n<p><span style=\"font-weight: 400;\">To follow along, you can clone the associated git repository and initialize the project containers. It is important that you ensure that the application is functioning properly prior to executing any chaos testing.<\/span><\/p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">$ git clone https:\/\/github.com\/n3integration\/dockerize-java.git\n$ cd dockerize-java &amp;&amp; git co chaos\n$ .\/gradlew clean build\n$ docker-compose up -d db\n$ .\/gradlew flywayMigrate\n$ docker-compose up -d www<\/pre>\n<h2><b>Traffic Generation<\/b><\/h2>\n<p><span style=\"font-weight: 400;\">We\u2019ll also need a tool to generate a constant amount of traffic. For this purpose, although it may be overkill, we\u2019ll use <\/span><a href=\"https:\/\/github.com\/tsenart\/vegeta\"><span style=\"font-weight: 400;\">Vegeta<\/span><\/a><span style=\"font-weight: 400;\">. I\u2019ve provided a Vegeta Docker image which supports two environment variables <\/span><span style=\"font-weight: 400;\">DURATION<\/span><span style=\"font-weight: 400;\"> and <\/span><span style=\"font-weight: 400;\">TARGET<\/span><span style=\"font-weight: 400;\">. <\/span><span style=\"font-weight: 400;\">DURATION<\/span><span style=\"font-weight: 400;\"> is the amount of time for the traffic generation to run, which can be measured in seconds or minutes (eg. 1s, 1m). <\/span><span style=\"font-weight: 400;\">TARGET<\/span><span style=\"font-weight: 400;\"> is the URL of the web service under test. To begin generating traffic to the web service, you can run the following command.<\/span><\/p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">$ docker-compose up -d generator<\/pre>\n<h2><b>Chaos Testing with Pumba<\/b><\/h2>\n<p><span style=\"font-weight: 400;\">Pumba provides five commands that are used to simulate error conditions within a controlled environment. <\/span><\/p>\n<h4><span style=\"font-weight: 400;\"><code>kill<\/code><\/span><\/h4>\n<p><span style=\"font-weight: 400;\">The <\/span><span style=\"font-weight: 400;\"><code>kill<\/code><\/span><span style=\"font-weight: 400;\"> command can be used to simulate containers being randomly terminated. The command allows users to provide a custom signal. If left unspecified, <\/span><span style=\"font-weight: 400;\">SIGKILL<\/span><span style=\"font-weight: 400;\"> is sent to the container process.<\/span><\/p>\n<h4><span style=\"font-weight: 400;\"><code>netem<\/code><\/span><\/h4>\n<p><span style=\"font-weight: 400;\">The <\/span><span style=\"font-weight: 400;\"><code>netem<\/code><\/span><span style=\"font-weight: 400;\"> command is one of the more advanced testing capabilities provided by Pumba used to emulate misbehaving networks. This command provides several capabilities, which include rate limiting, delaying, reordering, duplicating, and losing packets. This is considerably important due to the variability of networks.<\/span><\/p>\n<h4><span style=\"font-weight: 400;\"><code>pause<\/code><\/span><\/h4>\n<p><span style=\"font-weight: 400;\">The <\/span><span style=\"font-weight: 400;\"><code>pause<\/code><\/span><span style=\"font-weight: 400;\"> command pauses running containers whose name matches the supplied expression. Unless you are running within an orchestration framework, such as <\/span><a href=\"https:\/\/kubernetes.io\/\" target=\"_blank\" rel=\"noopener noreferrer\"><span style=\"font-weight: 400;\">Kubernetes<\/span><\/a><span style=\"font-weight: 400;\"> or <\/span><a href=\"https:\/\/aws.amazon.com\/ecs\/\" target=\"_blank\" rel=\"noopener noreferrer\"><span style=\"font-weight: 400;\">Amazon\u2019s Container Service<\/span><\/a><span style=\"font-weight: 400;\">, this command is especially helpful. It works by periodically pausing\/resuming one or more containers for a user specified duration.<\/span><\/p>\n<h4><span style=\"font-weight: 400;\"><code>stop<\/code><\/span><\/h4>\n<p><span style=\"font-weight: 400;\">The <\/span><span style=\"font-weight: 400;\"><code>stop<\/code><\/span><span style=\"font-weight: 400;\"> command stops running containers whose name matches the supplied expression. First, Pumba will attempt to gracefully terminate the process running within the target container(s). If unable to stop the process, the process is terminated with a <\/span><span style=\"font-weight: 400;\">SIGKILL<\/span><span style=\"font-weight: 400;\"> signal.<\/span><\/p>\n<h4><span style=\"font-weight: 400;\"><code>rm<\/code><\/span><\/h4>\n<p><span style=\"font-weight: 400;\">The <\/span><span style=\"font-weight: 400;\"><code>rm<\/code><\/span><span style=\"font-weight: 400;\"> command removes running containers and attached volumes. This command is especially destructive since by default it will also remove any underlying volumes attached to the target container(s).<\/span><\/p>\n<p><span style=\"font-weight: 400;\">For more information about Pumba and its capabilities, refer to the project\u2019s <\/span><a href=\"https:\/\/github.com\/gaia-adm\/pumba\" target=\"_blank\" rel=\"noopener noreferrer\"><span style=\"font-weight: 400;\">source repository<\/span><\/a><span style=\"font-weight: 400;\">.<\/span><\/p>\n<h3><b>Putting it All Together<\/b><\/h3>\n<p><span style=\"font-weight: 400;\">To run through a set of tests, you will need at least two separate terminal windows open. In one terminal, run the Chaos Test. Since all tests are being executed without an orchestration framework, we want to run Pumba\u2019s <\/span><span style=\"font-weight: 400;\">pause<\/span><span style=\"font-weight: 400;\"> command.<\/span><\/p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">$ docker-compose up chaos-pause<\/pre>\n<p>In another window, begin the traffic generator.<\/p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">$ docker-compose up generator<\/pre>\n<p><span style=\"font-weight: 400;\">You should see output similar to the following once the test has completed.<\/span><\/p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">generator_1 | Requests     [total, rate]           3000, 50.02\n\ngenerator_1 | Duration     [total, attack, wait]   1m25.386995253s, 59.979999887s, 25.406995366s\n\ngenerator_1 | Latencies    [mean, 50, 95, 99, max] 2.990878328s, 1.025975081s, 10.16703107s, 14.752185309s, 30.01735129s\n\ngenerator_1 | Bytes In     [total, mean]           103777, 34.59\n\ngenerator_1 | Bytes Out    [total, mean]           0, 0.00\n\ngenerator_1 | Success      [ratio]                 61.43%\n\ngenerator_1 | Status Codes [code:count]            500:1146 0:11 200:1843\n\ngenerator_1 | Error Set:\n\ngenerator_1 | 500 Server Error<\/pre>\n<p><span style=\"font-weight: 400;\">As you can see, Pumba was able to interfere with the test results. You can also see that the service is returning a 500 error when it is unable to connect to the Postgres database, which is less than ideal. Although a simplistic case, we could add caching to our service to prevent any errors from occurring and end up with a much higher success rate. Let\u2019s see how Pumba\u2019s network emulation commands can vary test results. In one window run an instance of the <\/span><span style=\"font-weight: 400;\">chaos-loss<\/span><span style=\"font-weight: 400;\"> container.<\/span><\/p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">$ docker-compose up chaos-loss<\/pre>\n<p><span style=\"font-weight: 400;\">Again, in another window, let\u2019s run the traffic generator.<\/span><\/p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">$ docker-compose up generator<\/pre>\n<p><span style=\"font-weight: 400;\">Again, you should see results similar to the following, when completed.<\/span><\/p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\">generator_1 | Requests     [total, rate]           3000, 50.02\n\ngenerator_1 | Duration     [total, attack, wait]   1m1.017726406s, 59.979999917s, 1.037726489s\n\ngenerator_1 | Latencies    [mean, 50, 95, 99, max] 557.375498ms, 19.780692ms, 3.008849215s, 6.938442708s, 26.792086014s\n\ngenerator_1 | Bytes In     [total, mean]           114851, 38.28\n\ngenerator_1 | Bytes Out    [total, mean]           0, 0.00\n\ngenerator_1 | Success      [ratio]                 52.97%\n\ngenerator_1 | Status Codes [code:count]            200:1589  500:1411\n\ngenerator_1 | Error Set:\n\ngenerator_1 | 500 Server Error<\/pre>\n<p><span style=\"font-weight: 400;\">Hopefully, you\u2019ve gained an appreciation for Chaos Engineering and have a better understanding of how it can help to improve the resiliency of your production applications. I encourage you to learn more about the capabilities of both Vegeta and Pumba.<\/span><\/p>\n<input class=\"fooboxshare_post_id\" type=\"hidden\" value=\"6803\"\/>","protected":false},"excerpt":{"rendered":"<p>Okay so you\u2019ve successfully deployed your new or legacy application to a Docker container. You have also wired up dependencies and are ready for deployment to an integration environment, so now what? Building through continuous integration for your application is a great idea to ensure the success of a project, but how does your application &hellip; <a href=\"https:\/\/codefresh.io\/docker-tutorial\/docker-chaos-testing\/\">Read more<\/a><\/p>\n","protected":false},"author":27,"featured_media":0,"comment_status":"closed","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[8],"tags":[114],"yoast_head":"<!-- This site is optimized with the Yoast SEO Premium plugin v17.9 (Yoast SEO v18.4.1) - https:\/\/yoast.com\/wordpress\/plugins\/seo\/ -->\n<title>Docker Chaos Testing | Codefresh<\/title>\n<meta name=\"description\" content=\"Building through CI for your application is a great idea to ensure the success of a project, but how does your application deal with failure?\" \/>\n<meta name=\"robots\" content=\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\" \/>\n<link rel=\"canonical\" href=\"https:\/\/codefresh.io\/docker-tutorial\/docker-chaos-testing\/\" \/>\n<meta property=\"og:locale\" content=\"en_US\" \/>\n<meta property=\"og:type\" content=\"article\" \/>\n<meta property=\"og:title\" content=\"Docker Chaos Testing\" \/>\n<meta property=\"og:description\" content=\"Building through CI for your application is a great idea to ensure the success of a project, but how does your application deal with failure?\" \/>\n<meta property=\"og:url\" content=\"https:\/\/codefresh.io\/docker-tutorial\/docker-chaos-testing\/\" \/>\n<meta property=\"og:site_name\" content=\"Codefresh\" \/>\n<meta property=\"article:publisher\" content=\"https:\/\/www.facebook.com\/codefresh.io\" \/>\n<meta property=\"article:published_time\" content=\"2017-06-06T18:06:40+00:00\" \/>\n<meta property=\"article:modified_time\" content=\"2022-02-10T22:13:49+00:00\" \/>\n<meta name=\"twitter:card\" content=\"summary_large_image\" \/>\n<meta name=\"twitter:creator\" content=\"@todaywasawesome\" \/>\n<meta name=\"twitter:site\" content=\"@codefresh\" \/>\n<meta name=\"twitter:label1\" content=\"Written by\" \/>\n\t<meta name=\"twitter:data1\" content=\"Dan Garfield\" \/>\n\t<meta name=\"twitter:label2\" content=\"Est. reading time\" \/>\n\t<meta name=\"twitter:data2\" content=\"4 minutes\" \/>\n<script type=\"application\/ld+json\" class=\"yoast-schema-graph\">{\"@context\":\"https:\/\/schema.org\",\"@graph\":[{\"@type\":\"Organization\",\"@id\":\"https:\/\/codefresh.io\/#organization\",\"name\":\"Codefresh\",\"url\":\"https:\/\/codefresh.io\/\",\"sameAs\":[\"https:\/\/www.facebook.com\/codefresh.io\",\"https:\/\/www.linkedin.com\/company\/codefresh\",\"https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg\",\"https:\/\/twitter.com\/codefresh\"],\"logo\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#logo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"width\":800,\"height\":800,\"caption\":\"Codefresh\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/#logo\"}},{\"@type\":\"WebSite\",\"@id\":\"https:\/\/codefresh.io\/#website\",\"url\":\"https:\/\/codefresh.io\/\",\"name\":\"Codefresh\",\"description\":\"\",\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"potentialAction\":[{\"@type\":\"SearchAction\",\"target\":{\"@type\":\"EntryPoint\",\"urlTemplate\":\"https:\/\/codefresh.io\/?s={search_term_string}\"},\"query-input\":\"required name=search_term_string\"}],\"inLanguage\":\"en-US\"},{\"@type\":\"WebPage\",\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/docker-chaos-testing\/#webpage\",\"url\":\"https:\/\/codefresh.io\/docker-tutorial\/docker-chaos-testing\/\",\"name\":\"Docker Chaos Testing | Codefresh\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/#website\"},\"datePublished\":\"2017-06-06T18:06:40+00:00\",\"dateModified\":\"2022-02-10T22:13:49+00:00\",\"description\":\"Building through CI for your application is a great idea to ensure the success of a project, but how does your application deal with failure?\",\"breadcrumb\":{\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/docker-chaos-testing\/#breadcrumb\"},\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"ReadAction\",\"target\":[\"https:\/\/codefresh.io\/docker-tutorial\/docker-chaos-testing\/\"]}]},{\"@type\":\"BreadcrumbList\",\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/docker-chaos-testing\/#breadcrumb\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"name\":\"Home\",\"item\":\"https:\/\/codefresh.io\/\"},{\"@type\":\"ListItem\",\"position\":2,\"name\":\"Docker Chaos Testing\"}]},{\"@type\":\"Article\",\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/docker-chaos-testing\/#article\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/docker-chaos-testing\/#webpage\"},\"author\":{\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/17aca6389be0f81b999f1b138a0b44a4\"},\"headline\":\"Docker Chaos Testing\",\"datePublished\":\"2017-06-06T18:06:40+00:00\",\"dateModified\":\"2022-02-10T22:13:49+00:00\",\"mainEntityOfPage\":{\"@id\":\"https:\/\/codefresh.io\/docker-tutorial\/docker-chaos-testing\/#webpage\"},\"wordCount\":720,\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"keywords\":[\"Chaos Testing\"],\"articleSection\":[\"Docker Tutorials\"],\"inLanguage\":\"en-US\"},{\"@type\":\"Person\",\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/17aca6389be0f81b999f1b138a0b44a4\",\"name\":\"Dan Garfield\",\"image\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#personlogo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/secure.gravatar.com\/avatar\/d4a38809809980ed49dc7e696a8e3938?s=96&d=blank&r=g\",\"contentUrl\":\"https:\/\/secure.gravatar.com\/avatar\/d4a38809809980ed49dc7e696a8e3938?s=96&d=blank&r=g\",\"caption\":\"Dan Garfield\"},\"description\":\"Dan is the Co-Founder and Chief Open Source Officer at Codefresh. His work in open source includes being an Argo Maintainer, and co-chair of the GitOps Working Group. As a technology leader with a background in full-stack engineering, evangelism, and communications, he led Codefresh's go-to-market strategy and now leads open source strategy. You can follow him at twitter.com\/todaywasawesome\",\"sameAs\":[\"https:\/\/twitter.com\/todaywasawesome\"],\"url\":\"https:\/\/codefresh.io\/author\/dang\/\"}]}<\/script>\n<!-- \/ Yoast SEO Premium plugin. -->","yoast_head_json":{"title":"Docker Chaos Testing | Codefresh","description":"Building through CI for your application is a great idea to ensure the success of a project, but how does your application deal with failure?","robots":{"index":"index","follow":"follow","max-snippet":"max-snippet:-1","max-image-preview":"max-image-preview:large","max-video-preview":"max-video-preview:-1"},"canonical":"https:\/\/codefresh.io\/docker-tutorial\/docker-chaos-testing\/","og_locale":"en_US","og_type":"article","og_title":"Docker Chaos Testing","og_description":"Building through CI for your application is a great idea to ensure the success of a project, but how does your application deal with failure?","og_url":"https:\/\/codefresh.io\/docker-tutorial\/docker-chaos-testing\/","og_site_name":"Codefresh","article_publisher":"https:\/\/www.facebook.com\/codefresh.io","article_published_time":"2017-06-06T18:06:40+00:00","article_modified_time":"2022-02-10T22:13:49+00:00","twitter_card":"summary_large_image","twitter_creator":"@todaywasawesome","twitter_site":"@codefresh","twitter_misc":{"Written by":"Dan Garfield","Est. reading time":"4 minutes"},"schema":{"@context":"https:\/\/schema.org","@graph":[{"@type":"Organization","@id":"https:\/\/codefresh.io\/#organization","name":"Codefresh","url":"https:\/\/codefresh.io\/","sameAs":["https:\/\/www.facebook.com\/codefresh.io","https:\/\/www.linkedin.com\/company\/codefresh","https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg","https:\/\/twitter.com\/codefresh"],"logo":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#logo","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","width":800,"height":800,"caption":"Codefresh"},"image":{"@id":"https:\/\/codefresh.io\/#logo"}},{"@type":"WebSite","@id":"https:\/\/codefresh.io\/#website","url":"https:\/\/codefresh.io\/","name":"Codefresh","description":"","publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"potentialAction":[{"@type":"SearchAction","target":{"@type":"EntryPoint","urlTemplate":"https:\/\/codefresh.io\/?s={search_term_string}"},"query-input":"required name=search_term_string"}],"inLanguage":"en-US"},{"@type":"WebPage","@id":"https:\/\/codefresh.io\/docker-tutorial\/docker-chaos-testing\/#webpage","url":"https:\/\/codefresh.io\/docker-tutorial\/docker-chaos-testing\/","name":"Docker Chaos Testing | Codefresh","isPartOf":{"@id":"https:\/\/codefresh.io\/#website"},"datePublished":"2017-06-06T18:06:40+00:00","dateModified":"2022-02-10T22:13:49+00:00","description":"Building through CI for your application is a great idea to ensure the success of a project, but how does your application deal with failure?","breadcrumb":{"@id":"https:\/\/codefresh.io\/docker-tutorial\/docker-chaos-testing\/#breadcrumb"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https:\/\/codefresh.io\/docker-tutorial\/docker-chaos-testing\/"]}]},{"@type":"BreadcrumbList","@id":"https:\/\/codefresh.io\/docker-tutorial\/docker-chaos-testing\/#breadcrumb","itemListElement":[{"@type":"ListItem","position":1,"name":"Home","item":"https:\/\/codefresh.io\/"},{"@type":"ListItem","position":2,"name":"Docker Chaos Testing"}]},{"@type":"Article","@id":"https:\/\/codefresh.io\/docker-tutorial\/docker-chaos-testing\/#article","isPartOf":{"@id":"https:\/\/codefresh.io\/docker-tutorial\/docker-chaos-testing\/#webpage"},"author":{"@id":"https:\/\/codefresh.io\/#\/schema\/person\/17aca6389be0f81b999f1b138a0b44a4"},"headline":"Docker Chaos Testing","datePublished":"2017-06-06T18:06:40+00:00","dateModified":"2022-02-10T22:13:49+00:00","mainEntityOfPage":{"@id":"https:\/\/codefresh.io\/docker-tutorial\/docker-chaos-testing\/#webpage"},"wordCount":720,"publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"keywords":["Chaos Testing"],"articleSection":["Docker Tutorials"],"inLanguage":"en-US"},{"@type":"Person","@id":"https:\/\/codefresh.io\/#\/schema\/person\/17aca6389be0f81b999f1b138a0b44a4","name":"Dan Garfield","image":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#personlogo","inLanguage":"en-US","url":"https:\/\/secure.gravatar.com\/avatar\/d4a38809809980ed49dc7e696a8e3938?s=96&d=blank&r=g","contentUrl":"https:\/\/secure.gravatar.com\/avatar\/d4a38809809980ed49dc7e696a8e3938?s=96&d=blank&r=g","caption":"Dan Garfield"},"description":"Dan is the Co-Founder and Chief Open Source Officer at Codefresh. His work in open source includes being an Argo Maintainer, and co-chair of the GitOps Working Group. As a technology leader with a background in full-stack engineering, evangelism, and communications, he led Codefresh's go-to-market strategy and now leads open source strategy. You can follow him at twitter.com\/todaywasawesome","sameAs":["https:\/\/twitter.com\/todaywasawesome"],"url":"https:\/\/codefresh.io\/author\/dang\/"}]}},"acf":[],"_links":{"self":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/6803"}],"collection":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/users\/27"}],"replies":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/comments?post=6803"}],"version-history":[{"count":2,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/6803\/revisions"}],"predecessor-version":[{"id":21443,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/6803\/revisions\/21443"}],"wp:attachment":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media?parent=6803"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/categories?post=6803"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/tags?post=6803"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}