{"id":6882,"date":"2017-12-29T19:29:03","date_gmt":"2017-12-29T19:29:03","guid":{"rendered":"https:\/\/codefresh.io\/kubernetes-guides\/continuous-deployment-strategies-kubernetes-2\/"},"modified":"2022-03-01T17:39:58","modified_gmt":"2022-03-01T17:39:58","slug":"continuous-deployment-strategies-kubernetes-2","status":"publish","type":"post","link":"https:\/\/codefresh.io\/kubernetes-tutorial\/continuous-deployment-strategies-kubernetes-2\/","title":{"rendered":"Continuous Deployment Strategies with Kubernetes"},"content":{"rendered":"<p>Kubernetes provides a sophisticated platform for making cloud deployments easy. Low-stress deployments are the cornerstone of Continuous Delivery practices. Being able to reliably and safely deploy, rollback and orchestrate software releases allows engineering teams to iterate quickly, experiment and keep the customers happy. All at the same time.<\/p>\n<p>There is a number of industry-standard deployment strategies that make continuous delivery of service-oriented software systems possible. In this series of posts, we will describe a number of existing techniques and strategies and discuss their pros, cons and caveats. For each strategy, we will also provide an example that can be implemented and verified using Codefresh Kubernetes integration features.<\/p>\n<h2>List of strategies:<\/h2>\n<ul>\n<li>Recreate<\/li>\n<li>Ramped Deployments<\/li>\n<li>Blue\/Green Deployments<\/li>\n<li>Canary Releases<\/li>\n<li>A\/B Testing<\/li>\n<\/ul>\n<h2>Setting the Terms Straight<\/h2>\n<p>Before we begin it\u2019s important to agree on the terminology.<\/p>\n<p>Kubernetes has a controller object called Deployment. The purpose of this controller is to provide declarative desired state management for underlying Pods and Replica Sets.<\/p>\n<p>Basically a Deployment defines:<\/p>\n<ul>\n<li>The Pod to execute (i.e containers, ports, \u00a0and system resources)<\/li>\n<li>The number of instances the Pod should have<\/li>\n<li>All the metadata related to underlying objects<\/li>\n<\/ul>\n<p>The Deployment object has a property named \u2018Strategy\u2019 which can be of 2 types: either \u2018Recreate\u2019 or \u2018Rolling Update\u2019.<\/p>\n<p>It is important to \u00a0note that in this post series, when we say deployment strategy we are not referencing the mentioned K8S object property. While we will be showcasing the usage of these K8S technical concepts, what we actually intend to do is describe the general continuous application deployment strategies and how they can be implemented on top of the Kubernetes platform.<\/p>\n<p>With that off our table &#8211; let\u2019s begin looking at the strategies.<\/p>\n<h2>Recreate<\/h2>\n<p><img class=\"aligncenter size-full wp-image-5728\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/Recreate.png\" alt=\"\" width=\"614\" height=\"485\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/Recreate.png 614w, https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/Recreate-300x237.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/Recreate-415x328.png 415w\" sizes=\"(max-width: 614px) 100vw, 614px\" \/><\/p>\n<p>To be fair &#8211; this is not a true continuous deployment strategy. It\u2019s more like the old-fashioned installation\/upgrade process. You stop all the running application instances and then spin up the instances with the new version.<\/p>\n<p>(In Kubernetes this is implemented by deployment.spec.strategy.type of the same name &#8211; Recreate whereas all existing Pods are killed before new ones are created.)<\/p>\n<h3>The downside:<\/h3>\n<ul>\n<li>This deployment approach involves downtime that occurs, while the old versions are getting brought down and the new versions are starting up.<\/li>\n<\/ul>\n<h3>The upside:<\/h3>\n<ul>\n<li>The upside of this approach is its cleanliness and conceptual simplicity. At no time do we have to manage more than one application version in parallel. No API versioning issues, no data scheme incompatibilities to think about.<\/li>\n<\/ul>\n<h3>Applicability<\/h3>\n<p>This strategy is mostly appropriate for non-critical systems where downtime is acceptable and comes at no significant cost. One case of such a system could be our development environment. It\u2019s important to remember though that if we architect our services for continuous deployment, we should be testing their upgrade and failover behaviours as early as possible. Which means that we better use the same rollout procedure for all environment maturity levels.<\/p>\n<h2>Ramped Deployment<\/h2>\n<p><img class=\"aligncenter size-full wp-image-5730\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/RampedDep1.png\" alt=\"\" width=\"617\" height=\"480\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/RampedDep1.png 617w, https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/RampedDep1-300x233.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/RampedDep1-422x328.png 422w\" sizes=\"(max-width: 617px) 100vw, 617px\" \/><\/p>\n<p>This is basically another term for rolling update. An important thing to note is that this is only applicable when your service is horizontally scaled &#8211; i.e running in more than one instance. If this is the case \u00a0&#8211; then instances running the old version get retired as new instances with the new version get spun up.<\/p>\n<p>This should of course be accompanied by at least some kind of a basic health check in order to verify that the new instances are ready to provide services. In Kubernetes these health checks can be defined as a readinessProbe.<\/p>\n<p>Once an instance is considered ready to serve &#8211; traffic gets sent to it.<\/p>\n<p>If new instances aren\u2019t found healthy &#8211; this strategy provides a smooth rollback procedure: new instances get killed off and old version instances get scaled back to their original capacity.<\/p>\n<p>Note that during the rollout process the old and the new version of our code run side by side. This requires full backward compatibility of our API and schema changes or careful API versioning whenever backward compatibility gets broken.<\/p>\n<h3>The downside:<\/h3>\n<ul>\n<li>Version simultaneousness concerns: Backward compatibility and API versioning aren\u2019t easy to implement and require careful testing.<\/li>\n<li>System comprehensibility: Issues arising during the transition process will be significantly harder to debug and recreate.<\/li>\n<li>Resource cost: If we don\u2019t want any impact on the quality of service we\u2019ll need to bring up the new instances while the old ones are still running. This means that there will be a resource usage peak during the rollout process. Dealing with such peaks has become much easier in the age of cloud infrastructure, but still \u00a0&#8211; resources don\u2019t come for free.<\/li>\n<\/ul>\n<h3>The upside:<\/h3>\n<ul>\n<li>Slow and smooth application code rollout across all servers with integrated health checks and no downtime involved.<\/li>\n<li>Availability of in-place rollback in case the deployment is unsuccessful.<\/li>\n<\/ul>\n<h3>Applicability<\/h3>\n<p>As already stated &#8211; ramped deployments only make sense when the deployed application is horizontally scaled.<\/p>\n<p>Additionally, ramped deployments are great when the new versions are backward compatible &#8211; both API and data-wise. And when your system is truly service oriented &#8211; with clear context boundaries, API versioning and eventual consistency support built-in.<\/p>\n<h2>Blue\/Green (aka Red\/Black) Deployment<\/h2>\n<p>In this approach we always manage 2 versions of our production environment. One of them is considered \u2018blue\u2019 &#8211; i.e this is the version that is now live. The new versions are always deployed to the \u2018green\u2019 replica of the environment. After we run the necessary tests and verifications to make sure the \u2018blue\u2019 environment is ready we just flip over the traffic, so \u2018green\u2019 becomes \u2018blue\u2019 and \u2018blue\u2019 becomes \u2018green\u2019.<\/p>\n<p><img class=\"aligncenter size-full wp-image-5731\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/BlueGreen1.png\" alt=\"\" width=\"614\" height=\"480\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/BlueGreen1.png 614w, https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/BlueGreen1-300x235.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/BlueGreen1-420x328.png 420w\" sizes=\"(max-width: 614px) 100vw, 614px\" \/><\/p>\n<p>Note that this strategy introduces a new concern we didn\u2019t discuss before \u00a0&#8211; managing multiple deployment environments. While a standard practice in CI\/CD &#8211; this adds another level of complexity to our deployment pipeline.<\/p>\n<h3>The downside:<\/h3>\n<ul>\n<li>Resource duplication \u00a0&#8211; In this model we\u2019re maintaining at least two full versions of our environment at all times.<\/li>\n<li>Management overhead: This strategy can become very resource intensive and cumbersome to manage if each environment encompasses multiple service components.<\/li>\n<li>We can of course create an environment per service, but then the matrix of interrelated environments becomes quite hard to comprehend.<\/li>\n<li>Data synchronisation between the 2 environments is challenging. Especially while the \u2018green\u2019 environment is still under test.<\/li>\n<\/ul>\n<h3>The upside:<\/h3>\n<ul>\n<li>Very low-stress deployments as we never deploy to production.<\/li>\n<li>No downtime as traffic redirection occurs on the fly.<\/li>\n<li>Availability of extensive production-like testing prior to switch-over.<\/li>\n<li>Rolling back in case something still goes wrong is as easy as just flipping the traffic switch back to the \u2018blue\u2019 environment. Data sync taken into account of course.<\/li>\n<\/ul>\n<h3>Applicability<\/h3>\n<p>This can be a good fit when you don\u2019t have too many services in your system, or when each service is fully autonomous.<\/p>\n<ul>\n<li>In the first case we can hold 2 copies of a full application environment. (In K8s each of these could be managed as a separate namespace.)<\/li>\n<li>In the second case we maintain a pair of environments for each service, test the service in isolation and flip the traffic switch when the new version is verified.<\/li>\n<\/ul>\n<h2>Canary Releases<\/h2>\n<p>Canary releases got their name from coal miners\u2019 practice of carrying a canary in a cage down the mine. If there were toxic gases in the mine \u00a0&#8211; they would kill the canary before killing the humans. Similarly a canary release lets us test for potential problems before impacting our entire production system or user base.<\/p>\n<p><img class=\"aligncenter size-full wp-image-5736\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/canary1.png\" alt=\"\" width=\"828\" height=\"557\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/canary1.png 828w, https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/canary1-300x202.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/canary1-768x517.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2017\/12\/canary1-488x328.png 488w\" sizes=\"(max-width: 828px) 100vw, 828px\" \/><\/p>\n<p>When practicing canary releases \u00a0&#8211;<\/p>\n<ol>\n<li>We deploy the new version into the same environment as the production system.<\/li>\n<li>We then reroute a small part of production traffic to be served by the new instance. (This is also referred to as \u2018testing in production\u2019.) The routing can be purely percentage-based or driven by specific criteria such as user location, type of client and billing properties. This kind of deployment requires careful application performance monitoring and error rate measurements. The collected metrics define the so-called canary quality threshold.<\/li>\n<li>If the threshold is not crossed (i.e &#8211; application is behaving as expected) we gradually spin up more new version instances transferring even more traffic to the new version. We may introduce additional canary quality gateways along the way.<\/li>\n<\/ol>\n<h3>The downside:<\/h3>\n<ul>\n<li>Canary can be seen as a variation of blue\/green with fine tuned traffic splitting and more meticulous quality threshold enforcement. Therefore, all the complexities of blue\/green are present and amplified.<\/li>\n<li>It requires heightened system observability, which is desirable but entails substantial effort to achieve.<\/li>\n<\/ul>\n<h3>The upside:<\/h3>\n<ul>\n<li>Observability: It is a must for canary strategy. Once you build up the needed infrastructure &#8211; your ability to experiment, test hypotheses and identify issues will provide a lot of power.<\/li>\n<li>Ability to test on actual production traffic: Creating production-like testing environments is hard. With canary there\u2019s no need to do the same.<\/li>\n<li>Ability to release a version to subset of users.<\/li>\n<li>Fail fast: Canary allows one to deploy straight into production and fail fast if something goes wrong. Of course care should be taken so the new app version does not cause data corruption.<\/li>\n<\/ul>\n<h3>Applicability<\/h3>\n<p>Use this if you\u2019ve already invested in modern monitoring and logging tools. May be less applicable if your deployments involve schema changes as you don\u2019t want to change production schemas just to test a new version.<\/p>\n<h2>A\/B Testing<\/h2>\n<p>Speaking strictly \u00a0&#8211; this isn\u2019t really a deployment strategy. More of a market research approach enabled by a deployment technology very similar to what we described as Canary.<\/p>\n<ol>\n<li>We deploy the new version alongside the old one and use traffic splitting techniques to route some of client requests to the new version.<\/li>\n<li>We then compare the business, application or system performance metrics between the two versions in order to understand what works best.<\/li>\n<\/ol>\n<p>A\/B testing allows us to not only compare old vs. new but also to deploy multiple versions of the new feature and analyze which one yields better business results.<\/p>\n<h3>The downside:<\/h3>\n<ul>\n<li>Heightened system complexity which is harder to debug and analyze.<\/li>\n<li>Involves advanced load balancing and traffic splitting techniques.<\/li>\n<\/ul>\n<h3>The upside:<\/h3>\n<ul>\n<li>Allows for intelligent market and customer behaviour analysis.<\/li>\n<li>Several application versions can be deployed in parallel.<\/li>\n<\/ul>\n<h3>Applicability<\/h3>\n<p>Use this when you\u2019ve already achieved continuous delivery of features. When your teams are agile enough to quickly produce autonomous features that can be easily rolled back or forward. This strategy works best with application-based continuous deployments techniques such as feature toggling. And of course everything I previously said about observability applies here too.<\/p>\n<h2>Summary<\/h2>\n<p>In this post we\u2019ve provided an overview of the major continuous deployment strategies. In the following posts of the series we will go over practical examples of implementing these strategies with Codefresh pipelines and Kubernetes.<\/p>\n<p>Stay tuned!<\/p>\n<p>New to Codefresh? <a href=\"https:\/\/codefresh.io\/codefresh-signup\/?utm_source=Blog&amp;utm_medium=Post&amp;utm_campaign=CDB\">Create Your Free Account Today!<\/a><\/p>\n<input class=\"fooboxshare_post_id\" type=\"hidden\" value=\"6882\"\/>","protected":false},"excerpt":{"rendered":"<p>Kubernetes provides a sophisticated platform for making cloud deployments easy. Low-stress deployments are the cornerstone of Continuous Delivery practices. Being able to reliably and safely deploy, rollback and orchestrate software releases allows engineering teams to iterate quickly, experiment and keep the customers happy. All at the same time. There is a number of industry-standard deployment &hellip; <a href=\"https:\/\/codefresh.io\/kubernetes-tutorial\/continuous-deployment-strategies-kubernetes-2\/\">Read more<\/a><\/p>\n","protected":false},"author":27,"featured_media":825,"comment_status":"closed","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[1657],"tags":[14,24,44,1227],"yoast_head":"<!-- This site is optimized with the Yoast SEO Premium plugin v17.9 (Yoast SEO v18.4.1) - https:\/\/yoast.com\/wordpress\/plugins\/seo\/ -->\n<title>Continuous Deployment Strategies with Kubernetes | Codefresh<\/title>\n<meta name=\"description\" content=\"Kubernetes provides a sophisticated platform for making cloud deployments easy. Low-stress deployments are the cornerstone of Continuous Delivery practices.\" \/>\n<meta name=\"robots\" content=\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\" \/>\n<link rel=\"canonical\" href=\"https:\/\/codefresh.io\/kubernetes-tutorial\/continuous-deployment-strategies-kubernetes-2\/\" \/>\n<meta property=\"og:locale\" content=\"en_US\" \/>\n<meta property=\"og:type\" content=\"article\" \/>\n<meta property=\"og:title\" content=\"Continuous Deployment Strategies with Kubernetes\" \/>\n<meta property=\"og:description\" content=\"Kubernetes provides a sophisticated platform for making cloud deployments easy. Low-stress deployments are the cornerstone of Continuous Delivery practices.\" \/>\n<meta property=\"og:url\" content=\"https:\/\/codefresh.io\/kubernetes-tutorial\/continuous-deployment-strategies-kubernetes-2\/\" \/>\n<meta property=\"og:site_name\" content=\"Codefresh\" \/>\n<meta property=\"article:publisher\" content=\"https:\/\/www.facebook.com\/codefresh.io\" \/>\n<meta property=\"article:published_time\" content=\"2017-12-29T19:29:03+00:00\" \/>\n<meta property=\"article:modified_time\" content=\"2022-03-01T17:39:58+00:00\" \/>\n<meta property=\"og:image\" content=\"https:\/\/codefresh.io\/wp-content\/uploads\/2016\/03\/continuous-unit-integration-ui-testing.jpg\" \/>\n\t<meta property=\"og:image:width\" content=\"447\" \/>\n\t<meta property=\"og:image:height\" content=\"290\" \/>\n\t<meta property=\"og:image:type\" content=\"image\/jpeg\" \/>\n<meta name=\"twitter:card\" content=\"summary_large_image\" \/>\n<meta name=\"twitter:creator\" content=\"@todaywasawesome\" \/>\n<meta name=\"twitter:site\" content=\"@codefresh\" \/>\n<meta name=\"twitter:label1\" content=\"Written by\" \/>\n\t<meta name=\"twitter:data1\" content=\"Dan Garfield\" \/>\n\t<meta name=\"twitter:label2\" content=\"Est. reading time\" \/>\n\t<meta name=\"twitter:data2\" content=\"9 minutes\" \/>\n<script type=\"application\/ld+json\" class=\"yoast-schema-graph\">{\"@context\":\"https:\/\/schema.org\",\"@graph\":[{\"@type\":\"Organization\",\"@id\":\"https:\/\/codefresh.io\/#organization\",\"name\":\"Codefresh\",\"url\":\"https:\/\/codefresh.io\/\",\"sameAs\":[\"https:\/\/www.facebook.com\/codefresh.io\",\"https:\/\/www.linkedin.com\/company\/codefresh\",\"https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg\",\"https:\/\/twitter.com\/codefresh\"],\"logo\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#logo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"width\":800,\"height\":800,\"caption\":\"Codefresh\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/#logo\"}},{\"@type\":\"WebSite\",\"@id\":\"https:\/\/codefresh.io\/#website\",\"url\":\"https:\/\/codefresh.io\/\",\"name\":\"Codefresh\",\"description\":\"\",\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"potentialAction\":[{\"@type\":\"SearchAction\",\"target\":{\"@type\":\"EntryPoint\",\"urlTemplate\":\"https:\/\/codefresh.io\/?s={search_term_string}\"},\"query-input\":\"required name=search_term_string\"}],\"inLanguage\":\"en-US\"},{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/continuous-deployment-strategies-kubernetes-2\/#primaryimage\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2016\/03\/continuous-unit-integration-ui-testing.jpg\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2016\/03\/continuous-unit-integration-ui-testing.jpg\",\"width\":447,\"height\":290,\"caption\":\"continuous unit integration ui testing\"},{\"@type\":\"WebPage\",\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/continuous-deployment-strategies-kubernetes-2\/#webpage\",\"url\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/continuous-deployment-strategies-kubernetes-2\/\",\"name\":\"Continuous Deployment Strategies with Kubernetes | Codefresh\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/#website\"},\"primaryImageOfPage\":{\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/continuous-deployment-strategies-kubernetes-2\/#primaryimage\"},\"datePublished\":\"2017-12-29T19:29:03+00:00\",\"dateModified\":\"2022-03-01T17:39:58+00:00\",\"description\":\"Kubernetes provides a sophisticated platform for making cloud deployments easy. Low-stress deployments are the cornerstone of Continuous Delivery practices.\",\"breadcrumb\":{\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/continuous-deployment-strategies-kubernetes-2\/#breadcrumb\"},\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"ReadAction\",\"target\":[\"https:\/\/codefresh.io\/kubernetes-tutorial\/continuous-deployment-strategies-kubernetes-2\/\"]}]},{\"@type\":\"BreadcrumbList\",\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/continuous-deployment-strategies-kubernetes-2\/#breadcrumb\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"name\":\"Home\",\"item\":\"https:\/\/codefresh.io\/\"},{\"@type\":\"ListItem\",\"position\":2,\"name\":\"Continuous Deployment Strategies with Kubernetes\"}]},{\"@type\":\"Article\",\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/continuous-deployment-strategies-kubernetes-2\/#article\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/continuous-deployment-strategies-kubernetes-2\/#webpage\"},\"author\":{\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/17aca6389be0f81b999f1b138a0b44a4\"},\"headline\":\"Continuous Deployment Strategies with Kubernetes\",\"datePublished\":\"2017-12-29T19:29:03+00:00\",\"dateModified\":\"2022-03-01T17:39:58+00:00\",\"mainEntityOfPage\":{\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/continuous-deployment-strategies-kubernetes-2\/#webpage\"},\"wordCount\":1808,\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/kubernetes-tutorial\/continuous-deployment-strategies-kubernetes-2\/#primaryimage\"},\"thumbnailUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2016\/03\/continuous-unit-integration-ui-testing.jpg\",\"keywords\":[\"docker\",\"Containers\",\"Kubernetes\",\"deployment strategies\"],\"articleSection\":[\"Kubernetes Tutorials\"],\"inLanguage\":\"en-US\"},{\"@type\":\"Person\",\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/17aca6389be0f81b999f1b138a0b44a4\",\"name\":\"Dan Garfield\",\"image\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#personlogo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/secure.gravatar.com\/avatar\/d4a38809809980ed49dc7e696a8e3938?s=96&d=blank&r=g\",\"contentUrl\":\"https:\/\/secure.gravatar.com\/avatar\/d4a38809809980ed49dc7e696a8e3938?s=96&d=blank&r=g\",\"caption\":\"Dan Garfield\"},\"description\":\"Dan is the Co-Founder and Chief Open Source Officer at Codefresh. His work in open source includes being an Argo Maintainer, and co-chair of the GitOps Working Group. As a technology leader with a background in full-stack engineering, evangelism, and communications, he led Codefresh's go-to-market strategy and now leads open source strategy. You can follow him at twitter.com\/todaywasawesome\",\"sameAs\":[\"https:\/\/twitter.com\/todaywasawesome\"],\"url\":\"https:\/\/codefresh.io\/author\/dang\/\"}]}<\/script>\n<!-- \/ Yoast SEO Premium plugin. -->","yoast_head_json":{"title":"Continuous Deployment Strategies with Kubernetes | Codefresh","description":"Kubernetes provides a sophisticated platform for making cloud deployments easy. Low-stress deployments are the cornerstone of Continuous Delivery practices.","robots":{"index":"index","follow":"follow","max-snippet":"max-snippet:-1","max-image-preview":"max-image-preview:large","max-video-preview":"max-video-preview:-1"},"canonical":"https:\/\/codefresh.io\/kubernetes-tutorial\/continuous-deployment-strategies-kubernetes-2\/","og_locale":"en_US","og_type":"article","og_title":"Continuous Deployment Strategies with Kubernetes","og_description":"Kubernetes provides a sophisticated platform for making cloud deployments easy. Low-stress deployments are the cornerstone of Continuous Delivery practices.","og_url":"https:\/\/codefresh.io\/kubernetes-tutorial\/continuous-deployment-strategies-kubernetes-2\/","og_site_name":"Codefresh","article_publisher":"https:\/\/www.facebook.com\/codefresh.io","article_published_time":"2017-12-29T19:29:03+00:00","article_modified_time":"2022-03-01T17:39:58+00:00","og_image":[{"width":447,"height":290,"url":"https:\/\/codefresh.io\/wp-content\/uploads\/2016\/03\/continuous-unit-integration-ui-testing.jpg","type":"image\/jpeg"}],"twitter_card":"summary_large_image","twitter_creator":"@todaywasawesome","twitter_site":"@codefresh","twitter_misc":{"Written by":"Dan Garfield","Est. reading time":"9 minutes"},"schema":{"@context":"https:\/\/schema.org","@graph":[{"@type":"Organization","@id":"https:\/\/codefresh.io\/#organization","name":"Codefresh","url":"https:\/\/codefresh.io\/","sameAs":["https:\/\/www.facebook.com\/codefresh.io","https:\/\/www.linkedin.com\/company\/codefresh","https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg","https:\/\/twitter.com\/codefresh"],"logo":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#logo","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","width":800,"height":800,"caption":"Codefresh"},"image":{"@id":"https:\/\/codefresh.io\/#logo"}},{"@type":"WebSite","@id":"https:\/\/codefresh.io\/#website","url":"https:\/\/codefresh.io\/","name":"Codefresh","description":"","publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"potentialAction":[{"@type":"SearchAction","target":{"@type":"EntryPoint","urlTemplate":"https:\/\/codefresh.io\/?s={search_term_string}"},"query-input":"required name=search_term_string"}],"inLanguage":"en-US"},{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/continuous-deployment-strategies-kubernetes-2\/#primaryimage","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2016\/03\/continuous-unit-integration-ui-testing.jpg","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2016\/03\/continuous-unit-integration-ui-testing.jpg","width":447,"height":290,"caption":"continuous unit integration ui testing"},{"@type":"WebPage","@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/continuous-deployment-strategies-kubernetes-2\/#webpage","url":"https:\/\/codefresh.io\/kubernetes-tutorial\/continuous-deployment-strategies-kubernetes-2\/","name":"Continuous Deployment Strategies with Kubernetes | Codefresh","isPartOf":{"@id":"https:\/\/codefresh.io\/#website"},"primaryImageOfPage":{"@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/continuous-deployment-strategies-kubernetes-2\/#primaryimage"},"datePublished":"2017-12-29T19:29:03+00:00","dateModified":"2022-03-01T17:39:58+00:00","description":"Kubernetes provides a sophisticated platform for making cloud deployments easy. Low-stress deployments are the cornerstone of Continuous Delivery practices.","breadcrumb":{"@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/continuous-deployment-strategies-kubernetes-2\/#breadcrumb"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https:\/\/codefresh.io\/kubernetes-tutorial\/continuous-deployment-strategies-kubernetes-2\/"]}]},{"@type":"BreadcrumbList","@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/continuous-deployment-strategies-kubernetes-2\/#breadcrumb","itemListElement":[{"@type":"ListItem","position":1,"name":"Home","item":"https:\/\/codefresh.io\/"},{"@type":"ListItem","position":2,"name":"Continuous Deployment Strategies with Kubernetes"}]},{"@type":"Article","@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/continuous-deployment-strategies-kubernetes-2\/#article","isPartOf":{"@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/continuous-deployment-strategies-kubernetes-2\/#webpage"},"author":{"@id":"https:\/\/codefresh.io\/#\/schema\/person\/17aca6389be0f81b999f1b138a0b44a4"},"headline":"Continuous Deployment Strategies with Kubernetes","datePublished":"2017-12-29T19:29:03+00:00","dateModified":"2022-03-01T17:39:58+00:00","mainEntityOfPage":{"@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/continuous-deployment-strategies-kubernetes-2\/#webpage"},"wordCount":1808,"publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"image":{"@id":"https:\/\/codefresh.io\/kubernetes-tutorial\/continuous-deployment-strategies-kubernetes-2\/#primaryimage"},"thumbnailUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2016\/03\/continuous-unit-integration-ui-testing.jpg","keywords":["docker","Containers","Kubernetes","deployment strategies"],"articleSection":["Kubernetes Tutorials"],"inLanguage":"en-US"},{"@type":"Person","@id":"https:\/\/codefresh.io\/#\/schema\/person\/17aca6389be0f81b999f1b138a0b44a4","name":"Dan Garfield","image":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#personlogo","inLanguage":"en-US","url":"https:\/\/secure.gravatar.com\/avatar\/d4a38809809980ed49dc7e696a8e3938?s=96&d=blank&r=g","contentUrl":"https:\/\/secure.gravatar.com\/avatar\/d4a38809809980ed49dc7e696a8e3938?s=96&d=blank&r=g","caption":"Dan Garfield"},"description":"Dan is the Co-Founder and Chief Open Source Officer at Codefresh. His work in open source includes being an Argo Maintainer, and co-chair of the GitOps Working Group. As a technology leader with a background in full-stack engineering, evangelism, and communications, he led Codefresh's go-to-market strategy and now leads open source strategy. You can follow him at twitter.com\/todaywasawesome","sameAs":["https:\/\/twitter.com\/todaywasawesome"],"url":"https:\/\/codefresh.io\/author\/dang\/"}]}},"acf":[],"_links":{"self":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/6882"}],"collection":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/users\/27"}],"replies":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/comments?post=6882"}],"version-history":[{"count":1,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/6882\/revisions"}],"predecessor-version":[{"id":21753,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/6882\/revisions\/21753"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media\/825"}],"wp:attachment":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media?parent=6882"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/categories?post=6882"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/tags?post=6882"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}