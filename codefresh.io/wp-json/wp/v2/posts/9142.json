{"id":9142,"date":"2018-06-20T20:33:27","date_gmt":"2018-06-20T20:33:27","guid":{"rendered":"http:\/\/codefresh.io\/?p=9142"},"modified":"2019-04-18T01:59:22","modified_gmt":"2019-04-18T01:59:22","slug":"using-docker-maven-maven-docker","status":"publish","type":"post","link":"https:\/\/codefresh.io\/howtos\/using-docker-maven-maven-docker\/","title":{"rendered":"Using Docker from Maven and Maven from Docker"},"content":{"rendered":"<p><strong>Update: July 5<br \/>\nAfter publishing this post we got an extensive response from <a href=\"https:\/\/twitter.com\/ro14nd\">Roland Huss<\/a> maintainer of the fabric8 plugin, both as a comment here and at <a href=\"https:\/\/ro14nd.de\/dmp-not-so-bad\">his blog<\/a><br \/>\nWe updated the article to address some of his concerns, and also responded in the comments.<\/strong><\/p>\n<p>Even though containers have changed the way an application is packaged and deployed to the cloud, they don\u2019t always make things easier for local development. Especially for Java developers (where standardized packaging formats were already present in the form or WAR and EAR files), Docker seems to be at first glance another level of abstraction that makes local development a bit more difficult.<\/p>\n<p>It is true that several Docker advantages are not that impressive to Java developers, but that does not mean that developing Java applications with Docker is necessarily a complex process. In fact, using Docker in a Java application can be very transparent, as the Docker packaging step can be easily added as an extra step in the build process.<\/p>\n<p><img class=\"alignnone size-full wp-image-9144\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/06\/docker-plus-maven.jpg\" alt=\"\" width=\"800\" height=\"410\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/06\/docker-plus-maven.jpg 800w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/06\/docker-plus-maven-300x154.jpg 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/06\/docker-plus-maven-768x394.jpg 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/06\/docker-plus-maven-628x322.jpg 628w\" sizes=\"(max-width: 800px) 100vw, 800px\" \/><\/p>\n<p>In this article, we will see how Docker can easily work with Maven (the de-facto build system for Java applications). As with most other technologies before Docker, Maven can be easily extended with custom plugins that inject the build lifecycle with extra functionality.<\/p>\n<p>We will explore two Maven plugins for Docker:<\/p>\n<ol>\n<li>The new version of the <a href=\"https:\/\/github.com\/spotify\/dockerfile-maven\">Spotify Docker plugin<\/a><\/li>\n<li>The <a href=\"https:\/\/github.com\/fabric8io\/docker-maven-plugin\">fabric8 Docker plugin<\/a><\/li>\n<\/ol>\n<p>At the time of writing these are the two major Docker plugins that still see active development. There are several other Maven docker plugins that are now abandoned. Also, note that the <a href=\"https:\/\/github.com\/spotify\/docker-maven-plugin\">old version of the Spotify plugin<\/a> is now deprecated and here we are focusing on the new one.<\/p>\n<h2>Should you use a Maven plugin for Docker?<\/h2>\n<p>This question might seem strange given the title of the article, but it makes perfect sense if you have followed Docker from its early days. Docker is one of the fastest moving technologies at the moment and in the past, there were several occasions where new Docker versions were not compatible with the old ones. When you select a Maven plugin for Docker, you essentially trust the plugin developers that they will continuously update it, as new Docker versions appear.<\/p>\n<p>There have been cases in the past where Docker has broken compatibility even between its own client and server, so a Maven plugin that uses the same API will instantly break as well. In less extreme cases, Docker has presented new features that will not automatically transfer to your favorite Maven plugin. You need to decide if this delay is important to you or not.<\/p>\n<p>For this reason, it is crucial to understand how each Maven plugin actually communicates with the Docker environment and all the points where breakage can occur.<\/p>\n<p>I have seen at least two companies that instead of using a dedicated Docker plugin, are just calling the native Docker executable via the <a href=\"https:\/\/www.mojohaus.org\/exec-maven-plugin\/\">maven exec plugin<\/a>. This means that the Docker version that is injected in the Maven lifecycle is always the same as the Docker daemon that will actually run the image. This solution is not very elegant but it is more resistant to API breakage and guarantees the latest Docker version for the Maven build process.<\/p>\n<h2>The example application<\/h2>\n<p>As a running example, we will be using an old school Java application found at <a href=\"https:\/\/github.com\/kostis-codefresh\/docker-maven-comparison\">https:\/\/github.com\/kostis-codefresh\/docker-maven-comparison<\/a>. It is old school because it is a simple WAR file (no DB needed) that requires Tomcat to run. Also, the Dockerfile expects the WAR file to be created externally (we will talk about multi-stage builds later in this article). Here is the respective <a href=\"https:\/\/github.com\/kostis-codefresh\/docker-maven-comparison\/blob\/master\/01-using-spotify-plugin\/Dockerfile\">Dockerfile <\/a>found at the root of the project:<\/p>\n<pre class=\"lang:default decode:true \"> \nFROM tomcat:9.0-jre8-alpine\n\nCOPY target\/wizard*.war $CATALINA_HOME\/webapps\/wizard.war\n<\/pre>\n<p>The war file is created during the <strong>package <\/strong>phase of the Maven build process. The source code contains unit tests as well as integration tests that connect to localhost:8080 and just verify that that tomcat is up and running and that it has deployed the correct application context.<\/p>\n<p>The unit tests are executed during the <strong>test <\/strong>phase while the integration tests are using the <a href=\"http:\/\/maven.apache.org\/surefire\/maven-failsafe-plugin\/\">failsafe plugin<\/a> and thus run at the <strong>integration-test<\/strong> phase (or <strong>verify<\/strong>).<\/p>\n<p>If you are not familiar with the Maven lifecycle, consult the <a href=\"https:\/\/maven.apache.org\/guides\/introduction\/introduction-to-the-lifecycle.html#Lifecycle_Reference\">documentation <\/a>to see all the available phases.<\/p>\n<h2>The Spotify Maven Docker plugin<\/h2>\n<p>The Docker plugin from Spotify is the embodiment of simplicity. It actually supports only two operations: building a <a href=\"https:\/\/codefresh.io\/docs\/docs\/yaml-examples\/examples\/build-and-push-an-image\/\">Docker image<\/a> and pushing a Docker image to the Registry.<\/p>\n<p>The plugin is not calling Docker directly but instead acts as a wrapper around Docker-client (<a href=\"https:\/\/github.com\/spotify\/docker-client\">https:\/\/github.com\/spotify\/docker-client<\/a> ) also developed by Spotify.<\/p>\n<p><img class=\"alignnone size-full wp-image-9147\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/06\/spotify-docker.png\" alt=\"\" width=\"800\" height=\"457\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/06\/spotify-docker.png 800w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/06\/spotify-docker-300x171.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/06\/spotify-docker-768x439.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/06\/spotify-docker-574x328.png 574w\" sizes=\"(max-width: 800px) 100vw, 800px\" \/><\/p>\n<p>This means that the plugin can only use Docker features that are offered by the docker-client library and if at any point this library breaks because an incompatible Docker version appeared, the plugin will also break.<\/p>\n<p>Using the plugin is straightforward. You include it in your pom.xml file in the build section as you would expect.<\/p>\n<pre class=\"lang:default decode:true \"> \n<plugin>\n        <groupId>com.spotify<\/groupId>\n             <artifactId>dockerfile-maven-plugin<\/artifactId>\n             <version>1.4.3<\/version>\n             <executions>\n                 <execution>\n                     <id>default<\/id>\n                     <goals>\n                         <goal>build<\/goal>\n                     <\/goals>\n                 <\/execution>\n             <\/executions>\n             <configuration>\n             <repository>docker.io\/kkapelon\/docker-maven-comparison<\/repository>\n                 <tag>${project.version}<\/tag>\n             <\/configuration>\n         <\/plugin>\n\n<\/pre>\n<p>There are 3 things defined here:<\/p>\n<ul>\n<li>The name of the Docker image that will be created (also includes the registry URL)<\/li>\n<li>The tag of the Docker image. Here it is the same at the Maven project version. So your Docker images will be named with the same version as the WAR file<\/li>\n<li>A binding of the plugin to the Maven build lifecycle. Here I have left the default values so the plugin will automatically kick-in after the package phase and thus the Dockerfile will detect the already created WAR file.<\/li>\n<\/ul>\n<p>Now you can simply run \u201cmvn package\u201d and watch the Docker image get created:<\/p>\n<pre class=\"lang:default decode:true \">[INFO] Packaging webapp\n[INFO] Assembling webapp [wizard] in [\/home\/osboxes\/workspace\/docker-maven-comparison\/01-using-spotify-plugin\/target\/wizard-0.0.1-SNAPSHOT]\n[INFO] Processing war project\n[INFO] Copying webapp resources [\/home\/osboxes\/workspace\/docker-maven-comparison\/01-using-spotify-plugin\/src\/main\/webapp]\n[INFO] Webapp assembled in [161 msecs]\n[INFO] Building war: \/home\/osboxes\/workspace\/docker-maven-comparison\/01-using-spotify-plugin\/target\/wizard-0.0.1-SNAPSHOT.war\n[INFO]\n[INFO] --- dockerfile-maven-plugin:1.4.3:build (default) @ wizard ---\n[INFO] Building Docker context \/home\/osboxes\/workspace\/docker-maven-comparison\/01-using-spotify-plugin\n[... redacted for brevity\u2026]\n[INFO]\n[INFO] Detected build of image with id 8deea9aaed5f\n[INFO] Building jar: \/home\/osboxes\/workspace\/docker-maven-comparison\/01-using-spotify-plugin\/target\/wizard-0.0.1-SNAPSHOT-docker-info.jar\n[INFO] Successfully built docker.io\/kkapelon\/docker-maven-comparison:0.0.1-SNAPSHOT\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n<\/pre>\n<p>We can verify that the image was created:<\/p>\n<pre class=\"lang:default decode:true \">$ docker image list\nREPOSITORY                                 TAG                 IMAGE ID            CREATED             SIZE\nkkapelon\/docker-maven-comparison           0.0.1-SNAPSHOT      e7efa33b669f        2 seconds ago       119 MB\n<\/pre>\n<p>We can test the image by launching the container<\/p>\n<pre class=\"lang:default decode:true \">$ docker run -p 8080:8080 kkapelon\/docker-maven-comparison:0.0.1-SNAPSHOT\n<\/pre>\n<p>The Spotify plugin also includes the capability to push a Docker image to a Registry. It supports various authentication methods that allow you to use DockerHub or another external registry that requires credentials. The Docker push step can easily be bound to the Maven <strong>deploy <\/strong>phase so that the end of a Maven build also results in uploading a Docker image.<\/p>\n<p>I am not going to show this capability, however, as pushing Docker images from a developer workstation is not recommended. Only a CI server should push Docker images in a well-behaved manner (i.e. when tests are passing). Pushing Docker images from a developer workstation is even more dangerous if the changes are not committed first.<\/p>\n<p>Finally, the Spotify Docker plugin can be executed using its individual goals, if for some reason you don\u2019t want to bind it to the Maven lifecycle. These are<\/p>\n<ul>\n<li>dockerfile:build<\/li>\n<li>dockerfile:push<\/li>\n<li>dockerfile:tag<\/li>\n<\/ul>\n<p>This concludes the capabilities of the Spotify Maven plugin. It is as simple as it gets focusing only on creating Docker images.<\/p>\n<p>Remember however that our sample application also includes integration tests. Wouldn\u2019t it be nice if we could also launch the Docker image as part of the Maven lifecycle and run the integration tests against the resulting container?<\/p>\n<p>This is where the next plugin finds its place&#8230;<\/p>\n<h2>The Fabric8 Maven Docker plugin<\/h2>\n<p>As we saw in the previous section, the Spotify Maven plugin is a very spartan solution that focuses on building Docker images and nothing else. The <a href=\"https:\/\/github.com\/fabric8io\/docker-maven-plugin\">Maven plugin from Fabric8<\/a> takes instead the \u201ckitchen-sink \u201c approach. It supports both building and starting\/stopping Docker containers among several other features such as Docker volumes, log viewing, docker machine support etc.<\/p>\n<p>It even supports the creation of Docker images without a <a href=\"https:\/\/codefresh.io\/docker-tutorial\/build-docker-image-dockerfiles\/\">Dockerfile<\/a> (!!!) as we will see later on.<\/p>\n<p>This plugin communicates <a href=\"https:\/\/github.com\/fabric8io\/docker-maven-plugin\/blob\/master\/src\/main\/java\/io\/fabric8\/maven\/docker\/access\/hc\/DockerAccessWithHcClient.java#L39\">directly with the Docker daemon<\/a> in an effort to make it as robust as possible and minimize its dependencies.<\/p>\n<p><img class=\"alignnone size-full wp-image-9148\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/06\/fabric8-docker.png\" alt=\"\" width=\"800\" height=\"457\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/06\/fabric8-docker.png 800w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/06\/fabric8-docker-300x171.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/06\/fabric8-docker-768x439.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/06\/fabric8-docker-574x328.png 574w\" sizes=\"(max-width: 800px) 100vw, 800px\" \/><\/p>\n<p>At first glance, the fabric8 plugin seems very opinionated. As a starting point, you can create Docker images with it without actually having a Dockerfile! Instead, the plugin allows you to describe your image in an XML format that will be then converted to a Dockerfile on the fly.  Here is an example straight out of the <a href=\"https:\/\/dmp.fabric8.io\/#build-assembly\">documentation<\/a>.<\/p>\n<pre class=\"lang:default decode:true \"> \n<build>\n  <from>java:8u40<\/from>\n  <maintainer>john.doe@example.com<\/maintainer>\n  <tags>\n    <tag>latest<\/tag>\n    <tag>${project.version}<\/tag>\n  <\/tags>\n  <ports>\n    <port>8080<\/port>\n  <\/ports>\n  <volumes>\n    <volume>\/path\/to\/expose<\/volume>\n  <\/volumes>\n  <buildOptions>\n    <shmsize>2147483648<\/shmsize>\n  <\/buildOptions>\n\n  <entryPoint>\n    <!-- exec form for ENTRYPOINT -->\n    <exec>\n      <arg>java<\/arg>\n      <arg>-jar<\/arg>\n      <arg>\/opt\/demo\/server.jar<\/arg>\n    <\/exec>\n  <\/entryPoint>\n\n  <assembly>\n    <mode>dir<\/mode>\n    <targetDir>\/opt\/demo<\/targetDir>\n    <descriptor>assembly.xml<\/descriptor>\n  <\/assembly>\n<\/build>\n\n<\/pre>\n<p>As you can see there are all the familiar Docker directives such as FROM, VOLUME, ENTRYPOINT etc.<\/p>\n<p>I admit I don\u2019t like this approach and did not explore it further. Dockerfiles are well understood and documented even outside the Java world, while describing a Docker in this XML format is something specific to this plugin, and goes against the platform independence of Docker.<\/p>\n<p>Hopefully, the fabric8 plugin also supports plain Dockerfiles. Even there, however, it has some strong opinions. (<Strong>Update:See comments on this article<\/strong>) It assumes that the Dockerfile of a project is in src\/main\/docker and also it uses the assembly syntax for actually deciding what artifact is available during the Docker build step.<\/p>\n<p>Here is the respective pom.xml fragment<\/p>\n<pre class=\"lang:default decode:true \">        \n<plugin>\n         <groupId>io.fabric8<\/groupId>\n         <artifactId>docker-maven-plugin<\/artifactId>\n         <version>0.26.0<\/version>\n         <executions>\n             <execution>\n                 <id>start<\/id>\n                 <phase>pre-integration-test<\/phase>\n                 <goals>\n                     <goal>build<\/goal>\n                     <goal>start<\/goal>\n                 <\/goals>\n             <\/execution>\n             <execution>\n                 <id>stop<\/id>\n                 <phase>post-integration-test<\/phase>\n                 <goals>\n                     <goal>stop<\/goal>\n                 <\/goals>\n             <\/execution>\n         <\/executions>\n\n\n         <configuration>\n             <images>\n                 <image>\n                 <name>docker.io\/kkapelon\/docker-maven-comparison<\/name>\n                     <build>\n                     <dockerFile>${project.basedir}\/Dockerfile<\/dockerFile >\n                         <\/build>\n                         <run>\n                             <ports>\n                                 <port>8080:8080<\/port>\n                             <\/ports>\n                             <wait>\n                             <!-- Check for this URL to return a 200 return code .... -->\n                             <url>http:\/\/localhost:8080\/wizard<\/url>\n                                 <time>120000<\/time>\n                             <\/wait>     \n                         <\/run>\n                     <\/image>\n\n                 <\/images>\n             <\/configuration>\n         <\/plugin>\n                 \n                            \n                        \n\n                    \n                \n            \n<\/pre>\n<p>Again we configure the name of the image and the location of the Dockerfile. For the run section, we map port 8080 (where tomcat runs) from the container to the Docker host and we also define a wait condition.<\/p>\n<p>Having a wait condition is one of the strongest points of the Fabric8 Docker plugin as it allows you to run integration tests against the containers. Maven will wait until the container is \u201chealthy\u201d before moving to the next phase, so we can guarantee that when the integration tests are running the container will be ready to accept requests.<\/p>\n<p>The configuration setting basically makes sure that the container is launched before the tests and destroyed after. Here is the diagram:<\/p>\n<p><img class=\"alignnone size-full wp-image-9149\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/06\/maven-lifecycle.png\" alt=\"\" width=\"599\" height=\"745\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/06\/maven-lifecycle.png 599w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/06\/maven-lifecycle-241x300.png 241w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/06\/maven-lifecycle-264x328.png 264w\" sizes=\"(max-width: 599px) 100vw, 599px\" \/><\/p>\n<p>The final result is that we can run <strong>mvn verify<\/strong> and the following will happen:<\/p>\n<ol>\n<li>Java code will be compiled<\/li>\n<li>Unit tests will run<\/li>\n<li>A WAR file will be created<\/li>\n<li>A tomcat Docker image with the WAR file will be built<\/li>\n<li>The Docker image will be launched locally and will expose port 8080<\/li>\n<li>Maven will wait until the container is actually up and can serve requests<\/li>\n<li>Integration tests will run and will hit localhost:8080<\/li>\n<li>The container will be stopped<\/li>\n<li>The result of the build will be reported<\/li>\n<\/ol>\n<p>Here is a sample run<\/p>\n<pre class=\"lang:default decode:true \">[INFO]\n[INFO] --- docker-maven-plugin:0.26.0:build (start) @ wizard ---\n[INFO] Building tar: \/home\/osboxes\/workspace\/docker-maven-comparison\/02-using-fabric8-plugin\/target\/docker\/docker.io\/kkapelon\/docker-maven-comparison\/tmp\/docker-build.tar\n[INFO] DOCKER&gt; [docker.io\/kkapelon\/docker-maven-comparison:latest]: Created docker-build.tar in 464 milliseconds\n[INFO] DOCKER&gt; [docker.io\/kkapelon\/docker-maven-comparison:latest]: Built image sha256:f15a6\n[INFO] DOCKER&gt; [docker.io\/kkapelon\/docker-maven-comparison:latest]: Removed old image sha256:7cebc\n[INFO]\n[INFO] --- docker-maven-plugin:0.26.0:start (start) @ wizard ---\n[INFO] DOCKER&gt; [docker.io\/kkapelon\/docker-maven-comparison:latest]: Start container 65cefab5942c\n[INFO] DOCKER&gt; [docker.io\/kkapelon\/docker-maven-comparison:latest]: Waiting on url http:\/\/localhost:8080\/wizard.\n[INFO] DOCKER&gt; [docker.io\/kkapelon\/docker-maven-comparison:latest]: Waited on url http:\/\/localhost:8080\/wizard 8297 ms\n[INFO]\n[INFO] --- maven-failsafe-plugin:2.18:integration-test (default) @ wizard ---\n[INFO] Failsafe report directory: \/home\/osboxes\/workspace\/docker-maven-comparison\/02-using-fabric8-plugin\/target\/failsafe-reports\n-------------------------------------------------------\n T E S T S\n-------------------------------------------------------\n[..redacted for brevity\u2026..]\nTests run: 2, Failures: 0, Errors: 0, Skipped: 0\n\n[INFO]\n[INFO] --- docker-maven-plugin:0.26.0:stop (stop) @ wizard ---\n[INFO] DOCKER&gt; [docker.io\/kkapelon\/docker-maven-comparison:latest]: Stop and removed container 65cefab5942c after 0 ms\n[INFO]\n[INFO] --- maven-failsafe-plugin:2.18:verify (default) @ wizard ---\n[INFO] Failsafe report directory: \/home\/osboxes\/workspace\/docker-maven-comparison\/02-using-fabric8-plugin\/target\/failsafe-reports\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n<\/pre>\n<h2>Plot twist: Using Maven from Docker<\/h2>\n<p>If you have been paying attention you will have noticed that the Dockerfiles we used so far expect the application to be already compiled. This means that the machine that creates the Docker image needs to have a development environment as well (in our case a JDK and Maven).<\/p>\n<p>This is of course very easy to handle in your workstation, but quickly becomes problematic when it comes to build slaves. Traditionally, build slaves that include development tools have been very resistant to changes (especially if in your organization the build slaves are not controlled by the development team). Upgrading a newer version of the JDK or Maven in a build slave is one of the most common requests from a dev team to an operations team. The pain of tooling upgrades is even more evident with organizations that are not pure Java shops (imagine a build slave that has Java, Node, Python, PHP etc).<\/p>\n<p>The reason that this happens is that both plugins we have seen so far assume that Maven is in control. The two plugins work by allowing Maven to control Docker during the build process.<\/p>\n<p>Here is the plot twist: We could also revert this relationship and allow Docker to control Maven :-). This means that Docker calls Maven commands from within a Docker container. While most people think Docker as a deployment format for the application itself, in reality, Docker can be used for the build process as well (i.e. tooling via Docker)<\/p>\n<p>The approach has several advantages. First of all, it makes the combination, future proof as the API of the docker daemon is no longer relevant to the build process. Secondly, it makes for really simple build slaves (they only have Docker installed and nothing else)<\/p>\n<p>As a developer, you also gain the fastest upgrade possible for build tools. If you have Maven version N and you want to go to version N+1 you just change the Docker image that is used for the Maven compilation and you are done. No need to open a ticket or notify anybody for an upgrade. Do you want to use 3 different versions of JDKs at once? Again this is super simple as you can use 3 different Dockerfiles for 3 different application. All of them can build on the same machine.<\/p>\n<p>In the past, Docker tooling for compiled languages was a bit complicated (because normally you don\u2019t want your compilation tools to end up in the production image), but with the <a href=\"https:\/\/blog.docker.com\/2017\/07\/multi-stage-builds\/\">introduction of multi-stage builds<\/a> in Docker version 17.06 the process is now much easier.<\/p>\n<p>The idea here is that we make the Docker build completely self-sufficient. Instead of making the Docker file assume the existence of the WAR file, we create the WAR file as part of the build process itself.<\/p>\n<p>Here is the respective Dockerfile:<\/p>\n<pre class=\"lang:default decode:true \">FROM maven:3.5.2-jdk-8-alpine AS MAVEN_TOOL_CHAIN\nCOPY pom.xml \/tmp\/\nCOPY src \/tmp\/src\/\nWORKDIR \/tmp\/\nRUN mvn package\n\nFROM tomcat:9.0-jre8-alpine\nCOPY --from=MAVEN_TOOL_CHAIN \/tmp\/target\/wizard*.war $CATALINA_HOME\/webapps\/wizard.war\n\nHEALTHCHECK --interval=1m --timeout=3s CMD wget --quiet --tries=1 --spider http:\/\/localhost:8080\/wizard\/ || exit 1\n<\/pre>\n<p>First, we use a Maven image to compile the source code of the application. As an extra bonus <strong>mvn package<\/strong> will also execute the unit tests. Then, from the results, we take only the WAR file and embed in the Tomcat image as before.<\/p>\n<p>The source code, the maven dependencies, the raw classes and everything under the Maven target folder are NOT included in the final image.<\/p>\n<p>So what have we gained here?<\/p>\n<p>First of all, there is no fear of API breakage. This Dockerfile will always work regardless of internal API changes in the Docker daemon.<\/p>\n<p>Secondly, if you want to update to Maven 3.6 for the compilation process you just change the first line in the docker file and rebuild your image. This is as simple as it gets.<\/p>\n<p>Finally, if you have 10 applications that compile this way you can actually use 10 different combinations of JDK\/Maven just be using a different Maven image. But the build slave itself uses only\u00a0Docker. No more nightmares of configuring multiple JDKs on the same host.<\/p>\n<p>And let\u2019s say that tomorrow you decide to use Gradle for this very same application. Again you will just use a Gradle image as the first line in the Dockerfile. The ops team does not need to know or even care about what build tool you need for your application.<\/p>\n<p>Having a build process based on Docker also opens a lot of opportunities for working with tools that are Docker compatible (rather than Java\/Maven specific)<\/p>\n<p>The best example of this is the ease of moving this project to CI\/CD. In the past, migrating to a CI\/CD platform meant that you needed to understand first if your favorite versions of Java\/Maven were supported. And if they weren\u2019t you had to contact the vendor and ask them to add support.<\/p>\n<p>This is not needed anymore. You can use any tool\/platform that supports Docker even if it doesn\u2019t advertise explicit support for Maven.<\/p>\n<p>One thing that we missed with the multi-stage docker build shown above is the run of integration tests (unit tests are still executed just fine).<\/p>\n<p>To run integration tests we will use <a href=\"https:\/\/codefresh.io\/features\/\">Codefresh<\/a>, the Docker-based CI\/CD platform. Because Maven is now controlled by Docker and Codefresh supports natively Docker tooling as part of the build process, we can run the build on the cloud without really caring about what tools are available on Codefresh build slaves.<\/p>\n<h2>Multi-stage builds with Codefresh<\/h2>\n<p>The power of multi-stage builds becomes evident as soon as you create a project in Codefresh. As long as your project contains a Dockerfile (which is true in our case) your build is dead simple!<\/p>\n<p><img class=\"alignnone size-full wp-image-9150\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/06\/build-method.png\" alt=\"\" width=\"899\" height=\"409\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/06\/build-method.png 899w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/06\/build-method-300x136.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/06\/build-method-768x349.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/06\/build-method-628x286.png 628w\" sizes=\"(max-width: 899px) 100vw, 899px\" \/><\/p>\n<p>Here Codefresh will just use the Dockerfile and create a Docker image, downloading the Maven docker image as part of the Docker build itself. You don\u2019t need to know if Codefresh has explicit support for Maven, it doesn\u2019t really matter (this wouldn\u2019t be true if you tried to use the traditional way where Maven controls the build).<\/p>\n<p>Once you select your Dockerfile and without any other configuration Codefresh performs a build and the resulting Docker image is placed on the <a href=\"https:\/\/codefresh.io\/docs\/docs\/docker-registries\/codefresh-registry\/\">internal Docker registry<\/a> (built-in with each Codefresh account).<\/p>\n<p><img class=\"alignnone size-large wp-image-9151\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/06\/registry-1-1024x248.png\" alt=\"\" width=\"1024\" height=\"248\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/06\/registry-1-1024x248.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/06\/registry-1-300x73.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/06\/registry-1-768x186.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/06\/registry-1-628x152.png 628w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/06\/registry-1.png 1117w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" \/><\/p>\n<p>If we used the non-multi-stage Docker file things would not be as simple. We would need to define within Codefresh how to compile the code first (using a Maven step) and then how to create the image from the resulting WAR file. This is perfectly possible with Codefresh, but much more complex than what we have now.<\/p>\n<h2>Multi-stage builds and integration tests with Codefresh<\/h2>\n<p>I promised before that we will take care of the automatic run of integration tests (i.e. tests that require the application to be up) even with multi-stage builds. The unit tests run just fine during the build (as part of the <strong>maven package<\/strong> goal) but the integration tests do not.<\/p>\n<p>We need a way to launch the application and run integration tests against it. Codefresh can easily do this using <a href=\"https:\/\/codefresh.io\/docs\/docs\/codefresh-yaml\/steps\/composition-1\/\">compositions <\/a>(think <a href=\"https:\/\/docs.docker.com\/compose\/\">Docker compose<\/a> as a service). A Codefresh pipeline can start and stop a Docker image as part of the build process using a syntax similar to Docker compose.<\/p>\n<p>But how do we run the integration tests? Using the Docker paradigm of course! We will create a separate Docker image that holds the tests (i.e. the source code plus Maven). This image is only used during compilation, it is not deployed anywhere so we are ok with it having development tools.<\/p>\n<p>Here is <a href=\"https:\/\/github.com\/kostis-codefresh\/docker-maven-comparison\/blob\/master\/04-codefresh\/Dockerfile.testing\">Dockerfile.testing<\/a><\/p>\n<pre class=\"lang:default decode:true \">FROM maven:3.5.2-jdk-8-alpine \nCOPY wait-for-it.sh \/usr\/bin\nRUN chmod +x \/usr\/bin\/wait-for-it.sh\nCOPY pom.xml \/tmp\/\nCOPY src \/tmp\/src\/\nWORKDIR \/tmp\/\n<\/pre>\n<p>This is a simple Docker file that extends the Maven image and just copies the source code. We also package the <a href=\"https:\/\/github.com\/vishnubob\/wait-for-it\">wait-for-it<\/a> script that will come handy later on.<\/p>\n<p>Now we are ready to run everything in Codefresh. For this build, we will use a codefresh.yml file that<\/p>\n<ol>\n<li>Creates the Docker image of the application (multi-stage build)<\/li>\n<li>Creates a second Docker image with the tests<\/li>\n<li>Launches the application image and expose port 8080<\/li>\n<li>Executes the tests from the testing image targeting the launched application<\/li>\n<li>Finishes the build with success if everything passes<\/li>\n<\/ol>\n<p>Here is the <a href=\"https:\/\/github.com\/kostis-codefresh\/docker-maven-comparison\/blob\/master\/codefresh.yml\">codefresh.yml<\/a> file<\/p>\n<pre class=\"lang:default decode:true \">version: '1.0'\nsteps:\n  build_image:\n    type: build\n    description: Building the image...\n    image_name: docker-maven-comparison\n    working_directory: .\/04-codefresh\n    tag: develop\n  build_image_with_tests:\n    type: build\n    description: Building the Test image...\n    image_name: maven-integration-tests\n    working_directory: .\/04-codefresh\n    dockerfile: Dockerfile.testing\n  integration_tests:\n    type: composition\n    title: Launching QA environment\n    description: Temporary test environment\n    working_directory: ${{main_clone}}\n    composition:\n      version: '2'\n      services:\n        app:\n          image: ${{build_image}}\n          ports:\n           - 8080\n    composition_candidates:\n      test_service: \n        image: ${{build_image_with_tests}}\n        links:\n          - app\n        command: bash -c '\/usr\/bin\/wait-for-it.sh -t 20 app:8080 -- mvn verify -Dserver.host=app'\n<\/pre>\n<p>Each Codefresh file contains several top-level steps. The steps defined here are:<\/p>\n<ol>\n<li>Build_image<\/li>\n<li>Build_image_with_tests<\/li>\n<li>Integration_tests<\/li>\n<\/ol>\n<p>The first step just builds our main application (using the multi-stage dockerfile so that is only has Tomcat and the WAR file).<\/p>\n<p>The second step creates a separate image for integration tests. It is similar with the first step, but it just defines another dockerfile. These first two steps are of type <a href=\"https:\/\/codefresh.io\/docs\/docs\/codefresh-yaml\/steps\/build-1\/\">build image<\/a>.<\/p>\n<p>The <a href=\"https:\/\/codefresh.io\/docs\/docs\/codefresh-yaml\/steps\/composition-1\/\">last step<\/a> (which is where the magic happens) does the following:<\/p>\n<ol>\n<li>It launches the first container (with the application) and exposes port 8080. This container is named \u201capp\u201d<\/li>\n<li>It launches the second container with the integration tests. The containers have network connectivity between them and the application one is running on a hostname called \u201capp\u201d<\/li>\n<li>We call the wait-for-it script to account for the tomcat startup time (if you have worked with docker compose locally this should be familiar to you).<\/li>\n<li>Once tomcat is up, the integration tests are running using <strong>mvn verify<\/strong>. Notice that the integration tests are \u201c<a href=\"https:\/\/github.com\/kostis-codefresh\/docker-maven-comparison\/blob\/master\/04-codefresh\/src\/test\/groovy\/com\/codepipes\/wizard\/HomePageSpec.groovy#L43\">targetable<\/a>\u201d and can work either with localhost or with another hostname<\/li>\n<\/ol>\n<p><img class=\"alignnone size-full wp-image-9152\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/06\/codefresh-composition.png\" alt=\"\" width=\"800\" height=\"601\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/06\/codefresh-composition.png 800w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/06\/codefresh-composition-300x225.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/06\/codefresh-composition-768x577.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/06\/codefresh-composition-437x328.png 437w\" sizes=\"(max-width: 800px) 100vw, 800px\" \/><\/p>\n<p>That\u2019s it! The whole pipeline will succeed if everything goes well. If the unit tests fail or if the integration tests fail, or even if a Docker build fails the whole pipeline will stop with an error.<\/p>\n<p><img class=\"alignnone size-large wp-image-9153\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/06\/integration-tests.png\" alt=\"\" width=\"912\" height=\"770\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/06\/integration-tests.png 912w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/06\/integration-tests-300x253.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/06\/integration-tests-768x648.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/06\/integration-tests-388x328.png 388w\" sizes=\"(max-width: 912px) 100vw, 912px\" \/><\/p>\n<p>All steps are visible in Codefresh with individual logs so it is easy to understand which step does what.<\/p>\n<h2>Conclusion<\/h2>\n<p>Even though we started this article with Maven plugins for Docker, I hope that you can see that multi-stage builds where Docker is controlling Maven (and not the other way around) is a good alternative to the traditional way of Maven plugins:<\/p>\n<ul>\n<li>They make our application resilient against Docker API changes<\/li>\n<li>There is no need for special Maven plugins anymore<\/li>\n<li>It makes the build self-contained. No developer tools are needed on the build machine<\/li>\n<li>It makes the setup of build slaves super easy (only Docker is needed)<\/li>\n<li>Your operations team will love you, especially if they have to deal with languages other than Java<\/li>\n<li>It is very easy to setup CI\/CD if you follow the Docker paradigm. And with <a href=\"https:\/\/codefresh.io\/features\/\">Codefresh<\/a> it is very easy to run integration tests as well.<\/li>\n<\/ul>\n<p>That does not mean that traditional Maven plugins do not have their place. In fact, even multi-stage Docker builds have their own challenges (with regards to caching) and this is why in a future article, we will explore how to work with Maven caching and multi-stage builds.<\/p>\n<p>Ready to try Codefresh, the CI\/CD platform for Docker\/Kubernetes\/Helm? ? <a href=\"https:\/\/codefresh.io\/codefresh-signup\/?utm_source=Blog&amp;utm_medium=Post&amp;utm_campaign=MavenB\">Create Your Free Account Today! <\/a><\/p>\n<input class=\"fooboxshare_post_id\" type=\"hidden\" value=\"9142\"\/>","protected":false},"excerpt":{"rendered":"<p>Update: July 5 After publishing this post we got an extensive response from Roland Huss maintainer of the fabric8 plugin, both as a comment here and at his blog We updated the article to address some of his concerns, and also responded in the comments. Even though containers have changed the way an application is &hellip; <a href=\"https:\/\/codefresh.io\/howtos\/using-docker-maven-maven-docker\/\">Read more<\/a><\/p>\n","protected":false},"author":62,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[8,6],"tags":[14,24,49,59,86,87],"yoast_head":"<!-- This site is optimized with the Yoast SEO Premium plugin v17.9 (Yoast SEO v18.4.1) - https:\/\/yoast.com\/wordpress\/plugins\/seo\/ -->\n<title>Using Docker from Maven and Maven from Docker<\/title>\n<meta name=\"description\" content=\"It is true that several Docker advantages are not that impressive to Java developers, but that does not mean that developing Java applications with Docker is necessarily a complex thing?\" \/>\n<meta name=\"robots\" content=\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\" \/>\n<link rel=\"canonical\" href=\"https:\/\/codefresh.io\/howtos\/using-docker-maven-maven-docker\/\" \/>\n<meta property=\"og:locale\" content=\"en_US\" \/>\n<meta property=\"og:type\" content=\"article\" \/>\n<meta property=\"og:title\" content=\"Using Docker from Maven and Maven from Docker\" \/>\n<meta property=\"og:description\" content=\"It is true that several Docker advantages are not that impressive to Java developers, but that does not mean that developing Java applications with Docker is necessarily a complex thing?\" \/>\n<meta property=\"og:url\" content=\"https:\/\/codefresh.io\/howtos\/using-docker-maven-maven-docker\/\" \/>\n<meta property=\"og:site_name\" content=\"Codefresh\" \/>\n<meta property=\"article:publisher\" content=\"https:\/\/www.facebook.com\/codefresh.io\" \/>\n<meta property=\"article:published_time\" content=\"2018-06-20T20:33:27+00:00\" \/>\n<meta property=\"article:modified_time\" content=\"2019-04-18T01:59:22+00:00\" \/>\n<meta property=\"og:image\" content=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/06\/docker-plus-maven.jpg\" \/>\n<meta name=\"twitter:card\" content=\"summary_large_image\" \/>\n<meta name=\"twitter:creator\" content=\"@codefresh\" \/>\n<meta name=\"twitter:site\" content=\"@codefresh\" \/>\n<meta name=\"twitter:label1\" content=\"Written by\" \/>\n\t<meta name=\"twitter:data1\" content=\"Kostis Kapelonis\" \/>\n\t<meta name=\"twitter:label2\" content=\"Est. reading time\" \/>\n\t<meta name=\"twitter:data2\" content=\"20 minutes\" \/>\n<script type=\"application\/ld+json\" class=\"yoast-schema-graph\">{\"@context\":\"https:\/\/schema.org\",\"@graph\":[{\"@type\":\"Organization\",\"@id\":\"https:\/\/codefresh.io\/#organization\",\"name\":\"Codefresh\",\"url\":\"https:\/\/codefresh.io\/\",\"sameAs\":[\"https:\/\/www.facebook.com\/codefresh.io\",\"https:\/\/www.linkedin.com\/company\/codefresh\",\"https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg\",\"https:\/\/twitter.com\/codefresh\"],\"logo\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#logo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"width\":800,\"height\":800,\"caption\":\"Codefresh\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/#logo\"}},{\"@type\":\"WebSite\",\"@id\":\"https:\/\/codefresh.io\/#website\",\"url\":\"https:\/\/codefresh.io\/\",\"name\":\"Codefresh\",\"description\":\"\",\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"potentialAction\":[{\"@type\":\"SearchAction\",\"target\":{\"@type\":\"EntryPoint\",\"urlTemplate\":\"https:\/\/codefresh.io\/?s={search_term_string}\"},\"query-input\":\"required name=search_term_string\"}],\"inLanguage\":\"en-US\"},{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/howtos\/using-docker-maven-maven-docker\/#primaryimage\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/06\/docker-plus-maven.jpg\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/06\/docker-plus-maven.jpg\",\"width\":800,\"height\":410},{\"@type\":\"WebPage\",\"@id\":\"https:\/\/codefresh.io\/howtos\/using-docker-maven-maven-docker\/#webpage\",\"url\":\"https:\/\/codefresh.io\/howtos\/using-docker-maven-maven-docker\/\",\"name\":\"Using Docker from Maven and Maven from Docker\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/#website\"},\"primaryImageOfPage\":{\"@id\":\"https:\/\/codefresh.io\/howtos\/using-docker-maven-maven-docker\/#primaryimage\"},\"datePublished\":\"2018-06-20T20:33:27+00:00\",\"dateModified\":\"2019-04-18T01:59:22+00:00\",\"description\":\"It is true that several Docker advantages are not that impressive to Java developers, but that does not mean that developing Java applications with Docker is necessarily a complex thing?\",\"breadcrumb\":{\"@id\":\"https:\/\/codefresh.io\/howtos\/using-docker-maven-maven-docker\/#breadcrumb\"},\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"ReadAction\",\"target\":[\"https:\/\/codefresh.io\/howtos\/using-docker-maven-maven-docker\/\"]}]},{\"@type\":\"BreadcrumbList\",\"@id\":\"https:\/\/codefresh.io\/howtos\/using-docker-maven-maven-docker\/#breadcrumb\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"name\":\"Home\",\"item\":\"https:\/\/codefresh.io\/\"},{\"@type\":\"ListItem\",\"position\":2,\"name\":\"Using Docker from Maven and Maven from Docker\"}]},{\"@type\":\"Article\",\"@id\":\"https:\/\/codefresh.io\/howtos\/using-docker-maven-maven-docker\/#article\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/howtos\/using-docker-maven-maven-docker\/#webpage\"},\"author\":{\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87\"},\"headline\":\"Using Docker from Maven and Maven from Docker\",\"datePublished\":\"2018-06-20T20:33:27+00:00\",\"dateModified\":\"2019-04-18T01:59:22+00:00\",\"mainEntityOfPage\":{\"@id\":\"https:\/\/codefresh.io\/howtos\/using-docker-maven-maven-docker\/#webpage\"},\"wordCount\":3434,\"commentCount\":20,\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/howtos\/using-docker-maven-maven-docker\/#primaryimage\"},\"thumbnailUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/06\/docker-plus-maven.jpg\",\"keywords\":[\"docker\",\"Containers\",\"test automation\",\"codefresh\",\"java\",\"maven\"],\"articleSection\":[\"Docker Tutorials\",\"How Tos\"],\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"CommentAction\",\"name\":\"Comment\",\"target\":[\"https:\/\/codefresh.io\/howtos\/using-docker-maven-maven-docker\/#respond\"]}]},{\"@type\":\"Person\",\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87\",\"name\":\"Kostis Kapelonis\",\"image\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#personlogo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png\",\"caption\":\"Kostis Kapelonis\"},\"description\":\"Kostis is a software engineer\/technical-writer dual class character. He lives and breathes automation, good testing practices and stress-free deployments with GitOps.\",\"url\":\"https:\/\/codefresh.io\/author\/kostiscodefresh-io\/\"}]}<\/script>\n<!-- \/ Yoast SEO Premium plugin. -->","yoast_head_json":{"title":"Using Docker from Maven and Maven from Docker","description":"It is true that several Docker advantages are not that impressive to Java developers, but that does not mean that developing Java applications with Docker is necessarily a complex thing?","robots":{"index":"index","follow":"follow","max-snippet":"max-snippet:-1","max-image-preview":"max-image-preview:large","max-video-preview":"max-video-preview:-1"},"canonical":"https:\/\/codefresh.io\/howtos\/using-docker-maven-maven-docker\/","og_locale":"en_US","og_type":"article","og_title":"Using Docker from Maven and Maven from Docker","og_description":"It is true that several Docker advantages are not that impressive to Java developers, but that does not mean that developing Java applications with Docker is necessarily a complex thing?","og_url":"https:\/\/codefresh.io\/howtos\/using-docker-maven-maven-docker\/","og_site_name":"Codefresh","article_publisher":"https:\/\/www.facebook.com\/codefresh.io","article_published_time":"2018-06-20T20:33:27+00:00","article_modified_time":"2019-04-18T01:59:22+00:00","og_image":[{"url":"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/06\/docker-plus-maven.jpg"}],"twitter_card":"summary_large_image","twitter_creator":"@codefresh","twitter_site":"@codefresh","twitter_misc":{"Written by":"Kostis Kapelonis","Est. reading time":"20 minutes"},"schema":{"@context":"https:\/\/schema.org","@graph":[{"@type":"Organization","@id":"https:\/\/codefresh.io\/#organization","name":"Codefresh","url":"https:\/\/codefresh.io\/","sameAs":["https:\/\/www.facebook.com\/codefresh.io","https:\/\/www.linkedin.com\/company\/codefresh","https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg","https:\/\/twitter.com\/codefresh"],"logo":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#logo","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","width":800,"height":800,"caption":"Codefresh"},"image":{"@id":"https:\/\/codefresh.io\/#logo"}},{"@type":"WebSite","@id":"https:\/\/codefresh.io\/#website","url":"https:\/\/codefresh.io\/","name":"Codefresh","description":"","publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"potentialAction":[{"@type":"SearchAction","target":{"@type":"EntryPoint","urlTemplate":"https:\/\/codefresh.io\/?s={search_term_string}"},"query-input":"required name=search_term_string"}],"inLanguage":"en-US"},{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/howtos\/using-docker-maven-maven-docker\/#primaryimage","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/06\/docker-plus-maven.jpg","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/06\/docker-plus-maven.jpg","width":800,"height":410},{"@type":"WebPage","@id":"https:\/\/codefresh.io\/howtos\/using-docker-maven-maven-docker\/#webpage","url":"https:\/\/codefresh.io\/howtos\/using-docker-maven-maven-docker\/","name":"Using Docker from Maven and Maven from Docker","isPartOf":{"@id":"https:\/\/codefresh.io\/#website"},"primaryImageOfPage":{"@id":"https:\/\/codefresh.io\/howtos\/using-docker-maven-maven-docker\/#primaryimage"},"datePublished":"2018-06-20T20:33:27+00:00","dateModified":"2019-04-18T01:59:22+00:00","description":"It is true that several Docker advantages are not that impressive to Java developers, but that does not mean that developing Java applications with Docker is necessarily a complex thing?","breadcrumb":{"@id":"https:\/\/codefresh.io\/howtos\/using-docker-maven-maven-docker\/#breadcrumb"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https:\/\/codefresh.io\/howtos\/using-docker-maven-maven-docker\/"]}]},{"@type":"BreadcrumbList","@id":"https:\/\/codefresh.io\/howtos\/using-docker-maven-maven-docker\/#breadcrumb","itemListElement":[{"@type":"ListItem","position":1,"name":"Home","item":"https:\/\/codefresh.io\/"},{"@type":"ListItem","position":2,"name":"Using Docker from Maven and Maven from Docker"}]},{"@type":"Article","@id":"https:\/\/codefresh.io\/howtos\/using-docker-maven-maven-docker\/#article","isPartOf":{"@id":"https:\/\/codefresh.io\/howtos\/using-docker-maven-maven-docker\/#webpage"},"author":{"@id":"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87"},"headline":"Using Docker from Maven and Maven from Docker","datePublished":"2018-06-20T20:33:27+00:00","dateModified":"2019-04-18T01:59:22+00:00","mainEntityOfPage":{"@id":"https:\/\/codefresh.io\/howtos\/using-docker-maven-maven-docker\/#webpage"},"wordCount":3434,"commentCount":20,"publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"image":{"@id":"https:\/\/codefresh.io\/howtos\/using-docker-maven-maven-docker\/#primaryimage"},"thumbnailUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/06\/docker-plus-maven.jpg","keywords":["docker","Containers","test automation","codefresh","java","maven"],"articleSection":["Docker Tutorials","How Tos"],"inLanguage":"en-US","potentialAction":[{"@type":"CommentAction","name":"Comment","target":["https:\/\/codefresh.io\/howtos\/using-docker-maven-maven-docker\/#respond"]}]},{"@type":"Person","@id":"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87","name":"Kostis Kapelonis","image":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#personlogo","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png","caption":"Kostis Kapelonis"},"description":"Kostis is a software engineer\/technical-writer dual class character. He lives and breathes automation, good testing practices and stress-free deployments with GitOps.","url":"https:\/\/codefresh.io\/author\/kostiscodefresh-io\/"}]}},"acf":[],"_links":{"self":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/9142"}],"collection":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/users\/62"}],"replies":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/comments?post=9142"}],"version-history":[{"count":0,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/9142\/revisions"}],"wp:attachment":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media?parent=9142"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/categories?post=9142"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/tags?post=9142"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}