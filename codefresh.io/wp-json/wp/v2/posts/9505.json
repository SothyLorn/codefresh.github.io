{"id":9505,"date":"2018-07-09T14:04:53","date_gmt":"2018-07-09T14:04:53","guid":{"rendered":"http:\/\/codefresh.io\/?p=9505"},"modified":"2022-03-01T17:02:43","modified_gmt":"2022-03-01T17:02:43","slug":"ci-cd-serverless","status":"publish","type":"post","link":"https:\/\/codefresh.io\/continuous-deployment\/serverless\/ci-cd-serverless\/","title":{"rendered":"Production-ready CI\/CD for Serverless Applications"},"content":{"rendered":"<h2>TL;DR<\/h2>\n<blockquote><p>Looking for reusable <em>development<\/em> and <em>production<\/em> CI\/CD pipelines for AWS Lambda (with Serverless Framework)? Just open your Codefresh account and copy two pipelines from this post, provide AWS credentials and configuration and start writing your serverless functions. These CI\/CD pipelines will streamline changes to testing and production environments automatically.<\/p><\/blockquote>\n<h2>Motivation<\/h2>\n<p>Microservice architecture plays a major role in many organizations today. The adoption of microservice architecture has grown significantly in the last few years. Docker containers and container cluster technologies, like Kubernetes and Swarm, simplified adoption of microservices, especially the way they are packaged and deployed. Still, when you are using containers to develop and deploy your microservices, there is an additional price you have to pay: you still need to know containers and container clusters pretty well and keep this knowledge up to date.<\/p>\n<p>On the other hand, with serverless technologies, you care less about the deployment and operation of driverless applications. For this and other reasons, serverless technologies like function as a service (FaaS) became widely used by many companies. A serverless architecture provides an additional and more granular way to implement microservices, spending less effort on developing, running, and scaling individual microservices.<\/p>\n<p>When a company selects a serverless architecture to implement microservices, there is still a need to define how to manage serverless code, and how to build scalable, fast and effective CI\/CD pipelines.<\/p>\n<h2>Managing Serverless code<\/h2>\n<p>In serverless architecture, there is usually a single event handler function. There may also be additional helper functions and imported libraries.<\/p>\n<p>This function should follow the <a href=\"https:\/\/en.wikipedia.org\/wiki\/Single_responsibility_principle\">single responsibility principle<\/a>. And if it does, one should not expect to find unreasonably long functions with thousands of lines of code.<\/p>\n<p>Besides a function code, there is also a need to define a function deployment configuration that can include additional resources, permissions, and endpoints. For AWS Lambda function, it could be a CloudFormation template that configures multiple AWS services like S3, IAM, DynamoDB, API, Gateway, and others.<\/p>\n<h2>Mono repositories<\/h2>\n<p>One approach of managing multiple serverless microservices is to put all of them into a single code repository, also called a &#8220;mono repository&#8221;. While this can simplify code management and encourage sharing, it can also create undesired coupling between different services and force non-effective CI\/CD.<\/p>\n<p>Once you commit a code to a mono repository, most existing CI\/CD tools cannot distinguish what had been changed and thus do a full rebuild, test, and deploy for all services in this mono repository. This makes the whole process of CI\/CD highly ineffective and very slow.<\/p>\n<p>If you select a mono repository for code management, make sure to search for a CI\/CD tool that can natively support mono repositories (i.e. can understand the essence of change and can run CI\/CD only for modified services, skipping unchanged services).<\/p>\n<h2>Micro repositories<\/h2>\n<p>Another approach is to keep each service in its own code repository. I will call this approach &#8220;micro repository&#8221;, similar to microservice. The idea is that each of these repositories is pretty small, containing one function, configuration, and required dependency. You should also expect that there will not be too many changes for micro repositories, once code matures.<\/p>\n<p>When you modify one service code, it does not affect all other services. But when you have to update multiple services to implement one feature, you are forced to work with multiple repositories and multiple branches, which can be large, challenging cross-cutting changes (hopefully they are not frequent). When you see a lot of cross-cutting changes, this can also mean that you have the wrong microservice architecture and there is a strong coupling between multiple services.<\/p>\n<p>As for CI\/CD, on one hand, it is easier using familiar processes and defining a pipeline for each repository. On the other hand, when you have too many repositories and CI\/CD pipeline code is almost of the same size as a serverless function code, maintaining hundreds of almost identical CI\/CD pipelines can quickly become a challenge.<\/p>\n<p>So, when you practice a micro repository approach, select a CI\/CD tool that either has a short and simple DSL for describing CI\/CD for serverless and\/or can support pipeline reuse, using the same pipeline for multiple micro repositories.<\/p>\n<h2>Hybrid repositories<\/h2>\n<p>In practice, you should choose a hybrid approach, grouping multiple serverless services from the same or adjacent domain into the same code repository. Once, you do this, there is a chance that cross-cutting change will happen within a single repository.<\/p>\n<h2>Tools and Services<\/h2>\n<h2>Serverless Framework<\/h2>\n<p>The <a href=\"https:\/\/serverless.com\/framework\">Serverless Framework<\/a> supports building and deploying a serverless application to multiple cloud providers with a consistent experience, hiding provider differences. The Serverless Framework automatically configures cloud vendor settings, based on the used language and the target cloud provider. For example, it creates a CloudFormation template when you are using an AWS Lambda provider.<\/p>\n<p>There are other similar tools, but the Serverless Framework is one of the most popular tools with a big community around it.<\/p>\n<h2>Serverless-friendly CI\/CD<\/h2>\n<p>Choose a CI\/CD tool that either has a built-in integration with a desired serverless platform (or cloud platform) or one that can easily be extended. This tool should also be able to support both mono repositories (understand change at a service level) and micro repositories (allow reuse of pipelines across multiple repositories).<\/p>\n<p>Give Codefresh CI\/CD a try. It has native support for any code management strategy you will choose.<\/p>\n<p>Codefresh <a href=\"https:\/\/codefresh.io\/codefresh-news\/using-codefresh-with-mono-repos\/\">supports mono repositories<\/a> allowing you to execute pipelines based on commit content, using <a href=\"https:\/\/en.wikipedia.org\/wiki\/Glob_(programming)\">glob<\/a> patterns to detect changed services. Codefresh also supports pipeline reuse, where you can connect the same CI\/CD pipeline to multiple non-related code repositories.<\/p>\n<p>Each serverless platform\/framework has its own syntax and tools to simplify development, deployment, and testing of serverless function. The CI\/CD platform you choose should allow you to effectively use your tool of choice.<\/p>\n<p>Being a Docker-centric CI\/CD service with first-class Kubernetes integration, Codefresh runs every pipeline step within a Docker container. This provides both great isolation between pipeline steps\u00a0and makes it easy to bring in your own tool. We&#8217;ve prepared a reusable <a href=\"https:\/\/hub.docker.com\/r\/codefresh\/serverless\/\">Docker image<\/a> with Serverless Framework on board.<\/p>\n<h2>Testing Serverless applications<\/h2>\n<p>Writing serverless applications can simplify business logic development, but can also be hard to test. First, if your serverless service depends on external cloud services or event providers, it can be challenging to emulate in order to run tests locally. There is also still a need to run real integration tests anyway.<\/p>\n<h2>Unit testing<\/h2>\n<p>To get around these challenges, try to write a testable code. Abstract any external resources and APIs you are using in serverless function with a clean interface and write stubs for these abstractions. Avoid writing platform-specific code: code that can be executed only inside the specific serverless platform. Write a main serverless function in a generic way and wrap it with a platform-specific function that does not contain any logic and just serves as a binder between platform specific code and your function.<\/p>\n<p>If you can write tests for your serverless function, achieving full coverage, and can execute these tests in a single process with a testing framework only, then you did a great job writing testable code.<\/p>\n<p>Also consider using static code analysis tools, linters, and security scanners to eliminate more potential issues.<\/p>\n<h2>Integration testing<\/h2>\n<p>While unit testing is must, it&#8217;s not sufficient to rely only on it on its own. You have to test a serverless function in a real battlefield. Create a real dedicated testing environment, trigger an expected event and analyze function flow, performance, and resource usage. Free unneeded resources once you complete integration testing.<\/p>\n<h2>Acceptance testing<\/h2>\n<p>Acceptance testing is a non-destructive flavor of integration testing. Run acceptance tests to validate a new deployment to <em>production<\/em> environment. Rollback if acceptance tests fail.<\/p>\n<h2>Codefresh CI\/CD pipelines<\/h2>\n<h2>Development CI\/CD pipeline<\/h2>\n<p>The following pipeline defines a CI\/CD flow for any <em>development<\/em> <code>branch<\/code>.<\/p>\n<p><img class=\"aligncenter size-full wp-image-9508\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/serverless-develop.png\" alt=\"\" width=\"1565\" height=\"381\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/serverless-develop.png 1565w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/serverless-develop-300x73.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/serverless-develop-768x187.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/serverless-develop-1024x249.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/serverless-develop-628x153.png 628w\" sizes=\"(max-width: 1565px) 100vw, 1565px\" \/><\/p>\n<h3>The Flow<\/h3>\n<h4>1. Trigger<\/h4>\n<p>The pipeline is triggered when a developer pushes a new change to a <em>development<\/em> branch. The first implicit action taken by the pipeline is <code>git clone<\/code> command.<br \/>\nThen, the pipeline should get two contexts for proper execution:<\/p>\n<ol>\n<li><strong>commit context<\/strong> &#8211; <code>commit<\/code> details (commit id, branch, modified files, etc.)<\/li>\n<li><strong>environment context<\/strong> &#8211; secrets, configurations, etc. (auto-select this context based on active branch)<\/li>\n<\/ol>\n<h4>2. Unit Test<\/h4>\n<p>This is a basic code validation step. In this step, the pipeline executes unit tests, linters, and static code analysis.<\/p>\n<h4>3. Setup<\/h4>\n<p>Working with a serverless cloud provider like Amazon AWS Lambda requires configuring credentials and target runtime environments. Consider using a separate AWS account and region for test and production environments.<\/p>\n<p>One approach to setup credentials is to use a shared <a href=\"https:\/\/docs.aws.amazon.com\/cli\/latest\/userguide\/cli-config-files.html\">credentials file<\/a> with two profiles: <code>develop<\/code> and <code>production<\/code>.<\/p>\n<p>In order to make this file available for Codefresh CI\/CD pipeline, you need to perform the following:<\/p>\n<ol>\n<li>Encode <code>~\/.aws\/credentials<\/code> (assuming this is the file you want to use) with <code>base64<\/code> encoding without <code>new line<\/code> characters: <code>cat ~\/.aws\/credentials | openssl base64 -A<\/code><\/li>\n<li>Create <strong>encrypted<\/strong> <code>AWS_CREDENTIALS_FILE<\/code> Codefresh variable with encoded content of AWS credentials file<\/li>\n<li>Recreate credentials file with <code>echo -n $AWS_CREDENTIALS_FILE | base64 -d &amp;gt; ${PWD}\/.aws\/credentials<\/code> command<\/li>\n<li>Make AWS credentials file available for all <code>aws<\/code> CLI commands, pointing <code>AWS_SHARED_CREDENTIALS_FILE<\/code> to the file location, with <code>cf_export AWS_SHARED_CREDENTIALS_FILE=${PWD}\/.aws\/credentials<\/code> command<\/li>\n<\/ol>\n<h4>4. Package<\/h4>\n<p>The <code>serverless package<\/code> command packages the entire AWS Lambda infrastructure into the <code>.serverless.develop<\/code> directory by default and make it ready for deployment. It is possible to specify another packaging directory by passing the <code>--package<\/code> option.<\/p>\n<p>It is a good idea to create a deployment package and archive it for future use and\/or traceability.<\/p>\n<h4>5. Deploy<\/h4>\n<p>The <code>serverless deploy --package<\/code> command deploys entire service via CloudFormation, using previously prepared <em>package<\/em> to a test environment.<\/p>\n<h4>6. Integration Test<\/h4>\n<p>In order to run integration tests, you need to create the event that triggers the AWS Lambda function execution. It&#8217;s possible to use <code>aws<\/code> CLI\/API to create a required event, or <code>serverless invoke<\/code> command, passing <em>event<\/em> and <em>context<\/em> as command parameters.<\/p>\n<p>If integration tests complete without failures, the pipeline creates a new <code>PullRequest<\/code> from the current <em>development<\/em> branch. Once merged (manually or automatically), this <code>PullRequest<\/code> will trigger the <code>production<\/code> CI\/CD pipeline.<\/p>\n<h4>7. Cleanup<\/h4>\n<p>To reduce charges, it&#8217;s better to clean up all allocated AWS resources, regardless of integration tests status. The <code>serverless remove<\/code> command can do the required cleanup.<\/p>\n<h3>Codefresh <em>develop<\/em> CI\/CD pipeline: <code>develop.yaml<\/code><\/h3>\n<pre>version: '1.0'\r\n\r\nsteps:\r\n\r\n  check_master:\r\n    image: alpine:3.7\r\n    title: fail on master branch\r\n    commands:\r\n      - echo \"cannot run this pipeline on master\"\r\n      - exit 1\r\n    when:\r\n      branch:\r\n        only:\r\n          - master\r\n\r\n  setup:\r\n    image: alpine:3.7\r\n    title: generate AWS shared credentials file\r\n    commands:\r\n      - mkdir -p .aws\r\n      - echo -n $AWS_CREDENTIALS_FILE | base64 -d &gt; ${PWD}\/.aws\/credentials\r\n      - cf_export AWS_SHARED_CREDENTIALS_FILE=${PWD}\/.aws\/credentials\r\n\r\n  test:\r\n    image: node:10-alpine\r\n    title: lint and test\r\n    working_directory: ${{main_clone}}\/examples\/aws-node-simple-http-endpoint\r\n    commands:\r\n      - yarn lint\r\n      - yarn test\r\n\r\n  package:\r\n    image: codefresh\/serverless:1.28\r\n    title: package serverless service\r\n    working_directory: ${{main_clone}}\/examples\/aws-node-simple-http-endpoint\r\n    commands:\r\n      - serverless package --stage ${AWS_STAGE} --region ${AWS_REGION} --package ${PACKAGE}\r\n\r\n  archive:\r\n    image: mesosphere\/aws-cli\r\n    title: archive package to S3 bucket\r\n    working_directory: ${{main_clone}}\/examples\/aws-node-simple-http-endpoint\r\n    commands:\r\n      - aws --profile ${AWS_PROFILE} --region ${AWS_REGION} s3 cp ${PACKAGE} s3:\/\/${AWS_BUCKET}\/${{CF_BRANCH}}\/${{CF_SHORT_REVISION}}\/ --recursive\r\n\r\n  deploy:\r\n    image: codefresh\/serverless:1.28\r\n    title: deploy to AWS with serverless framework\r\n    working_directory: ${{main_clone}}\/examples\/aws-node-simple-http-endpoint\r\n    commands:\r\n      - serverless deploy --conceal --verbose --stage ${AWS_STAGE} --region ${AWS_REGION} --aws-profile ${AWS_PROFILE} --package ${PACKAGE}\r\n\r\n  integration:\r\n    image: codefresh\/serverless:1.28\r\n    title: run integration test\r\n    working_directory: ${{main_clone}}\/examples\/aws-node-simple-http-endpoint\r\n    fail_fast: false\r\n    commands:\r\n      - serverless invoke --function currentTime --stage ${AWS_STAGE} --region ${AWS_REGION} --path test\/data.json &amp;&amp; cf_export INTEGRATION_FAILED=false || cf_export INTEGRATION_FAILED=true\r\n\r\n  rollback:\r\n    image: codefresh\/serverless:1.28\r\n    title: rollback if integration test failed\r\n    working_directory: ${{main_clone}}\/examples\/aws-node-simple-http-endpoint\r\n    commands:\r\n      - ${INTEGRATION_FAILED} &amp;&amp; echo \"rollback to previous version on error\" || true\r\n      - ${INTEGRATION_FAILED} &amp;&amp; if [ ! -z \"${KEEP_VERSION}\" ]; then serverless rollback --verbose --timestamp ${KEEP_VERSION} --region ${AWS_REGION} --stage ${AWS_STAGE} --aws-profile ${AWS_PROFILE}; fi || true\r\n\r\n  cleanup:\r\n    image: codefresh\/serverless:1.28\r\n    title: cleanup allocated resources\r\n    working_directory: ${{main_clone}}\/examples\/aws-node-simple-http-endpoint\r\n    commands:\r\n      - serverless remove --verbose --region ${AWS_REGION} --stage ${AWS_STAGE} --aws-profile ${AWS_PROFILE}\r\n\r\n  release_pull_request:\r\n    image: codefresh\/serverless:1.28\r\n    title: create a pull-request for release, if integration tests passed\r\n    working_directory: ${{main_clone}}\/examples\/aws-node-simple-http-endpoint\r\n    commands:\r\n      - if [ ${INTEGRATION_FAILED} == false ]; curl -H 'Authorization: token ${GITHUB_TOKEN}' -d '{\"title\":\"release of ${{CF_BRANCH}}\",\"base\":\"master\", \"head\":\"${{CF_BRANCH}}\"}' https:\/\/api.github.com\/repos\/${{CF_REPO_OWNER}}\/${{CF_REPO_NAME}}\/pulls; fi\r\n\r\n  decide_on_status:\r\n    image: alpine:3.7\r\n    title: decide on pipeline status\r\n    commands:\r\n      - if [ ${INTEGRATION_FAILED} == true ]; then echo \"integration tests failed\" &amp;&amp; exit 1; fi\r\n\r\n<\/pre>\n<p>If you want to achieve <em>Continuous Deployment<\/em>, you can also automate the merge of <code>Pull Request<\/code> and thus trigger a CI\/CD pipeline for the <strong>production<\/strong> environment.<\/p>\n<h2>Production CI\/CD pipeline<\/h2>\n<p><img class=\"aligncenter size-full wp-image-9507\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/serverless-production.png\" alt=\"\" width=\"1445\" height=\"371\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/serverless-production.png 1445w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/serverless-production-300x77.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/serverless-production-768x197.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/serverless-production-1024x263.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/serverless-production-628x161.png 628w\" sizes=\"(max-width: 1445px) 100vw, 1445px\" \/><\/p>\n<h3>The Flow<\/h3>\n<h4>1. Trigger<\/h4>\n<p>The <em>production<\/em> pipeline is triggered when a <code>PullRequest<\/code> is merged from some <em>development<\/em> branch. If you automate the <code>merge<\/code> process, you will be able to achieve <em>Continuous Deployment<\/em><\/p>\n<p>The first implicit action taken by the pipeline is the <code>git clone<\/code> command.<br \/>\nThen, the pipeline should get two contexts for proper execution:<\/p>\n<ol>\n<li><strong>commit context<\/strong> &#8211; <code>commit<\/code> details (commit id, <code>master<\/code> branch, modified files, etc.)<\/li>\n<li><strong>environment context<\/strong> &#8211; secrets, configurations, etc. for <code>production<\/code> environment<\/li>\n<\/ol>\n<h4>2. Unit Test<\/h4>\n<p>This is a basic code validation step. In this step, the pipeline executes unit tests, linters, and static code analysis. It&#8217;s possible to skip this step.<\/p>\n<h4>3. Setup<\/h4>\n<p>This step is exactly the same step as in the <em>development<\/em> CI\/CD pipeline. You will need to configure AWS credentials and specify the target environment (region, stage, etc.).<\/p>\n<p><img class=\"aligncenter size-full wp-image-9524\" src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/Screen-Shot-2018-07-05-at-11.32.31.png\" alt=\"\" width=\"2822\" height=\"1048\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/Screen-Shot-2018-07-05-at-11.32.31.png 2822w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/Screen-Shot-2018-07-05-at-11.32.31-300x111.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/Screen-Shot-2018-07-05-at-11.32.31-768x285.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/Screen-Shot-2018-07-05-at-11.32.31-1024x380.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/Screen-Shot-2018-07-05-at-11.32.31-628x233.png 628w\" sizes=\"(max-width: 2822px) 100vw, 2822px\" \/><\/p>\n<h4>4. Package<\/h4>\n<p>The <code>serverless package<\/code> command packages the entire AWS Lambda infrastructure into the <code>.serverless.production<\/code> directory by default and make it ready for deployment. It is possible to specify another packaging directory by passing the <code>--package<\/code> option.<\/p>\n<p>It is a good idea to create a deployment package and archive it for future use and\/or traceability.<\/p>\n<h4>5. Deploy<\/h4>\n<p>The <code>serverless deploy --package<\/code> command deploys the entire service via CloudFormation, using the previously prepared <em>package<\/em> to a test environment.<\/p>\n<h4>6. Acceptance Tests<\/h4>\n<p>In this step, run non-destructive acceptance tests mainly. These can be integration tests from a <em>development<\/em> pipeline or different acceptance tests.<\/p>\n<p>If acceptance tests complete with failures, the pipeline will <strong>rollback<\/strong> the deployment to the <em>previous<\/em> working version.<\/p>\n<h3>Codefresh <em>production<\/em> CI\/CD pipeline: <code>production.yaml<\/code><\/h3>\n<pre>version: '1.0'\r\n\r\nsteps:\r\n\r\n  check_non_master:\r\n    image: alpine:3.7\r\n    title: fail on master branch\r\n    commands:\r\n      - echo \"cannot run this pipeline on non-master\"\r\n      - exit 1\r\n    when:\r\n      branch:\r\n        ignore:\r\n          - master\r\n\r\n  setup:\r\n    image: alpine:3.7\r\n    title: generate AWS shared credentials file\r\n    commands:\r\n      - mkdir -p .aws\r\n      - echo -n $AWS_CREDENTIALS_FILE | base64 -d &gt; ${PWD}\/.aws\/credentials\r\n      - cf_export AWS_SHARED_CREDENTIALS_FILE=${PWD}\/.aws\/credentials\r\n\r\n  test:\r\n    image: node:10-alpine\r\n    title: lint and test\r\n    working_directory: ${{main_clone}}\/examples\/aws-node-simple-http-endpoint\r\n    commands:\r\n      - yarn lint\r\n      - yarn test\r\n\r\n  package:\r\n    image: codefresh\/serverless:1.28\r\n    title: package serverless service\r\n    working_directory: ${{main_clone}}\/examples\/aws-node-simple-http-endpoint\r\n    commands:\r\n      - serverless package --stage ${AWS_STAGE} --region ${AWS_REGION} --package ${PACKAGE}\r\n\r\n  archive:\r\n    image: mesosphere\/aws-cli\r\n    title: archive package to S3 bucket\r\n    working_directory: ${{main_clone}}\/examples\/aws-node-simple-http-endpoint\r\n    commands:\r\n      - aws --profile ${AWS_PROFILE} --region ${AWS_REGION} s3 cp ${PACKAGE} s3:\/\/${AWS_BUCKET}\/${{CF_BRANCH}}\/${{CF_SHORT_REVISION}}\/ --recursive\r\n\r\n  deploy:\r\n    image: codefresh\/serverless:1.28\r\n    title: deploy to AWS with serverless framework\r\n    working_directory: ${{main_clone}}\/examples\/aws-node-simple-http-endpoint\r\n    commands:\r\n      - KEEP_VERSION=$(serverless deploy list --stage ${AWS_STAGE} --region ${AWS_REGION} | grep Timestamp | tail -1 | awk '{print $3}') || true\r\n      - cf_export KEEP_VERSION=${KEEP_VERSION}\r\n      - serverless deploy --conceal --verbose --stage ${AWS_STAGE} --region ${AWS_REGION} --aws-profile ${AWS_PROFILE} --package ${PACKAGE}\r\n\r\n  acceptance:\r\n    image: codefresh\/serverless:1.28\r\n    title: run acceptance test\r\n    working_directory: ${{main_clone}}\/examples\/aws-node-simple-http-endpoint\r\n    fail_fast: false\r\n    commands:\r\n      - serverless invoke --function currentTime --stage ${AWS_STAGE} --region ${AWS_REGION} --path test\/data.json &amp;&amp; cf_export ACCEPTANCE_FAILED=false || cf_export ACCEPTANCE_FAILED=\"true\"\r\n\r\n  rollback:\r\n    image: codefresh\/serverless:1.28\r\n    title: rollback if acceptance test failed\r\n    working_directory: ${{main_clone}}\/examples\/aws-node-simple-http-endpoint\r\n    commands:\r\n      - ${ACCEPTANCE_FAILED} &amp;&amp; echo \"rollback to previous version on error\" || true\r\n      - ${ACCEPTANCE_FAILED} &amp;&amp; if [ ! -z \"${KEEP_VERSION}\" ]; then serverless rollback --verbose --timestamp ${KEEP_VERSION} --region ${AWS_REGION} --stage ${AWS_STAGE} --aws-profile ${AWS_PROFILE}; fi || true\r\n\r\n  decide_on_status:\r\n    image: alpine:3.7\r\n    title: decide on pipeline status\r\n    commands:\r\n      - if [ ${ACCEPTANCE_FAILED} == true ]; then echo \"acceptance tests failed, rollback to previous version\" &amp;&amp; exit 1; fi\r\n<\/pre>\n<h2>Summary<\/h2>\n<p>Using both Serverless Framework and Codefresh can make it easy to create a highly effective CI\/CD pipelines for serverless applications.<\/p>\n<p>I hope you find this post useful. I look forward to your comments and any questions you have. To try this out, <a href=\"https:\/\/g.codefresh.io\/signup?utm_source=Blog&amp;utm_medium=Post&amp;utm_campaign=Serverless\">create a free Codefresh account<\/a> and start building, testing and deploying Docker images faster than ever.<\/p>\n<p><a href=\"https:\/\/g.codefresh.io\/signup?utm_source=Blog&amp;utm_medium=Post&amp;utm_campaign=Serverless\">Go on and give it a try!<\/a><\/p>\n<input class=\"fooboxshare_post_id\" type=\"hidden\" value=\"9505\"\/>","protected":false},"excerpt":{"rendered":"<p>TL;DR Looking for reusable development and production CI\/CD pipelines for AWS Lambda (with Serverless Framework)? Just open your Codefresh account and copy two pipelines from this post, provide AWS credentials and configuration and start writing your serverless functions. These CI\/CD pipelines will streamline changes to testing and production environments automatically. Motivation Microservice architecture plays a &hellip; <a href=\"https:\/\/codefresh.io\/continuous-deployment\/serverless\/ci-cd-serverless\/\">Read more<\/a><\/p>\n","protected":false},"author":28,"featured_media":20529,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[2983],"tags":[15,52,53,59,65,68,409,2984,2985],"yoast_head":"<!-- This site is optimized with the Yoast SEO Premium plugin v17.9 (Yoast SEO v18.4.1) - https:\/\/yoast.com\/wordpress\/plugins\/seo\/ -->\n<title>Production-ready CI\/CD for Serverless Applications | Codefresh<\/title>\n<meta name=\"description\" content=\"Creating a production-ready CI\/CD pipelines for AWS Lambda serverless application, with Codefresh and Serverless Framework.\" \/>\n<meta name=\"robots\" content=\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\" \/>\n<link rel=\"canonical\" href=\"https:\/\/codefresh.io\/continuous-deployment\/serverless\/ci-cd-serverless\/\" \/>\n<meta property=\"og:locale\" content=\"en_US\" \/>\n<meta property=\"og:type\" content=\"article\" \/>\n<meta property=\"og:title\" content=\"Production-ready CI\/CD for Serverless Applications\" \/>\n<meta property=\"og:description\" content=\"Creating a production-ready CI\/CD pipelines for AWS Lambda serverless application, with Codefresh and Serverless Framework.\" \/>\n<meta property=\"og:url\" content=\"https:\/\/codefresh.io\/continuous-deployment\/serverless\/ci-cd-serverless\/\" \/>\n<meta property=\"og:site_name\" content=\"Codefresh\" \/>\n<meta property=\"article:publisher\" content=\"https:\/\/www.facebook.com\/codefresh.io\" \/>\n<meta property=\"article:published_time\" content=\"2018-07-09T14:04:53+00:00\" \/>\n<meta property=\"article:modified_time\" content=\"2022-03-01T17:02:43+00:00\" \/>\n<meta property=\"og:image\" content=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/computer-workers-alex-kotliarskyi-QBpZGqEMsKg-unsplash-scaled.jpg\" \/>\n\t<meta property=\"og:image:width\" content=\"2560\" \/>\n\t<meta property=\"og:image:height\" content=\"1707\" \/>\n\t<meta property=\"og:image:type\" content=\"image\/jpeg\" \/>\n<meta name=\"twitter:card\" content=\"summary_large_image\" \/>\n<meta name=\"twitter:creator\" content=\"@alexeiled\" \/>\n<meta name=\"twitter:site\" content=\"@codefresh\" \/>\n<meta name=\"twitter:label1\" content=\"Written by\" \/>\n\t<meta name=\"twitter:data1\" content=\"Alexei Ledenev\" \/>\n\t<meta name=\"twitter:label2\" content=\"Est. reading time\" \/>\n\t<meta name=\"twitter:data2\" content=\"12 minutes\" \/>\n<script type=\"application\/ld+json\" class=\"yoast-schema-graph\">{\"@context\":\"https:\/\/schema.org\",\"@graph\":[{\"@type\":\"Organization\",\"@id\":\"https:\/\/codefresh.io\/#organization\",\"name\":\"Codefresh\",\"url\":\"https:\/\/codefresh.io\/\",\"sameAs\":[\"https:\/\/www.facebook.com\/codefresh.io\",\"https:\/\/www.linkedin.com\/company\/codefresh\",\"https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg\",\"https:\/\/twitter.com\/codefresh\"],\"logo\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#logo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"width\":800,\"height\":800,\"caption\":\"Codefresh\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/#logo\"}},{\"@type\":\"WebSite\",\"@id\":\"https:\/\/codefresh.io\/#website\",\"url\":\"https:\/\/codefresh.io\/\",\"name\":\"Codefresh\",\"description\":\"\",\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"potentialAction\":[{\"@type\":\"SearchAction\",\"target\":{\"@type\":\"EntryPoint\",\"urlTemplate\":\"https:\/\/codefresh.io\/?s={search_term_string}\"},\"query-input\":\"required name=search_term_string\"}],\"inLanguage\":\"en-US\"},{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/continuous-deployment\/serverless\/ci-cd-serverless\/#primaryimage\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/computer-workers-alex-kotliarskyi-QBpZGqEMsKg-unsplash-scaled.jpg\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/computer-workers-alex-kotliarskyi-QBpZGqEMsKg-unsplash-scaled.jpg\",\"width\":2560,\"height\":1707},{\"@type\":\"WebPage\",\"@id\":\"https:\/\/codefresh.io\/continuous-deployment\/serverless\/ci-cd-serverless\/#webpage\",\"url\":\"https:\/\/codefresh.io\/continuous-deployment\/serverless\/ci-cd-serverless\/\",\"name\":\"Production-ready CI\/CD for Serverless Applications | Codefresh\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/#website\"},\"primaryImageOfPage\":{\"@id\":\"https:\/\/codefresh.io\/continuous-deployment\/serverless\/ci-cd-serverless\/#primaryimage\"},\"datePublished\":\"2018-07-09T14:04:53+00:00\",\"dateModified\":\"2022-03-01T17:02:43+00:00\",\"description\":\"Creating a production-ready CI\/CD pipelines for AWS Lambda serverless application, with Codefresh and Serverless Framework.\",\"breadcrumb\":{\"@id\":\"https:\/\/codefresh.io\/continuous-deployment\/serverless\/ci-cd-serverless\/#breadcrumb\"},\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"ReadAction\",\"target\":[\"https:\/\/codefresh.io\/continuous-deployment\/serverless\/ci-cd-serverless\/\"]}]},{\"@type\":\"BreadcrumbList\",\"@id\":\"https:\/\/codefresh.io\/continuous-deployment\/serverless\/ci-cd-serverless\/#breadcrumb\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"name\":\"Home\",\"item\":\"https:\/\/codefresh.io\/\"},{\"@type\":\"ListItem\",\"position\":2,\"name\":\"Production-ready CI\/CD for Serverless Applications\"}]},{\"@type\":\"Article\",\"@id\":\"https:\/\/codefresh.io\/continuous-deployment\/serverless\/ci-cd-serverless\/#article\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/continuous-deployment\/serverless\/ci-cd-serverless\/#webpage\"},\"author\":{\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/33798ced90c48c116c3a9a59ae74af50\"},\"headline\":\"Production-ready CI\/CD for Serverless Applications\",\"datePublished\":\"2018-07-09T14:04:53+00:00\",\"dateModified\":\"2022-03-01T17:02:43+00:00\",\"mainEntityOfPage\":{\"@id\":\"https:\/\/codefresh.io\/continuous-deployment\/serverless\/ci-cd-serverless\/#webpage\"},\"wordCount\":2018,\"commentCount\":0,\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/continuous-deployment\/serverless\/ci-cd-serverless\/#primaryimage\"},\"thumbnailUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/computer-workers-alex-kotliarskyi-QBpZGqEMsKg-unsplash-scaled.jpg\",\"keywords\":[\"continuous integration\",\"devops\",\"CI\/CD\",\"codefresh\",\"testing\",\"continuous delivery\",\"aws\",\"lambda\",\"serverless\"],\"articleSection\":[\"Serverless\"],\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"CommentAction\",\"name\":\"Comment\",\"target\":[\"https:\/\/codefresh.io\/continuous-deployment\/serverless\/ci-cd-serverless\/#respond\"]}]},{\"@type\":\"Person\",\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/33798ced90c48c116c3a9a59ae74af50\",\"name\":\"Alexei Ledenev\",\"image\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#personlogo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/secure.gravatar.com\/avatar\/53d5ff05d62acd594ea97300543a62a5?s=96&d=blank&r=g\",\"contentUrl\":\"https:\/\/secure.gravatar.com\/avatar\/53d5ff05d62acd594ea97300543a62a5?s=96&d=blank&r=g\",\"caption\":\"Alexei Ledenev\"},\"description\":\"Alexei is an experienced software architect and HPE distinguished technologist. He currently works at Codefresh as the Chief Researcher, focusing lately on #docker, #golang and #aws. In his spare time, Alexei maintains a couple of Docker-centric open-source projects, writes tech blog posts, and enjoys traveling and playing with his kids. https:\/\/github.com\/gaia-adm\/pumba\",\"sameAs\":[\"https:\/\/medium.com\/@alexeiled\/\",\"https:\/\/twitter.com\/alexeiled\"],\"url\":\"https:\/\/codefresh.io\/author\/alexei\/\"}]}<\/script>\n<!-- \/ Yoast SEO Premium plugin. -->","yoast_head_json":{"title":"Production-ready CI\/CD for Serverless Applications | Codefresh","description":"Creating a production-ready CI\/CD pipelines for AWS Lambda serverless application, with Codefresh and Serverless Framework.","robots":{"index":"index","follow":"follow","max-snippet":"max-snippet:-1","max-image-preview":"max-image-preview:large","max-video-preview":"max-video-preview:-1"},"canonical":"https:\/\/codefresh.io\/continuous-deployment\/serverless\/ci-cd-serverless\/","og_locale":"en_US","og_type":"article","og_title":"Production-ready CI\/CD for Serverless Applications","og_description":"Creating a production-ready CI\/CD pipelines for AWS Lambda serverless application, with Codefresh and Serverless Framework.","og_url":"https:\/\/codefresh.io\/continuous-deployment\/serverless\/ci-cd-serverless\/","og_site_name":"Codefresh","article_publisher":"https:\/\/www.facebook.com\/codefresh.io","article_published_time":"2018-07-09T14:04:53+00:00","article_modified_time":"2022-03-01T17:02:43+00:00","og_image":[{"width":2560,"height":1707,"url":"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/computer-workers-alex-kotliarskyi-QBpZGqEMsKg-unsplash-scaled.jpg","type":"image\/jpeg"}],"twitter_card":"summary_large_image","twitter_creator":"@alexeiled","twitter_site":"@codefresh","twitter_misc":{"Written by":"Alexei Ledenev","Est. reading time":"12 minutes"},"schema":{"@context":"https:\/\/schema.org","@graph":[{"@type":"Organization","@id":"https:\/\/codefresh.io\/#organization","name":"Codefresh","url":"https:\/\/codefresh.io\/","sameAs":["https:\/\/www.facebook.com\/codefresh.io","https:\/\/www.linkedin.com\/company\/codefresh","https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg","https:\/\/twitter.com\/codefresh"],"logo":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#logo","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","width":800,"height":800,"caption":"Codefresh"},"image":{"@id":"https:\/\/codefresh.io\/#logo"}},{"@type":"WebSite","@id":"https:\/\/codefresh.io\/#website","url":"https:\/\/codefresh.io\/","name":"Codefresh","description":"","publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"potentialAction":[{"@type":"SearchAction","target":{"@type":"EntryPoint","urlTemplate":"https:\/\/codefresh.io\/?s={search_term_string}"},"query-input":"required name=search_term_string"}],"inLanguage":"en-US"},{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/continuous-deployment\/serverless\/ci-cd-serverless\/#primaryimage","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/computer-workers-alex-kotliarskyi-QBpZGqEMsKg-unsplash-scaled.jpg","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/computer-workers-alex-kotliarskyi-QBpZGqEMsKg-unsplash-scaled.jpg","width":2560,"height":1707},{"@type":"WebPage","@id":"https:\/\/codefresh.io\/continuous-deployment\/serverless\/ci-cd-serverless\/#webpage","url":"https:\/\/codefresh.io\/continuous-deployment\/serverless\/ci-cd-serverless\/","name":"Production-ready CI\/CD for Serverless Applications | Codefresh","isPartOf":{"@id":"https:\/\/codefresh.io\/#website"},"primaryImageOfPage":{"@id":"https:\/\/codefresh.io\/continuous-deployment\/serverless\/ci-cd-serverless\/#primaryimage"},"datePublished":"2018-07-09T14:04:53+00:00","dateModified":"2022-03-01T17:02:43+00:00","description":"Creating a production-ready CI\/CD pipelines for AWS Lambda serverless application, with Codefresh and Serverless Framework.","breadcrumb":{"@id":"https:\/\/codefresh.io\/continuous-deployment\/serverless\/ci-cd-serverless\/#breadcrumb"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https:\/\/codefresh.io\/continuous-deployment\/serverless\/ci-cd-serverless\/"]}]},{"@type":"BreadcrumbList","@id":"https:\/\/codefresh.io\/continuous-deployment\/serverless\/ci-cd-serverless\/#breadcrumb","itemListElement":[{"@type":"ListItem","position":1,"name":"Home","item":"https:\/\/codefresh.io\/"},{"@type":"ListItem","position":2,"name":"Production-ready CI\/CD for Serverless Applications"}]},{"@type":"Article","@id":"https:\/\/codefresh.io\/continuous-deployment\/serverless\/ci-cd-serverless\/#article","isPartOf":{"@id":"https:\/\/codefresh.io\/continuous-deployment\/serverless\/ci-cd-serverless\/#webpage"},"author":{"@id":"https:\/\/codefresh.io\/#\/schema\/person\/33798ced90c48c116c3a9a59ae74af50"},"headline":"Production-ready CI\/CD for Serverless Applications","datePublished":"2018-07-09T14:04:53+00:00","dateModified":"2022-03-01T17:02:43+00:00","mainEntityOfPage":{"@id":"https:\/\/codefresh.io\/continuous-deployment\/serverless\/ci-cd-serverless\/#webpage"},"wordCount":2018,"commentCount":0,"publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"image":{"@id":"https:\/\/codefresh.io\/continuous-deployment\/serverless\/ci-cd-serverless\/#primaryimage"},"thumbnailUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/computer-workers-alex-kotliarskyi-QBpZGqEMsKg-unsplash-scaled.jpg","keywords":["continuous integration","devops","CI\/CD","codefresh","testing","continuous delivery","aws","lambda","serverless"],"articleSection":["Serverless"],"inLanguage":"en-US","potentialAction":[{"@type":"CommentAction","name":"Comment","target":["https:\/\/codefresh.io\/continuous-deployment\/serverless\/ci-cd-serverless\/#respond"]}]},{"@type":"Person","@id":"https:\/\/codefresh.io\/#\/schema\/person\/33798ced90c48c116c3a9a59ae74af50","name":"Alexei Ledenev","image":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#personlogo","inLanguage":"en-US","url":"https:\/\/secure.gravatar.com\/avatar\/53d5ff05d62acd594ea97300543a62a5?s=96&d=blank&r=g","contentUrl":"https:\/\/secure.gravatar.com\/avatar\/53d5ff05d62acd594ea97300543a62a5?s=96&d=blank&r=g","caption":"Alexei Ledenev"},"description":"Alexei is an experienced software architect and HPE distinguished technologist. He currently works at Codefresh as the Chief Researcher, focusing lately on #docker, #golang and #aws. In his spare time, Alexei maintains a couple of Docker-centric open-source projects, writes tech blog posts, and enjoys traveling and playing with his kids. https:\/\/github.com\/gaia-adm\/pumba","sameAs":["https:\/\/medium.com\/@alexeiled\/","https:\/\/twitter.com\/alexeiled"],"url":"https:\/\/codefresh.io\/author\/alexei\/"}]}},"acf":[],"_links":{"self":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/9505"}],"collection":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/users\/28"}],"replies":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/comments?post=9505"}],"version-history":[{"count":2,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/9505\/revisions"}],"predecessor-version":[{"id":21726,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/9505\/revisions\/21726"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media\/20529"}],"wp:attachment":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media?parent=9505"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/categories?post=9505"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/tags?post=9505"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}