{"id":9529,"date":"2019-12-10T06:00:29","date_gmt":"2019-12-10T06:00:29","guid":{"rendered":"http:\/\/codefresh.io\/?p=9529"},"modified":"2019-12-13T13:07:48","modified_gmt":"2019-12-13T13:07:48","slug":"codefresh-versus-gitlabci","status":"publish","type":"post","link":"https:\/\/codefresh.io\/continuous-integration\/codefresh-versus-gitlabci\/","title":{"rendered":"Codefresh vs. GitlabCI"},"content":{"rendered":"<p>If you have selected Gitlab as your git provider, you may automatically think about selecting GitlabCI as your CI\/CD solution as well. Using the same vendor for source control and CI\/CD might seem natural, but is not always the best combination. In fact, choosing a \u201cgood-enough\u201d option just because it is part of the same solution is unwise in the long run if it doesn\u2019t cover your needs.<\/p>\n<p>Gitlab is one of the supported GIT providers in Codefresh, so another valid combination is using Gitlab for source control and Codefresh for CI\/CD. In this article, we will look at the advantages of Codefresh compared to the GitlabCI platform.<\/p>\n<p><strong>Update: See Gitlab&#8217;s response to this comparison <a href=\"https:\/\/about.gitlab.com\/devops-tools\/codefresh\/\">here<\/a><\/strong><\/p>\n<p><strong>Content was updated as both products changed since initial writing<\/strong><\/p>\n<h3>Table of contents<\/h3>\n<ol>\n<li>Codefresh is GIT agnostic, GitlabCI has native support only for its own repos<\/li>\n<li>Codefresh allows you to create multiple pipelines per repo, while GitlabCI is constrained to just one<\/li>\n<li>Docker builds are much faster with Codefresh<\/li>\n<li>GitlabCI needs special configuration to share information between pipeline phases<\/li>\n<li>The Docker registry in Codefresh is fully automated<\/li>\n<li>The Docker registry in Codefresh is much more detailed<\/li>\n<li>Codefresh has explicit support for Kubernetes deployments<\/li>\n<li>Codefresh has explicit support for Helm deployments<\/li>\n<\/ol>\n<h2>Codefresh is GIT agnostic, GitlabCI is not<\/h2>\n<p>This is probably the biggest difference between Codefresh and GitlabCI. Codefresh has <strong>native support<\/strong> for all popular Git providers such as Github, Gitlab, Bitbucket, Azure Devops Git, Atlassian Stash and can work with both cloud and hosted variants of them. All Git providers enjoy equal support in Codefresh and all features (git triggers, monorepo changes, checkouts, webhooks etc) work in a similar manner.<\/p>\n<figure id=\"attachment_14937\" aria-describedby=\"caption-attachment-14937\" style=\"width: 687px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/codefresh-git.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/codefresh-git.png\" alt=\"Codefresh Git support\" width=\"687\" height=\"396\" class=\"size-full wp-image-14937\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/codefresh-git.png 687w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/codefresh-git-300x173.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/codefresh-git-20x12.png 20w\" sizes=\"(max-width: 687px) 100vw, 687px\" \/><\/a><figcaption id=\"caption-attachment-14937\" class=\"wp-caption-text\">Codefresh Git support<\/figcaption><\/figure>\n<p>GitlabCI has native support only for Gitlab repositories. If your source code is located somewhere else you need to import it into Gitlab, basically creating a second copy. Specifically for Github, there is also partial support for &#8220;mirroring&#8221; where a second clone of your git repository is placed into Gitlab and all upstream changes are automatically synced. But the communication is one way. If you make changes into Gitlab they won&#8217;t be synced back to Github. The process is very cumbersome as essentially you have two repos to manage and they can easily suffer from drift issues.<\/p>\n<p>At the time of writing there is a <a href=\"https:\/\/gitlab.com\/groups\/gitlab-org\/-\/epics\/943\">whole epic open (with 10+ issues)<\/a>, so at least Gitlab is aware of this limitation. But until this epic is implemented Codefresh is the only viable solution if you work in an organization that is using multiple GIT providers.<\/p>\n<p>We find that several companies want to use other Git providers apart from Gitlab, so Codefresh has a major advantage on the topic of GIT support.<\/p>\n<h2>Codefresh allows you to create multiple pipelines per repo, while GitlabCI is constrained to just one<\/h2>\n<p>This was another big revelation during my time with GitlabCI. In GitlabCI you can only define a single pipeline per project. That\u2019s it! There is no way to add more pipelines. In the screenshot below, you can see there is really only one &#8220;Run Pipeline&#8221; button:<\/p>\n<figure id=\"attachment_9543\" aria-describedby=\"caption-attachment-9543\" style=\"width: 1024px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/only-one-pipeline-defined.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/only-one-pipeline-defined-1024x118.png\" alt=\"Only one pipeline\" width=\"1024\" height=\"118\" class=\"size-large wp-image-9543\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/only-one-pipeline-defined-1024x118.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/only-one-pipeline-defined-300x34.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/only-one-pipeline-defined-768x88.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/only-one-pipeline-defined-628x72.png 628w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/only-one-pipeline-defined.png 1306w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" \/><\/a><figcaption id=\"caption-attachment-9543\" class=\"wp-caption-text\">Only one pipeline<\/figcaption><\/figure>\n<p>A nontrivial application will need more than one pipeline. A common set of pipelines would be:<\/p>\n<ul>\n<li>A pipeline that runs on every commit that packages code and probably creates a Docker image.<\/li>\n<li>A pipeline the deploys to an environment (e.g. prod or staging).<\/li>\n<li>A pipeline that runs load testing against a specific environment.<\/li>\n<li>A pipeline for pull requests that might run code quality or other security tools.<\/li>\n<li>A weekly build for cleanups or maintenance actions.<\/li>\n<\/ul>\n<p>GitlabCI offers the capability to have conditionals in a pipeline, so in theory, you could create a really huge pipeline that acts as a superset of all the things that you might ever need. But this is not ideal, and there is even <a href=\"https:\/\/gitlab.com\/gitlab-org\/gitlab\/issues\/16094\">an issue that has been open since 2016<\/a> for this particular problem.<\/p>\n<p>Codefresh does not suffer from such limitations. Even though Codefresh also allows you to define <a href=\"https:\/\/codefresh.io\/docs\/docs\/codefresh-yaml\/conditional-execution-of-steps\/\">pipeline conditionals<\/a>, you are still free to define multiple pipelines for every workflow imaginable.<\/p>\n<figure id=\"attachment_14933\" aria-describedby=\"caption-attachment-14933\" style=\"width: 177px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/multiple-pipelines.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/multiple-pipelines.png\" alt=\"Multiple pipelines in Codefresh\" width=\"177\" height=\"325\" class=\"size-full wp-image-14933\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/multiple-pipelines.png 177w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/multiple-pipelines-163x300.png 163w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/multiple-pipelines-11x20.png 11w\" sizes=\"(max-width: 177px) 100vw, 177px\" \/><\/a><figcaption id=\"caption-attachment-14933\" class=\"wp-caption-text\">Multiple pipelines in Codefresh<\/figcaption><\/figure>\n<p>In a similar manner, the git trigger capabilities in Codefresh can cover all webhook events sent by the git provider resulting in pipelines that can run against specific git events. This can be done right from the GUI with no special configuration in the build yaml file.<\/p>\n<figure id=\"attachment_9546\" aria-describedby=\"caption-attachment-9546\" style=\"width: 300px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/add-git-trigger.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/add-git-trigger-300x126.png\" alt=\"Codefresh git triggers\" width=\"300\" height=\"126\" class=\"size-medium wp-image-9546\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/add-git-trigger-300x126.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/add-git-trigger.png 542w\" sizes=\"(max-width: 300px) 100vw, 300px\" \/><\/a><figcaption id=\"caption-attachment-9546\" class=\"wp-caption-text\">Codefresh git triggers<\/figcaption><\/figure>\n<p>This limitation of GitlabCI essentially forces you into having a huge <code>gitab-ci.yml<\/code> file with multiple conditional steps that select the \u201cproper\u201d workflow when an event is triggering the pipeline. For a really really complex workflow, this can quickly get out of hand.<\/p>\n<p>Codefresh also supports parent\/child relationships which GitlabCI currently does not.<\/p>\n<h2>Docker builds are much faster with Codefresh<\/h2>\n<p>Codefresh has <a href=\"https:\/\/codefresh.io\/docs\/docs\/configure-ci-cd-pipeline\/pipeline-caching\/\">several types of built-in caching<\/a> and two of them are actually specific to Docker builds.<\/p>\n<p>One of the most powerful Codefresh features is the zero-configuration distributed docker layer cache. All Codefresh build nodes share it which means that all subsequent builds will use the previously cached layers. It works exactly as you would expect from the Docker layer cache in your local workstation:<\/p>\n<figure id=\"attachment_14939\" aria-describedby=\"caption-attachment-14939\" style=\"width: 1024px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/docker-layer-cache.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/docker-layer-cache-1024x459.png\" alt=\"Docker cache in Codefresh\" width=\"1024\" height=\"459\" class=\"size-large wp-image-14939\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/docker-layer-cache-1024x459.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/docker-layer-cache-300x134.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/docker-layer-cache-768x344.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/docker-layer-cache-20x9.png 20w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/docker-layer-cache.png 1424w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" \/><\/a><figcaption id=\"caption-attachment-14939\" class=\"wp-caption-text\">Docker cache in Codefresh<\/figcaption><\/figure>\n<p>This cache is completely automatic. There is nothing to setup or configure. It works in all versions of Codefresh (even the SAAS one). GitlabCI has no such cache and no matter how many times you build a docker images, it will rebuild everything from scratch. This means that Docker builds are very slow in GitlabCI and depending on the size of your images (and number of layers) the amount of time you lose by waiting for builds can become a bottleneck.<\/p>\n<p>Here is an actual example where the same project is packaged with Codefresh and GitlabCI without actually changing anything.<\/p>\n<figure id=\"attachment_14940\" aria-describedby=\"caption-attachment-14940\" style=\"width: 957px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/cache-comparison.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/cache-comparison.png\" alt=\"GitlabCI has no Docker cache\" width=\"957\" height=\"508\" class=\"size-full wp-image-14940\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/cache-comparison.png 957w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/cache-comparison-300x159.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/cache-comparison-768x408.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/cache-comparison-20x11.png 20w\" sizes=\"(max-width: 957px) 100vw, 957px\" \/><\/a><figcaption id=\"caption-attachment-14940\" class=\"wp-caption-text\">GitlabCI has no Docker cache<\/figcaption><\/figure>\n<p>Codefresh is very fast because the second type of cache has kicked-in and has detected that this Docker image is already built.<\/p>\n<figure id=\"attachment_14941\" aria-describedby=\"caption-attachment-14941\" style=\"width: 1024px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/prebuild.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/prebuild-1024x386.png\" alt=\"Codefresh detects an existing Docker image\" width=\"1024\" height=\"386\" class=\"size-large wp-image-14941\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/prebuild-1024x386.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/prebuild-300x113.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/prebuild-768x290.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/prebuild-20x8.png 20w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/prebuild.png 1185w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" \/><\/a><figcaption id=\"caption-attachment-14941\" class=\"wp-caption-text\">Codefresh detects an existing Docker image<\/figcaption><\/figure>\n<p>At the time of writing there is an <a href=\"https:\/\/gitlab.com\/gitlab-org\/gitlab-runner\/issues\/1107\">open issue for Docker cache in GitlabCI<\/a>. But as things are now, just by building a project with Codefresh you will get much faster builds.<\/p>\n<h2>GitlabCI needs special configuration to share information between pipeline phases<\/h2>\n<p>The pipeline phases in GitlabCI are called \u201cjobs\u201d (in Codefresh they are called \u201csteps\u201d). These run in a completely independent manner so everything that needs to be shared between pipeline phases must be defined explicitly.<\/p>\n<p>To accomplish this, GitlabCI introduces a special syntax for two different concepts: <a href=\"https:\/\/docs.gitlab.com\/ee\/user\/project\/pipelines\/job_artifacts.html\">artifacts <\/a>and <a href=\"https:\/\/docs.gitlab.com\/ee\/ci\/caching\/#caching-nodejs-dependencies\">caching<\/a>.<\/p>\n<p>If you need to transfer something from one phase to another you need to explicitly define it as cache. For example, let&#8217;s say you have two GitlabCI jobs that both use node modules. Unless you define the folder as cache, both of them will re-download everything.<\/p>\n<p>The correct syntax in GitlabCI would be:<\/p>\n<pre class=\"lang:default decode:true \"> \ncache:\n paths:\n    - node_modules\/\nsetup:\n stage: setup\n image: node:7.9\n script:\n    - npm install\n\ntest:\n stage: test\n image: node:7.9\n script:\n    - npm test\n<\/pre>\n<p>If you wish to just move things from one job to another you are expected to use artifacts. For example, if you create a jar file in one job and expect to find it in the next one, you first need to add the following to your GitlabCI file:<\/p>\n<pre class=\"lang:default decode:true \"> \nbuild:\n stage: build\n image: maven:3.3.9-jdk-8\n script:\n    - mvn package\n artifacts:\n    paths:\n     - target\/*.jar<\/code>\n<\/pre>\n<p>The distinction between caching and artifacts is not always very clear, forcing even the <a href=\"https:\/\/docs.gitlab.com\/ee\/ci\/caching\/index.html#cache-vs-artifacts\">official documentation<\/a> to offer advice on best practices for what to consider cache and what to consider an artifact.<\/p>\n<p>So how does Codefresh deal with this issue?<\/p>\n<p>In Codefresh, in order to transfer information from one step to the other, you do (drumroll please)&#8230;.absolutely nothing. In Codefresh all pipeline phases <a href=\"https:\/\/codefresh.io\/docs\/docs\/configure-ci-cd-pipeline\/introduction-to-codefresh-pipelines\/#sharing-the-workspace-between-build-steps\">share a common volume<\/a> (which includes the code of your project). So everything that is created in the project folder is automatically available to the next phase.<\/p>\n<figure id=\"attachment_9552\" aria-describedby=\"caption-attachment-9552\" style=\"width: 800px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/codefresh-volume.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/codefresh-volume.png\" alt=\"Shared Codefresh volume\" width=\"800\" height=\"440\" class=\"size-full wp-image-9552\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/codefresh-volume.png 800w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/codefresh-volume-300x165.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/codefresh-volume-768x422.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/codefresh-volume-596x328.png 596w\" sizes=\"(max-width: 800px) 100vw, 800px\" \/><\/a><figcaption id=\"caption-attachment-9552\" class=\"wp-caption-text\">Shared Codefresh volume<\/figcaption><\/figure>\n<p>This means that you don&#8217;t need to do anything special to cache node modules. In Codefresh yml the same thing would be:<\/p>\n<pre class=\"lang:default decode:true \"> \nsetup:\n title: setup\n image: node:7.9\n commands:\n    - npm install\n\ntest:\n title: test\n image: node:7.9\n commands:\n    - npm test<\/code>\n<\/pre>\n<p>The same goes for \u201cartifacts\u201d. There is no need to define something explicitly for binaries,  test reports, or anything else that you wish to be visible to all pipeline steps.<\/p>\n<pre class=\"lang:default decode:true \"> \nbuild:\n title: build\n image: maven:3.3.9-jdk-8\n commands:\n    - mvn package\n<\/pre>\n<p>The end result is that Codefresh pipelines are much more compact and readable. You can find more information about Codefresh pipelines in the <a href=\"https:\/\/codefresh.io\/docs\/docs\/configure-ci-cd-pipeline\/introduction-to-codefresh-pipelines\/\">documentation<\/a>.<\/p>\n<h2>The Docker registry in Codefresh is fully automated<\/h2>\n<p>Both Codefresh and GitlabCI offer a built-in Docker registry that can be used for storage of Docker images. The Docker registry offered by GitlabCI acts as any other Docker registry and in order to use it, you have to explicitly call Docker commands in your yml file.<\/p>\n<p>For example, in order to push an image in GitlabCI you need to do the following:<\/p>\n<pre class=\"lang:default decode:true \"> \ncreate-image:\n stage: create-image\n image: docker:stable\n services:\n    - docker:dind\n script:\n    - docker build -t \"$CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG\" .\n    - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY\n    - docker push \"$CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG\"\n<\/pre>\n<p>This yml syntax essentially reflects what you would write in locally on your workstation. Codefresh offers much better support for its own internal registry.<\/p>\n<p>In order to push your image to the Codefresh registry you do (drumroll please)&#8230;.absolutely nothing. By default, all your Docker images that are produced by your builds are automatically pushed to the internal registry. You don\u2019t add anything in your yml file to enable this functionality.<\/p>\n<figure id=\"attachment_9553\" aria-describedby=\"caption-attachment-9553\" style=\"width: 1024px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/codefresh-registry.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/codefresh-registry-1024x597.png\" alt=\"Codefresh Registry\" width=\"1024\" height=\"597\" class=\"size-large wp-image-9553\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/codefresh-registry-1024x597.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/codefresh-registry-300x175.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/codefresh-registry-768x448.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/codefresh-registry-563x328.png 563w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/codefresh-registry.png 1232w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" \/><\/a><figcaption id=\"caption-attachment-9553\" class=\"wp-caption-text\">Codefresh Registry<\/figcaption><\/figure>\n<p>And before you ask about wasted space, know the Codefresh pricing is independent of the number of Docker images you have, so don\u2019t worry about overusing the internal registry. As we will also see in the next section, it is very easy to locate images even when their number is very big.<\/p>\n<p>If you want to use an external registry, Codefresh helps you even further by allowing you to declare all your registries at your account level (including authentication details).<\/p>\n<figure id=\"attachment_9554\" aria-describedby=\"caption-attachment-9554\" style=\"width: 630px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/add-docker-registry.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/add-docker-registry.png\" alt=\"Adding a Docker Registry\" width=\"630\" height=\"672\" class=\"size-full wp-image-9554\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/add-docker-registry.png 630w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/add-docker-registry-281x300.png 281w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/add-docker-registry-308x328.png 308w\" sizes=\"(max-width: 630px) 100vw, 630px\" \/><\/a><figcaption id=\"caption-attachment-9554\" class=\"wp-caption-text\">Adding a Docker Registry<\/figcaption><\/figure>\n<p>Once you want to use an external registry you only need a push step:<\/p>\n<pre class=\"lang:default decode:true \"> \nbuild_image:\n   title: Building DockerImage\n   type: build\n   image_name: my-app:master\npush_name:\n type: push\n title: Pushing to ECR\n candidate: ${{build_image}}\n tag: latest\n image_name: codefresh\/my-app\n registry: my-ecr-registry<\/code>\n<\/pre>\n<p>Notice the complete lack of login instructions in Codefresh. You only define the registry name as it was defined in the GUI. With GitlabCI you would need to replicate the Docker login commands as before.<\/p>\n<p>In summary, working with the integrated Docker registry is completely automatic with Codefresh, while GitlabCI needs the exact push instructions.<\/p>\n<h2>The Docker registry in Codefresh is much more detailed<\/h2>\n<p>We have seen in the previous section how easy it is to use the Codefresh internal registry and talked about the yml syntax for each platform. Once you have many images in your Docker registry you need a way to find them and catalog them.<\/p>\n<p>The GUI view of the registry in GitlabCI is very sparse:<\/p>\n<figure id=\"attachment_9555\" aria-describedby=\"caption-attachment-9555\" style=\"width: 1024px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/registry-details.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/registry-details-1024x362.png\" alt=\"GitlabCI registry\" width=\"1024\" height=\"362\" class=\"size-large wp-image-9555\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/registry-details-1024x362.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/registry-details-300x106.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/registry-details-768x271.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/registry-details-628x222.png 628w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/registry-details.png 1283w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" \/><\/a><figcaption id=\"caption-attachment-9555\" class=\"wp-caption-text\">GitlabCI registry<\/figcaption><\/figure>\n<p>You only see the tag, the size, and the date of the image. There is no other option available (which might make sense as we have already seen that the registry in GitlabCI is tied to a single project).<\/p>\n<p>Codefresh, on the other hand, gives you several more options. As a starting point, you can narrow down your view using multiple filters<\/p>\n<figure id=\"attachment_9556\" aria-describedby=\"caption-attachment-9556\" style=\"width: 507px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/image-search.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/image-search.png\" alt=\"Image filtering\" width=\"507\" height=\"517\" class=\"size-full wp-image-9556\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/image-search.png 507w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/image-search-294x300.png 294w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/image-search-322x328.png 322w\" sizes=\"(max-width: 507px) 100vw, 507px\" \/><\/a><figcaption id=\"caption-attachment-9556\" class=\"wp-caption-text\">Image filtering<\/figcaption><\/figure>\n<p>You can also do an analysis of the layers of each image to gain insights of the size:<\/p>\n<figure id=\"attachment_9557\" aria-describedby=\"caption-attachment-9557\" style=\"width: 1024px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/docker-layers.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/docker-layers-1024x593.png\" alt=\"Docker layers\" width=\"1024\" height=\"593\" class=\"size-large wp-image-9557\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/docker-layers-1024x593.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/docker-layers-300x174.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/docker-layers-768x445.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/docker-layers-566x328.png 566w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/docker-layers.png 1082w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" \/><\/a><figcaption id=\"caption-attachment-9557\" class=\"wp-caption-text\">Docker layers<\/figcaption><\/figure>\n<p>And most importantly of all, you can annotate your Docker images with your own metadata. For example, you can mark images that have passed security scans, or code quality gates, or load testing approval. The metadata can be added either directly from the GUI or via the pipeline syntax.<\/p>\n<figure id=\"attachment_9558\" aria-describedby=\"caption-attachment-9558\" style=\"width: 1024px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/annotations.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/annotations-1024x637.png\" alt=\"Docker annotations\" width=\"1024\" height=\"637\" class=\"size-large wp-image-9558\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/annotations-1024x637.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/annotations-300x187.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/annotations-768x477.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/annotations-528x328.png 528w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/annotations.png 1200w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" \/><\/a><figcaption id=\"caption-attachment-9558\" class=\"wp-caption-text\">Docker annotations<\/figcaption><\/figure>\n<p>This makes the Codefresh Registry very powerful, making it a central source of truth for developers, QA, operations and any other stakeholder of a project.<\/p>\n<p>In summary, the integrated GitlabCI registry lacks a lot of features offered by the Codefresh version.<\/p>\n<h2>Codefresh has explicit support for Kubernetes deployments<\/h2>\n<p>Easy Kubernetes integration is one of the major features behind the development of Codefresh. Kubernetes support is one of the highlights of Codefresh functionality.<\/p>\n<p>When you define a Kubernetes cluster in Codefresh, you get access to two major features: First, you have a built-in Kubernetes dashboard that shows you namespaces\/pods and deployments:<\/p>\n<figure id=\"attachment_9559\" aria-describedby=\"caption-attachment-9559\" style=\"width: 1024px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/kubernetest-dashboard.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/kubernetest-dashboard-1024x778.png\" alt=\"Kubernetes Dashboard\" width=\"1024\" height=\"778\" class=\"size-large wp-image-9559\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/kubernetest-dashboard-1024x778.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/kubernetest-dashboard-300x228.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/kubernetest-dashboard-768x583.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/kubernetest-dashboard-432x328.png 432w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/kubernetest-dashboard.png 1035w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" \/><\/a><figcaption id=\"caption-attachment-9559\" class=\"wp-caption-text\">Kubernetes Dashboard<\/figcaption><\/figure>\n<p>Second, Codefresh allows you to deploy a Kubernetes service with just the GUI, which is a great way to quickly deploy demo apps.<\/p>\n<figure id=\"attachment_9560\" aria-describedby=\"caption-attachment-9560\" style=\"width: 1024px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/add-service.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/add-service-1024x623.png\" alt=\"Deploy on Kubernetes\" width=\"1024\" height=\"623\" class=\"size-large wp-image-9560\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/add-service-1024x623.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/add-service-300x182.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/add-service-768x467.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/add-service-539x328.png 539w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/add-service.png 1120w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" \/><\/a><figcaption id=\"caption-attachment-9560\" class=\"wp-caption-text\">Deploy on Kubernetes<\/figcaption><\/figure>\n<p>In vanilla GitlabCI there is no such thing. Apart from the deploy boards, there is no other GUI that can help you with your first steps in Kubernetes management.<\/p>\n<h2>Codefresh has explicit support for Helm deployments<\/h2>\n<p>Helm is a package manager for Kubernetes that allows you to group multiple application into charts.<\/p>\n<p>GitlabCI has some basic support for Helm. It allows you to easily install Helm on your Kubernetes cluster (i.e. the server component called Tiller).<\/p>\n<figure id=\"attachment_9561\" aria-describedby=\"caption-attachment-9561\" style=\"width: 882px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/install-tiller.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/install-tiller.png\" alt=\"Install Tiller\" width=\"882\" height=\"407\" class=\"size-full wp-image-9561\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/install-tiller.png 882w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/install-tiller-300x138.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/install-tiller-768x354.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/install-tiller-628x290.png 628w\" sizes=\"(max-width: 882px) 100vw, 882px\" \/><\/a><figcaption id=\"caption-attachment-9561\" class=\"wp-caption-text\">Install Tiller<\/figcaption><\/figure>\n<p>Once Tiller has installed it is also very easy to use Helm to install packages.<\/p>\n<p>Codefresh, on the other hand, takes Helm integration to the next level by providing:<\/p>\n<ul>\n<li>an integrated Helm repository for all accounts,<\/li>\n<li>a graphical app browser that can access both the internal and external helm repos,<\/li>\n<li>and a Helm dashboard for monitoring deployments and even rolling them back.<\/li>\n<\/ul>\n<p>None of these is offered by GitlabCI and having an internal Helm repository is really crucial for using Helm in the first place (as the built-in Docker registry is useful for Docker images).<\/p>\n<p>Codefresh gives you a built-in Helm repository that you can use for your own charts. You can also connect other chart repositories and create an application catalog.<\/p>\n<figure id=\"attachment_9562\" aria-describedby=\"caption-attachment-9562\" style=\"width: 1021px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/helm-repository.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/helm-repository.png\" alt=\"Helm Repository\" width=\"1021\" height=\"748\" class=\"size-full wp-image-9562\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/helm-repository.png 1021w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/helm-repository-300x220.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/helm-repository-768x563.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/helm-repository-448x328.png 448w\" sizes=\"(max-width: 1021px) 100vw, 1021px\" \/><\/a><figcaption id=\"caption-attachment-9562\" class=\"wp-caption-text\">Helm Repository<\/figcaption><\/figure>\n<p>Once you install a Helm chart in your Kubernetes cluster you have full visibility on version history, active services, chart values, etc.<\/p>\n<figure id=\"attachment_9563\" aria-describedby=\"caption-attachment-9563\" style=\"width: 1024px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/Helm-Releases.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/Helm-Releases-1024x619.png\" alt=\"Helm Releases\" width=\"1024\" height=\"619\" class=\"size-large wp-image-9563\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/Helm-Releases-1024x619.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/Helm-Releases-300x181.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/Helm-Releases-768x464.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/Helm-Releases-542x328.png 542w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/Helm-Releases.png 1108w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" \/><\/a><figcaption id=\"caption-attachment-9563\" class=\"wp-caption-text\">Helm Releases<\/figcaption><\/figure>\n<p>However, the most impressive capability is that you can rollback a version right from the GUI. And in this case, rollback means the Helm rollback (i.e. going to a previous version of the chart).<\/p>\n<figure id=\"attachment_9564\" aria-describedby=\"caption-attachment-9564\" style=\"width: 886px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/Helm-Releases-Diff-Rollback-2.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/Helm-Releases-Diff-Rollback-2.png\" alt=\"Helm Rollback\" width=\"886\" height=\"670\" class=\"size-full wp-image-9564\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/Helm-Releases-Diff-Rollback-2.png 886w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/Helm-Releases-Diff-Rollback-2-300x227.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/Helm-Releases-Diff-Rollback-2-768x581.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/Helm-Releases-Diff-Rollback-2-434x328.png 434w\" sizes=\"(max-width: 886px) 100vw, 886px\" \/><\/a><figcaption id=\"caption-attachment-9564\" class=\"wp-caption-text\">Helm Rollback<\/figcaption><\/figure>\n<p>In summary, Helm support in Codefresh is much more extensive than GitlabCI and the presence of a built-in Helm repo and dashboard are very important factors for using Helm as part of the CI\/CD process.<\/p>\n<h2>Autodevops is a hit-and-miss feature<\/h2>\n<p>In the first version of this comparison I didn&#8217;t say anything about the Auto-devops feature of GitlabCI. The reason was that I consider this feature experimental and it would not make sense to comment on its stability.<\/p>\n<p>However, seeing how GitlabCI uses it as a direct discussion point on its own comparison page I couldn&#8217;t resist on reviewing it as well. I tried autodevops on 3 sample projects (Java, Python, Ruby on Rails) and it worked only on the Java project.<\/p>\n<p>In the Python project it failed to find any tests (even thought the repository has unit tests).<\/p>\n<figure id=\"attachment_14945\" aria-describedby=\"caption-attachment-14945\" style=\"width: 950px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/failed-python-tests.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/failed-python-tests.png\" alt=\"Autodevops fails with a Python repo example\" width=\"950\" height=\"210\" class=\"size-full wp-image-14945\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/failed-python-tests.png 950w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/failed-python-tests-300x66.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/failed-python-tests-768x170.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/failed-python-tests-20x4.png 20w\" sizes=\"(max-width: 950px) 100vw, 950px\" \/><\/a><figcaption id=\"caption-attachment-14945\" class=\"wp-caption-text\">Autodevops fails with a Python repo example<\/figcaption><\/figure>\n<p>It turns out that Auto-devops is based on the same ideas as Heroku buildpacks, which are good for starter projects, but cannot work in all possible cases.<br \/>\nIn my Ruby project I got a completely different error:<\/p>\n<figure id=\"attachment_14946\" aria-describedby=\"caption-attachment-14946\" style=\"width: 1024px\" class=\"wp-caption alignnone\"><a href=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/failed-ruby-tests.png\"><img src=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/failed-ruby-tests-1024x617.png\" alt=\"Autodevops fails with a Ruby project example\" width=\"1024\" height=\"617\" class=\"size-large wp-image-14946\" srcset=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/failed-ruby-tests-1024x617.png 1024w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/failed-ruby-tests-300x181.png 300w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/failed-ruby-tests-768x463.png 768w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/failed-ruby-tests-20x12.png 20w, https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/failed-ruby-tests.png 1126w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" \/><\/a><figcaption id=\"caption-attachment-14946\" class=\"wp-caption-text\">Autodevops fails with a Ruby project example<\/figcaption><\/figure>\n<p>Now of course I could track down these errors and try to fix them, but that would beat the whole purpose of &#8220;autodevops&#8221;. People that know enough to fix those kind of errors can also create their own pipelines manually.<\/p>\n<p>It is also interesting to note that in the past Codefresh had its own &#8220;autodevops&#8221; feature. We tried as well to detect the kind of source code contained in a repository and tried to suggest a pipeline. But it didn&#8217;t work as reliably as we wanted and we scrapped this feature in order to avoid giving false information to our customers.<\/p>\n<p>So while Auto-devops is a very nice idea, in practice it is so unpredictable that I wouldn&#8217;t consider it an advantage of GitlabCI over any other CI platform.<\/p>\n<h2>Conclusion<\/h2>\n<p>In summary, Codefresh is a solution designed specifically for microservices and containers, while GitlabCI is a generic platform where Docker support is an afterthought and Helm support is in its infancy. If you have already switched to Docker\/Kubernetes and especially Helm, Codefresh brings much more value to the table.<\/p>\n<p>At the time of writing the major advantages of GitlabCI over Codefresh are the built-in NPM and Maven registries and the capacity to define artifacts in a pipeline.<\/p>\n<p><strong>Update: See Gitlab&#8217;s response to this comparison <a href=\"https:\/\/about.gitlab.com\/devops-tools\/codefresh\/\">here<\/a><\/strong><\/p>\n<div class=\"table-responsive\"><table class=\"table table-responsive-sm\">\n<thead>\n<tr>\n<th>Feature<\/th>\n<th>GitlabCI<\/th>\n<th>Codefresh<\/th>\n<\/tr>\n<\/thead>\n<tbody>\n<tr>\n<td>Native support for Gitlab GIT repos<\/td>\n<td>Yes<\/td>\n<td>Yes<\/td>\n<\/tr>\n<tr>\n<td>Native support for Github, Bitbucket, Azure Git<\/th>\n<td>No <a href=\"https:\/\/gitlab.com\/groups\/gitlab-org\/-\/epics\/943\">(Open epic)<\/a><\/td>\n<td>Yes<\/td>\n<\/tr>\n<tr>\n<td>Distributed docker layer cache<\/th>\n<td>No <a href=\"https:\/\/gitlab.com\/gitlab-org\/gitlab-runner\/issues\/1107\">(Open issue)<\/a><\/td>\n<td>Yes<\/td>\n<\/tr>\n<tr>\n<td>Distributed Docker Image cache<\/th>\n<td>No<\/td>\n<td>Yes<\/td>\n<\/tr>\n<tr>\n<td>Pipelines per project<\/th>\n<td>1<\/td>\n<td>Unlimited<\/td>\n<\/tr>\n<tr>\n<td>Parent\/Child pipelines<\/th>\n<td>No <a href=\"https:\/\/gitlab.com\/gitlab-org\/gitlab\/issues\/16094\">(Open issue)<\/a><\/td>\n<td>Yes<\/td>\n<\/tr>\n<tr>\n<td>First-class Docker support<\/td>\n<td>No <a href=\"https:\/\/gitlab.com\/gitlab-org\/gitlab\/issues\/23141\">(Open issue)<\/a><\/td>\n<td>Yes<\/td>\n<\/tr>\n<tr>\n<td>Instance level Docker registry<\/td>\n<td>No <a href=\"https:\/\/gitlab.com\/gitlab-org\/gitlab\/issues\/23315\">(Open issue)<\/a><\/td>\n<td>Yes<\/td>\n<\/tr>\n<tr>\n<td>Build caching<\/td>\n<td>Manual<\/td>\n<td>Automatic<\/td>\n<\/tr>\n<tr>\n<td>Parallel pipeline stages<\/td>\n<td>No <a href=\"https:\/\/gitlab.com\/gitlab-org\/gitlab\/issues\/27691\">(Open issue)<\/a><\/td>\n<td>Yes<\/td>\n<\/tr>\n<tr>\n<td>Built-in Helm chart repo<\/td>\n<td>No <a href=\"https:\/\/about.gitlab.com\/direction\/package\/helm_chart_registry\/\">(Vision)<\/a><\/td>\n<td>Yes<\/td>\n<\/tr>\n<tr>\n<td>Helm release dashboard<\/td>\n<td>No<\/td>\n<td>Yes<\/td>\n<\/tr>\n<tr>\n<td>Helm deployment dashboard<\/td>\n<td>No<\/td>\n<td>Yes<\/td>\n<\/tr>\n<tr>\n<td>Helm environment dashboard<\/td>\n<td>No<\/td>\n<td>Yes<\/td>\n<\/tr>\n<tr>\n<td>Live pipeline debugging<\/td>\n<td>No<\/td>\n<td>Yes<\/td>\n<\/tr>\n<tr>\n<td>Built-in NPM registry<\/td>\n<td>Yes<\/td>\n<td>No<\/td>\n<\/tr>\n<tr>\n<td>Built-in Maven registry<\/td>\n<td>Yes<\/td>\n<td>No<\/td>\n<\/tr>\n<tr>\n<td>Artifact Download support<\/td>\n<td>Yes<\/td>\n<td>No<\/td>\n<\/tr>\n<tr>\n<td>Kubernetes dashboard<\/td>\n<td>Yes<\/td>\n<td>Yes<\/td>\n<\/tr>\n<tr>\n<td>Monorepo support<\/td>\n<td>Yes<\/td>\n<td>Yes<\/td>\n<\/tr>\n<tr>\n<td>Preview environments<\/td>\n<td>Yes<\/td>\n<td>Yes<\/td>\n<\/tr>\n<tr>\n<td>Comprehensive API<\/td>\n<td>Yes<\/td>\n<td>Yes<\/td>\n<\/tr>\n<tr>\n<td>Serverless support<\/td>\n<td>Yes<\/td>\n<td>Yes<\/td>\n<\/tr>\n<\/tbody>\n<\/table><\/div>\n<p>New to Codefresh? <a href=\"https:\/\/codefresh.io\/codefresh-signup\/?utm_source=Blog&amp;utm_medium=Post&amp;utm_campaign=CvGitB\">Create Your Free Account Today! <\/a><\/p>\n<input class=\"fooboxshare_post_id\" type=\"hidden\" value=\"9529\"\/>","protected":false},"excerpt":{"rendered":"<p>If you have selected Gitlab as your git provider, you may automatically think about selecting GitlabCI as your CI\/CD solution as well. Using the same vendor for source control and CI\/CD might seem natural, but is not always the best combination. In fact, choosing a \u201cgood-enough\u201d option just because it is part of the same &hellip; <a href=\"https:\/\/codefresh.io\/continuous-integration\/codefresh-versus-gitlabci\/\">Read more<\/a><\/p>\n","protected":false},"author":62,"featured_media":9532,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[1543],"tags":[15,53,59,68],"yoast_head":"<!-- This site is optimized with the Yoast SEO Premium plugin v17.9 (Yoast SEO v18.4.1) - https:\/\/yoast.com\/wordpress\/plugins\/seo\/ -->\n<title>Codefresh vs. GitlabCI - Which one should you use<\/title>\n<meta name=\"description\" content=\"Gitlab is one of the supported GIT providers in Codefresh. In this article, we will look at the advantages of Codefresh compared to the GitlabCI platform.\" \/>\n<meta name=\"robots\" content=\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\" \/>\n<link rel=\"canonical\" href=\"https:\/\/codefresh.io\/continuous-integration\/codefresh-versus-gitlabci\/\" \/>\n<meta property=\"og:locale\" content=\"en_US\" \/>\n<meta property=\"og:type\" content=\"article\" \/>\n<meta property=\"og:title\" content=\"Codefresh vs. GitlabCI\" \/>\n<meta property=\"og:description\" content=\"Gitlab is one of the supported GIT providers in Codefresh. In this article, we will look at the advantages of Codefresh compared to the GitlabCI platform.\" \/>\n<meta property=\"og:url\" content=\"https:\/\/codefresh.io\/continuous-integration\/codefresh-versus-gitlabci\/\" \/>\n<meta property=\"og:site_name\" content=\"Codefresh\" \/>\n<meta property=\"article:publisher\" content=\"https:\/\/www.facebook.com\/codefresh.io\" \/>\n<meta property=\"article:published_time\" content=\"2019-12-10T06:00:29+00:00\" \/>\n<meta property=\"article:modified_time\" content=\"2019-12-13T13:07:48+00:00\" \/>\n<meta property=\"og:image\" content=\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/Blog_Webinar-Kubernetes.jpg\" \/>\n\t<meta property=\"og:image:width\" content=\"1534\" \/>\n\t<meta property=\"og:image:height\" content=\"401\" \/>\n\t<meta property=\"og:image:type\" content=\"image\/jpeg\" \/>\n<meta name=\"twitter:card\" content=\"summary_large_image\" \/>\n<meta name=\"twitter:creator\" content=\"@codefresh\" \/>\n<meta name=\"twitter:site\" content=\"@codefresh\" \/>\n<meta name=\"twitter:label1\" content=\"Written by\" \/>\n\t<meta name=\"twitter:data1\" content=\"Kostis Kapelonis\" \/>\n\t<meta name=\"twitter:label2\" content=\"Est. reading time\" \/>\n\t<meta name=\"twitter:data2\" content=\"15 minutes\" \/>\n<script type=\"application\/ld+json\" class=\"yoast-schema-graph\">{\"@context\":\"https:\/\/schema.org\",\"@graph\":[{\"@type\":\"Organization\",\"@id\":\"https:\/\/codefresh.io\/#organization\",\"name\":\"Codefresh\",\"url\":\"https:\/\/codefresh.io\/\",\"sameAs\":[\"https:\/\/www.facebook.com\/codefresh.io\",\"https:\/\/www.linkedin.com\/company\/codefresh\",\"https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg\",\"https:\/\/twitter.com\/codefresh\"],\"logo\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#logo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png\",\"width\":800,\"height\":800,\"caption\":\"Codefresh\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/#logo\"}},{\"@type\":\"WebSite\",\"@id\":\"https:\/\/codefresh.io\/#website\",\"url\":\"https:\/\/codefresh.io\/\",\"name\":\"Codefresh\",\"description\":\"\",\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"potentialAction\":[{\"@type\":\"SearchAction\",\"target\":{\"@type\":\"EntryPoint\",\"urlTemplate\":\"https:\/\/codefresh.io\/?s={search_term_string}\"},\"query-input\":\"required name=search_term_string\"}],\"inLanguage\":\"en-US\"},{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/continuous-integration\/codefresh-versus-gitlabci\/#primaryimage\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/Blog_Webinar-Kubernetes.jpg\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/Blog_Webinar-Kubernetes.jpg\",\"width\":1534,\"height\":401},{\"@type\":\"WebPage\",\"@id\":\"https:\/\/codefresh.io\/continuous-integration\/codefresh-versus-gitlabci\/#webpage\",\"url\":\"https:\/\/codefresh.io\/continuous-integration\/codefresh-versus-gitlabci\/\",\"name\":\"Codefresh vs. GitlabCI - Which one should you use\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/#website\"},\"primaryImageOfPage\":{\"@id\":\"https:\/\/codefresh.io\/continuous-integration\/codefresh-versus-gitlabci\/#primaryimage\"},\"datePublished\":\"2019-12-10T06:00:29+00:00\",\"dateModified\":\"2019-12-13T13:07:48+00:00\",\"description\":\"Gitlab is one of the supported GIT providers in Codefresh. In this article, we will look at the advantages of Codefresh compared to the GitlabCI platform.\",\"breadcrumb\":{\"@id\":\"https:\/\/codefresh.io\/continuous-integration\/codefresh-versus-gitlabci\/#breadcrumb\"},\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"ReadAction\",\"target\":[\"https:\/\/codefresh.io\/continuous-integration\/codefresh-versus-gitlabci\/\"]}]},{\"@type\":\"BreadcrumbList\",\"@id\":\"https:\/\/codefresh.io\/continuous-integration\/codefresh-versus-gitlabci\/#breadcrumb\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"name\":\"Home\",\"item\":\"https:\/\/codefresh.io\/\"},{\"@type\":\"ListItem\",\"position\":2,\"name\":\"Codefresh vs. GitlabCI\"}]},{\"@type\":\"Article\",\"@id\":\"https:\/\/codefresh.io\/continuous-integration\/codefresh-versus-gitlabci\/#article\",\"isPartOf\":{\"@id\":\"https:\/\/codefresh.io\/continuous-integration\/codefresh-versus-gitlabci\/#webpage\"},\"author\":{\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87\"},\"headline\":\"Codefresh vs. GitlabCI\",\"datePublished\":\"2019-12-10T06:00:29+00:00\",\"dateModified\":\"2019-12-13T13:07:48+00:00\",\"mainEntityOfPage\":{\"@id\":\"https:\/\/codefresh.io\/continuous-integration\/codefresh-versus-gitlabci\/#webpage\"},\"wordCount\":2918,\"commentCount\":1,\"publisher\":{\"@id\":\"https:\/\/codefresh.io\/#organization\"},\"image\":{\"@id\":\"https:\/\/codefresh.io\/continuous-integration\/codefresh-versus-gitlabci\/#primaryimage\"},\"thumbnailUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/Blog_Webinar-Kubernetes.jpg\",\"keywords\":[\"continuous integration\",\"CI\/CD\",\"codefresh\",\"continuous delivery\"],\"articleSection\":[\"Continuous Integration\"],\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"CommentAction\",\"name\":\"Comment\",\"target\":[\"https:\/\/codefresh.io\/continuous-integration\/codefresh-versus-gitlabci\/#respond\"]}]},{\"@type\":\"Person\",\"@id\":\"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87\",\"name\":\"Kostis Kapelonis\",\"image\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/codefresh.io\/#personlogo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png\",\"contentUrl\":\"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png\",\"caption\":\"Kostis Kapelonis\"},\"description\":\"Kostis is a software engineer\/technical-writer dual class character. He lives and breathes automation, good testing practices and stress-free deployments with GitOps.\",\"url\":\"https:\/\/codefresh.io\/author\/kostiscodefresh-io\/\"}]}<\/script>\n<!-- \/ Yoast SEO Premium plugin. -->","yoast_head_json":{"title":"Codefresh vs. GitlabCI - Which one should you use","description":"Gitlab is one of the supported GIT providers in Codefresh. In this article, we will look at the advantages of Codefresh compared to the GitlabCI platform.","robots":{"index":"index","follow":"follow","max-snippet":"max-snippet:-1","max-image-preview":"max-image-preview:large","max-video-preview":"max-video-preview:-1"},"canonical":"https:\/\/codefresh.io\/continuous-integration\/codefresh-versus-gitlabci\/","og_locale":"en_US","og_type":"article","og_title":"Codefresh vs. GitlabCI","og_description":"Gitlab is one of the supported GIT providers in Codefresh. In this article, we will look at the advantages of Codefresh compared to the GitlabCI platform.","og_url":"https:\/\/codefresh.io\/continuous-integration\/codefresh-versus-gitlabci\/","og_site_name":"Codefresh","article_publisher":"https:\/\/www.facebook.com\/codefresh.io","article_published_time":"2019-12-10T06:00:29+00:00","article_modified_time":"2019-12-13T13:07:48+00:00","og_image":[{"width":1534,"height":401,"url":"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/Blog_Webinar-Kubernetes.jpg","type":"image\/jpeg"}],"twitter_card":"summary_large_image","twitter_creator":"@codefresh","twitter_site":"@codefresh","twitter_misc":{"Written by":"Kostis Kapelonis","Est. reading time":"15 minutes"},"schema":{"@context":"https:\/\/schema.org","@graph":[{"@type":"Organization","@id":"https:\/\/codefresh.io\/#organization","name":"Codefresh","url":"https:\/\/codefresh.io\/","sameAs":["https:\/\/www.facebook.com\/codefresh.io","https:\/\/www.linkedin.com\/company\/codefresh","https:\/\/www.youtube.com\/channel\/UC9r94SY6BqN05kXPIHsDXPg","https:\/\/twitter.com\/codefresh"],"logo":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#logo","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/02\/Codefresh_Logo_Vertical_LightBkgd.png","width":800,"height":800,"caption":"Codefresh"},"image":{"@id":"https:\/\/codefresh.io\/#logo"}},{"@type":"WebSite","@id":"https:\/\/codefresh.io\/#website","url":"https:\/\/codefresh.io\/","name":"Codefresh","description":"","publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"potentialAction":[{"@type":"SearchAction","target":{"@type":"EntryPoint","urlTemplate":"https:\/\/codefresh.io\/?s={search_term_string}"},"query-input":"required name=search_term_string"}],"inLanguage":"en-US"},{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/continuous-integration\/codefresh-versus-gitlabci\/#primaryimage","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/Blog_Webinar-Kubernetes.jpg","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/Blog_Webinar-Kubernetes.jpg","width":1534,"height":401},{"@type":"WebPage","@id":"https:\/\/codefresh.io\/continuous-integration\/codefresh-versus-gitlabci\/#webpage","url":"https:\/\/codefresh.io\/continuous-integration\/codefresh-versus-gitlabci\/","name":"Codefresh vs. GitlabCI - Which one should you use","isPartOf":{"@id":"https:\/\/codefresh.io\/#website"},"primaryImageOfPage":{"@id":"https:\/\/codefresh.io\/continuous-integration\/codefresh-versus-gitlabci\/#primaryimage"},"datePublished":"2019-12-10T06:00:29+00:00","dateModified":"2019-12-13T13:07:48+00:00","description":"Gitlab is one of the supported GIT providers in Codefresh. In this article, we will look at the advantages of Codefresh compared to the GitlabCI platform.","breadcrumb":{"@id":"https:\/\/codefresh.io\/continuous-integration\/codefresh-versus-gitlabci\/#breadcrumb"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https:\/\/codefresh.io\/continuous-integration\/codefresh-versus-gitlabci\/"]}]},{"@type":"BreadcrumbList","@id":"https:\/\/codefresh.io\/continuous-integration\/codefresh-versus-gitlabci\/#breadcrumb","itemListElement":[{"@type":"ListItem","position":1,"name":"Home","item":"https:\/\/codefresh.io\/"},{"@type":"ListItem","position":2,"name":"Codefresh vs. GitlabCI"}]},{"@type":"Article","@id":"https:\/\/codefresh.io\/continuous-integration\/codefresh-versus-gitlabci\/#article","isPartOf":{"@id":"https:\/\/codefresh.io\/continuous-integration\/codefresh-versus-gitlabci\/#webpage"},"author":{"@id":"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87"},"headline":"Codefresh vs. GitlabCI","datePublished":"2019-12-10T06:00:29+00:00","dateModified":"2019-12-13T13:07:48+00:00","mainEntityOfPage":{"@id":"https:\/\/codefresh.io\/continuous-integration\/codefresh-versus-gitlabci\/#webpage"},"wordCount":2918,"commentCount":1,"publisher":{"@id":"https:\/\/codefresh.io\/#organization"},"image":{"@id":"https:\/\/codefresh.io\/continuous-integration\/codefresh-versus-gitlabci\/#primaryimage"},"thumbnailUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2018\/07\/Blog_Webinar-Kubernetes.jpg","keywords":["continuous integration","CI\/CD","codefresh","continuous delivery"],"articleSection":["Continuous Integration"],"inLanguage":"en-US","potentialAction":[{"@type":"CommentAction","name":"Comment","target":["https:\/\/codefresh.io\/continuous-integration\/codefresh-versus-gitlabci\/#respond"]}]},{"@type":"Person","@id":"https:\/\/codefresh.io\/#\/schema\/person\/b2f763eca5adecaee359ad3170055d87","name":"Kostis Kapelonis","image":{"@type":"ImageObject","@id":"https:\/\/codefresh.io\/#personlogo","inLanguage":"en-US","url":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png","contentUrl":"https:\/\/codefresh.io\/wp-content\/uploads\/2022\/03\/branded-96x96.png","caption":"Kostis Kapelonis"},"description":"Kostis is a software engineer\/technical-writer dual class character. He lives and breathes automation, good testing practices and stress-free deployments with GitOps.","url":"https:\/\/codefresh.io\/author\/kostiscodefresh-io\/"}]}},"acf":[],"_links":{"self":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/9529"}],"collection":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/users\/62"}],"replies":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/comments?post=9529"}],"version-history":[{"count":0,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/posts\/9529\/revisions"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media\/9532"}],"wp:attachment":[{"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/media?parent=9529"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/categories?post=9529"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/codefresh.io\/wp-json\/wp\/v2\/tags?post=9529"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}